\documentclass[a4paper, 14pt, russian]{extarticle}

\usepackage[top=2.5cm, bottom=1.5cm, left=2cm, right=1cm]{geometry}
\usepackage{fancyvrb}
\fvset{tabsize=2}
\usepackage{polyglossia}
\setmainlanguage{russian} 
\setotherlanguage{english}
\usepackage{setspace}

\usepackage{longtable}
\usepackage{ragged2e}
\setcounter{tocdepth}{2}
  
\setmainfont{Liberation Serif}
\newfontfamily\cyrillicfont{Liberation Serif}
%\setmainfont{Times New Roman}
%\newfontfamily\cyrillicfont{Times New Roman}
\setmonofont{Liberation Mono}
\setsansfont{Liberation Sans}
\newfontfamily\cyrillicfontmono{Liberation Mono}
\newfontfamily\cyrillicfontsans{Liberation Sans}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage[singlelinecheck=false]{caption}
\usepackage{listings, lstautogobble}
\usepackage{color}
\usepackage[table]{xcolor}

\usepackage{caption}
\DeclareCaptionFont{black}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{codeheaderbg}
	{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]
	{format=listing,labelfont=black,textfont=black}

\usepackage{enumitem}

\lstdefinestyle{framed}
{
     frame=none,         
     belowcaptionskip=2pt,
     xleftmargin=8pt,
     framexleftmargin=7pt,
     framexrightmargin=5pt,
     framextopmargin=10pt,
     framexbottommargin=5pt,
     framesep=0pt,
     rulesep=0pt,
     texcl=true
}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\definecolor{codebg}{rgb}{0.97, 0.97, 0.97}
\definecolor{codeheaderbg}{rgb}{0.90, 0.90, 0.90}
\definecolor{orange}{rgb}{0.8, 0.4, 0.0}
\definecolor{bluemarin}{RGB}{12, 134, 145}
\definecolor{grey}{rgb}{0.5, 0.5, 0.5}
\definecolor{function}{RGB}{11, 145, 89}
\definecolor{blue2}{RGB}{15, 92, 198}

\lstdefinelanguage{icL}{
	keywords={if, else, for, filter, range, exists, while, 
			  do, any,emit, emiter, slot, @, \#},
	keywordstyle=\color{blue2},
	keywords=[2]{boolean, int, double, string, list, element,
				 set, item, object, function},
	keywordstyle=[2]\color{bluemarin},
	classoffset=3,
	morekeywords={_log, _define, _tab, _dom, _define, _import},
	keywordstyle=\color{orange},
	classoffset=4,
	morekeywords={info, warm, error, signal, get, query,
				  queryAll, null, Prepend, Append, Insert,
				  Merge, PopFront, PopBack, Remove, RemoveOnce,
				  RemoveAll, Get, IndexOf, LastIndexOf,
				  Join, SumUp, Max, Min, LogicAnd, LogicOr,
				  Length, Text, HTML, Width, Height, Click,
				  ScrollTo, SendKeys, IsValid, Copy, Add,
				  Filter, Query, QueryAll, Visible, Clickable,
				  Next, Prev, Parent, Child, Closest, AddClass,
				  HasClass, RemoveClass, all, functions, none,
				  run, close},
	keywordstyle=\color{function},
	classoffset=5,
	morekeywords={UnrealCast, StringParse, EmptyList,
				  MultipleValues, NullElement, NotVisible,
				  WrongName, OutOfBounds, OutOfScreen,
				  FileNotFound},
	classoffset=0,
	identifierstyle=\color{black},
	sensitive=true,
	comment=[l]{``},
	morecomment=[s]{```}{```},
	morecomment=[s]{`c}{t`},
	commentstyle=\color{grey},
	stringstyle=\color{purple},
	morestring=[b]"
}

\newcommand\digitstyle{\color{red}}
\makeatletter
\newcommand{\ProcessDigit}[1]
{%
  \ifnum\lst@mode=\lst@Pmode\relax%
   {\digitstyle #1}%
  \else
    #1%
  \fi
}
\makeatother

\usepackage{chngcntr}

\newenvironment{icItems}
	{ \begin{itemize} [noitemsep,nolistsep] }
	{ \end{itemize} } 

\newenvironment{icEnumResume}
	{ \begin{enumerate}[noitemsep,nolistsep,resume] }
	{ \end{enumerate} } 

\newenvironment{icEnum}
	{ \begin{enumerate}[noitemsep,nolistsep] }
	{ \end{enumerate} } 

\begin{document}

%\renewcommand{\rmdefault}{ftm}
\counterwithin{lstlisting}{section}
\counterwithin{table}{section}

\renewcommand{\lstlistingname}{Листинг}

\setlength\abovecaptionskip{2pt}
\setlength\belowcaptionskip{1pt}

\lstset{
	language=icL,
	literate=
  		{0}{{{\ProcessDigit{0}}}}1
  		{1}{{{\ProcessDigit{1}}}}1
  		{2}{{{\ProcessDigit{2}}}}1
  		{3}{{{\ProcessDigit{3}}}}1
  		{4}{{{\ProcessDigit{4}}}}1
  		{5}{{{\ProcessDigit{5}}}}1
  		{6}{{{\ProcessDigit{6}}}}1
  		{7}{{{\ProcessDigit{7}}}}1
  		{8}{{{\ProcessDigit{8}}}}1
  		{9}{{{\ProcessDigit{9}}}}1
  		{-}{{{\ProcessDigit{-}}}}1
  		{<=}{{\(\leq\)}}1,
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	showtabs=false,
	numbers=left,
	stepnumber=1,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=true,
	backgroundcolor=\color{codebg},
	style=framed,
	lineskip=0pt,
	aboveskip=0pt,
	autogobble=true
}
	
\setlength{\LTleft}{0pt}
\onehalfspacing

\newcommand{\greycell}[1]{\cellcolor{lightgray}\centering\textbf{#1}}

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\tabletwo}[7]{
	\begin{longtable}[h]{p{#1}}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\stabletwo}[7]{
	\begin{longtable}[h]{|p{#1}|p{#2}|}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\tablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\stablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\tableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	#2
	#3
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	#3
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#6
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\stableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	#2
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	#2
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#5
	\end{longtable}
}

% Содержимое докимента
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Стандарт языка описания сценариях icL v1.0.0 черновик}
\author{Лелицак Василе}

\maketitle

\newpage
\renewcommand{\contentsname}{\textsf{Оглавление}}
\tableofcontents
	
\newpage

\section{Введение}	
	
\indent \textbf{icL} - \textbf{язык описания сценариев}, оптимизирован под описания сценариев тестирования веб-приложений.
	
\subsection{Читатели}
	
	Этот документ предназначен для всех тех людей, которые ищут отравную точку, откуда можно начать изучать язык icL. Также данный документ используется при разработке интерпретатора, поведения интерпретатора во всех ситуациях не описанных в данном документе считается не определённой.
	
\subsection{Что вы должны уметь}
	
Прежде чем выступать к изучения этого языка, вам желательно иметь базовое представление о компьютерном программировании.
	
\subsection{Обзор языка icL}
	
	icL - язык сценариев тестирования веб-приложений. Его разработка началась в 2017 году и первый выпуск планируется к 2020 году. В настоящий момент он находится в активном разработке.
	
	icL - \textbf{язык с С-подобным синтаксисом}, который использует статическую типизацию. В icL нельзя определить собственные типы данных, так как он разработан не для программистов, знания получены в школе на уроках информатики должны быть достаточными. Язык icL поддерживает только одну парадигму программирования - процедурная. При необходимости обработать данные, можно использовать экспорт/импорт в/из cvs и базы данных.
	
\subsection{Пример кода}

	В icL точка входа в программе - начало файла, программа \textit{Hello world!} иллюстрирована на листинге \ref{example0}.
	
\begin{lstlisting}[caption=Пример, label=example0]
`` comment example
_log.info "Hello world";
\end{lstlisting}
  
\subsection{Изучение icL}
	
	Самое важное при изучении icL - это сосредоточиться на идеях и не потеряться в технических деталях его реализации.
	
\subsection{Области применения icL}
	
	Язык icL является частью \textbf{программы icL}, с его помощью можно управлять браузером, а именно:
\begin{icItems}
	\item открыть вкладку;
	\item закрыть вкладку;
	\item перейти на веб-страницу;
	\item симулировать события клавиатуры и мышке;
	\item взаимодействовать с веб-страницей;
	\item выполнить код на языке javascript;
	\item управлять веб-страницей;
	\item обменять информацию с веб-страничкой;
	\item сделать screenshot;
	\item сохранить страницу в формате pdf;
	\item управлять памятью;
	\item экспортировать данные в csv файле;
	\item импортировать данные из csv файл;
	\item выполнить запросы на языке SQL.
\end{icItems}
	
\subsection{Начало работы}
	
	Чтобы начать работать достаточно установить и запустить программу icL.
	
\newpage
\section{Базовый синтаксис}
	
	icL достаточно прост в освоении, вставите код с листинга \ref{first} в icL и выполняете его. Первую программу можно уже сохранить в файле с расширением icl.
	
\begin{lstlisting}[caption=Первая программа, label=first]
_log.info "Test!";
\end{lstlisting}
	
	В консоль можем увидеть следующий \textbf{вывод программы}:
	
\begin{lstlisting}[numbers=none]
Test!
\end{lstlisting}
	
\subsection{Импорт в icL}
	
	Все \textbf{стандартные библиотеки} встроены в языке, но можно написать импортировать \textbf{пользовательские}, с помощью:
\begin{icItems}
	\item \lstinline`_import.none "path/to/file.iclib"` - выполнить код, который содержатся в файле, ничего не импортировать.
	\item \lstinline`_import.functions "path/to/file.iclib"` - выполнить код и импортировать функций; {\color{red}Важно:} импортированные функций не должны использовать глобальные переменные.
	\item \lstinline`_import.all "path/to/file.iclib"` -  выполнить код, импортировать функций и глобальные переменные;
	\item \lstinline`_import.run "path/to/file.iclib"` - выполнить код в текущем контексте, все функции и глобальные переменные импортируется и экспортируется;
\end{icItems}
	
\subsection{Токены в icL}
	
	Программа на icL состоит из различных \textbf{токенов} (литералов, семантических конструкциях), а токен может являться ключевым словом, идентификатором, константной, строковым литералом, либо символом. Например следующая команда состоит из четырёх токенов: \lstinline`_log.info "Hello world!";`
	
	Отдельными токенами являются:
\begin{icItems}
	\item \lstinline`_log` - идентификатор объекта;
	\item \lstinline`.info` - идентификатор метода;
	\item \lstinline`"Hello world!"` - строковый литерал;
	\item \lstinline`;` - разделитель, конец команды.
\end{icItems}
	
\subsection{Комментарии}
	
	\textbf{Комментарии} - это вспомогательный текст, который помогает понимать написанных сценариях, они полностью игнорируется командного процессора. 
	
	\textbf{Комментарии в линии} (\textit{inline}) являются строковым литералом ограниченным специальными кавычками \texttt{`}, как показано на листинге \ref{inlinecomment}.
	
\begin{lstlisting}[caption=Комментарий в линии,label=inlinecomment]
No comment `comment` no comment
\end{lstlisting}
	
	\textbf{Одиночный комментарий} записывается в использованием символов \texttt{``} в начале, смотрите листинг \ref{linecomment}.
	
\begin{lstlisting}[caption=Одиночный комментарий,label=linecomment]
No comment `` comment
\end{lstlisting}
	
	\textbf{Многострочный комментарий} начинается и заканчивается с \texttt{```}, пример многострочного комментария приведён на листинге \ref{multilinecomment}.
	
\begin{lstlisting}[caption=Многострочный комментарий,label=multilinecomment]
No comment
``` comment 1
	comment 2
	comment 3
``` No comment
\end{lstlisting}
	
\subsection{Идентификторы}
	
	\textbf{Идентификатор} в icL - это имя, используемое для идентификации переменной, функций, методов и свойств. Идентификатор начинается с символов обозначающий его предназначение(\lstinline`@`, \lstinline`#`, \lstinline`!`, \lstinline`_`, \lstinline`.` или \lstinline`'`), за которым следует от 2 до 32 букв(английского или национального алфавита) и цифр (от 0 до 9).
	
	icL - чувствительный к регистру язык. Таким образом \textit{@var} и \textit{@Var} являются двумя разными идентификаторами. Вот несколько примеров допустимых идентификаторов:
	
\begin{lstlisting}[numbers=none]
#loop		_tab		.Append		'Length	_dom	@ii 	@VAR
@variable	!sumPoints	#global		.Merge	.Get	#01		!SIN
\end{lstlisting}
	
\subsection{Ключевые слова}
	
	В icL \textbf{ключевые слова} не зарезервированные. Их всего 11: \lstinline`if`, \lstinline`for`, \lstinline`filter`, \lstinline`range`, \lstinline`exists`, \lstinline`while`, \lstinline`do`, \lstinline`any`, \lstinline`emit`, \lstinline`emiter` и \lstinline`slot`. В данном документе они выделены синим цветом.
  
\subsection{Пробельные символы и разделители}
	
	\textbf{Пробельный символ} (\textit{whitespace}) - этот термин используется в icL для описания пробелов, символов табуляции, символов новой строкой и комментариев. Пробельные символы не обязательные, они используется для улучшения читабельности кода. На листинге \ref{unreadable} показан пример кода без пробельных символов, а на листинге \ref{readable} с пробельными символами.
	
\begin{lstlisting}[caption=Koд без пробельных символов,label=unreadable]
if(_tab.get"mai.ru"){(_dom.query"button").Click;}else{_log.error"The site mai.ru is unaviable";};
\end{lstlisting}
	
\begin{lstlisting}[caption=Koд с пробельных символов,label=readable]
`` the begin of program

`` try to go to mai.ru
if (_tab.get "mai.ru") {
	`` site loaded successfull
	`` click the button
	(_dom.query "button").Click;
}
else {
	`` try again later
	`` now log the error
	_log.error "The site mai.ru is unaviable";
};

`` end of the program
\end{lstlisting}
	
	В icL присутствует только один разделитель - \textbf{разделитель команд} \lstinline`;`. Команда - это набор токенов, распределенных в определённом порядке и характеризующее действие. Примеры команд: открыть сайт - \lstinline`_tab.get "URL"`, закрыть вкладку - \lstinline`_tab.close`.
	
	При описании последовательности действий, их надо разделить, например последовательность вышеперечисленных команд описывается так:	
\begin{lstlisting}[numbers=none]
_tab.get "URL"; _tab.close
\end{lstlisting} 
	
	Таким образом из команд собираем сценарии. Перед закрывающих скобок ставить разделитель команд опционально.
	
\subsubsection{Дополнительные сведение}
	
	Если у вас нет знании в программировании перейдите пожалуйста на третью главу.
	
	В icL отсутствуют разделители между значениями в списке. Примеры:
\begin{icItems}
  \item Инициализация списка в С++:
\begin{lstlisting}[numbers=none, language=C++]
std::list<std::string> list = {"one", "two", "three"};
\end{lstlisting}
	Инициализация списка в icL:
\begin{lstlisting}[numbers=none]
@list = ["one" "two" "three"];
\end{lstlisting}
  \item Функция в С++:
\begin{lstlisting}[numbers=none, language=C++]
int sum (int number1, int number2) { return number1 + number2; };
\end{lstlisting}
	Функция в icL:
\begin{lstlisting}[numbers=none]
!sum = <int>number1 <int>number2 : int { @ = number1 + number2 };
\end{lstlisting}
  \item Вызов функций в С++:
\begin{lstlisting}[numbers=none, language=C++]
int s = sum (100, 200);
\end{lstlisting}
	Вызов функций в icL:
\begin{lstlisting}[numbers=none]
@sum = !sum 100 200;
\end{lstlisting}
  \item Код на С++:
\begin{lstlisting}[numbers=none, language=C++]
sum (100 + 50, 200);
\end{lstlisting}
	Эквивалент на icL:
\begin{lstlisting}[numbers=none]
!sum (100 + 50) 200;
\end{lstlisting}
\end{icItems}

\newpage
\section{Переменные}  
	
	\textbf{Переменная} - название области хранения, который могут манипулировать сценария. Каждая переменная в icL имеет область видимость (фрагмент кода где можно её использовать) и тип, который определяет размер и способ размещения памяти переменной; диапазон значений которые можно применить к переменной.
	
	Имя переменной является идентификатором, начинающийся с \lstinline`@` или {\color{blue2}\lstinline`#`}.
	\textbf{Основные типы} переменных показаны в таблице \ref{variablestypes}.

\stabletwo{2cm}{15.1cm}{variablestypes}{Типы переменных}%
	{Тип}{Описание}%
	{ 
	boolean & Логическое значения, имеет в состояние: истинно или лож. \\ \hline
	int & Целое число, позволяет хранить значения от -2.147.483.648 до 2.147.483.647. \\ \hline
	double & Дробное число, позволяет хранить вещественные числа. \\
	}
	
	icL также присутствуют и \textbf{сложные типы} переменных, такие как строки, списки, множества, объекты, которые мы посмотрим в полеживающих главах. В этой главе изучаем только основные типы.
	
\subsection{Объявления и инициализация переменных}
	
	\textbf{Объявления и инициализация} переменных, также операция \textit{присваивание} в icL неотличимы, и имеют общий вид \lstinline`a = b`, где \lstinline`a` новая или существующая переменная, а \lstinline`b` - значение. В тех случаев когда переменная \textbf{встречается первый раз}, мы её объявляем и инициализируем. В противном случае мы присваиваем ей значение.
	
	На листинге \ref{initexample} показаны несколько пример объявлений и инициализации переменных, обратите внимание что дробные числа пишется через точку, а не через запятую как принято в Европе и Российском Федераций.
  	
\begin{lstlisting}[caption=Пример объявлений и инициализации символов,label=initexample]
@bool = false;
@catched = true;
@int = 234;
@double = 23.4;
#pi = 3.14;
#negative = -100.0;
\end{lstlisting}

\subsection{Локальные переменные}
	
	\textbf{Локальные переменные} имею узкую область видимость, ограниченные фигурными скобками которые их охватывает, и только после их объявлений. 
	
	{\bf Идентификаторы} локальных переменных начинается с символом \lstinline`@`. 
	
	На листинге \ref{localvars} показана область видимость переменной \lstinline`@var`, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test6` - она не видна, когда в точках объявления переменных \lstinline`@test3`, \lstinline`@test4` и \lstinline`@test5` - да.
\begin{lstlisting}[caption=Область видимости локальных перемен, label=localvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var; 
	`` initialization
	@var = 0;
	`` ok
	@test3 = @var;
	if (@) {
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var; 
}
`` error
@test6 = @var; 
\end{lstlisting}

\subsection{Глобальные переменные}

	\textbf{Глобальные переменные} имеют самую широкую область видимости, их видны из любой точке программы после их инициализации. Использовать глобальные переменные не рекомендуется, так как они могут привести к серьезных ошибок. 
	
	{\bf Идентификаторы} глобальных переменных начинается с символом {\color{blue2}\lstinline`#`}. Локальные переменные с одной названий могут быть несколько, когда глобальные - нет. Идентификатор глобальной переменной уникальный.
	
	Как указано на листинге \ref{globalvars}, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test3` переменная \lstinline`@var` не видна, когда в точках объявления переменных \lstinline`@test4`, \lstinline`@test5` и \lstinline`@test6` - да.
	
\begin{lstlisting}[caption=Область видимости глобальных перемен, label=globalvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var; 
	if (@) {
		`` error
		@test3 = @var;
		`` initialization
		@var = 0;
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var; 
}
`` ok
@test6 = @var;
\end{lstlisting}

\subsection{Левые и правые значения в icL}

	В icL присутствуют 3 типа значении:
\begin{icEnum}
	\item левые значения {\it lvalue} - переменные;
	\item правые значения {\it rvalue} - переменные и константы;
	\item javascript значения {\it jsvalue} - их будем рассматривать позже.
\end{icEnum}
	
	Левые значения могут находится с обеих сторон знака {\it присваивание}, когда правые - только справа. Примеры правильно и неправильно кода иллюстрированы на листинге \ref{rlvalues};
\begin{lstlisting}[caption=Левые и правые значения, label=rlvalues]
@a1 = @a2; @a3 = 123; `` ok
123 = @a1; 125 = 456; `` error 
\end{lstlisting}

\subsection{Выводы}

	{\bf Работа с переменными в icL} - максимально проста, но продвинутых пользователях без знания в программировании рекомендуется не использовать глобальные переменные. Для написания сценариях средней и низкой сложности, локальные переменные лучше подходят. 

\section{Типы данных}

	В языке описания сценариев icL, типы данных выполняют очень важную роль, они определяют как данные будут храниться и обработаться в процессе выполнения программы. Классификация типов данных представлена в таблице \ref{datatypeclasses}.
	
\stabletwo{3.5cm}{13.6cm}{datatypeclasses}{Категории типов данных}
	{Категория}{Описание}
	{
	Базовые & Типы данных описанных в предыдущем главе: boolean - логический, int - целое - числа, double - дробные числа. \\ \hline
	Сложные & Типы данные содержащие несколько значении в контейнерах, примеры таких данных: строки, списки, множество. \\ \hline
	Системные & Типы данных которых нельзя создать и хранить в пользовательских переменных, но доступ к ними можно получить через системные (предопределённых) переменных, примеры таких данных: браузер, вкладка, история браузера, окно. \\ \hline
	Тип \textit{void} & Тип данных обозначающий отсутствия данных.
	}
	
\subsection{Основные типы данных}

	{\bf Основные типы данных} участвуют в логических и арифметических операциях языка icL. Логическими операциями являются конъюнкция, дизъюнкция, исключающий или, эквиваленция и инверсия. Логическими операциями являются сложения, вычитания, умножения, деления, извлечения корня и возведения в степень.
	
\subsection{Сложные типы данных}

	{\bf Сложные типы данных} специализированные под хранения больших массивов данных. Строка позволяет хранить более двух миллиардов символов. Список позволяет хранить более двух миллиардов строк. А множество позволяет хранить большой объём данных ограничен только оперативной памяти. Объект позволяет инкапсулировать данные разного рода по одном именем. Элемент позволяет хранить ссылку на один или несколько HTML-тэгов.

\subsection{Системные типы данных}

	{\bf Системные типы данных} позволяют взаимодействовать с веб-страницей и браузером. Подробную информацию можно найти в главах \ref{webelments} и \ref{dataexchange}.
	
\subsection{Тип данных void}

	{\bf Тип данных {\it void}} означает отсутствия информации, он используется в самых различных целях:
\begin{icItems}
	\item указать то что функция ничего не возвращает;
	\item указать на то что в процессе работы функций произошла ошибка;
	\item выбрать источник данных;
	\item фильтровать данные;
	\item удалить переменных состояния;
	\item и другие.
\end{icItems}

\newpage
\section{Прогресс}

{\color{red}Материал для продвинутых пользователей.}
  	
\begin{icEnum}
	\item + Введение
	\item + Базовый синтаксис
	\item + Переменные
	\item - Типы данных
	\item - Литералы
	\item - Операторы
	\item - Циклы
	\item - Условные операторы
	\item - Интеграция с Javascript
	\item - Функции
	\item - Строки
	\item - Списки
	\item - Многоженства
	\item - Объекты
	\item - Веб-элементы (симуляция мышки и клавиатуры) webelments
	\item - Обмен данных в веб-странницей (конкретные примеры) dataexchange
	\item - DSV / CSV / TSV
\end{icEnum}
  	
	{\color{red}далее материал для программистов, дополнительные возможности, просьба не читать далее материал если нету желание или необходимость.}
	
\begin{icEnumResume}
	\item - Механизм состояний
	\item - Базы данных (только SQLite в первой версии)
	\item - Обработка ошибок
	\item - Программирование errorless
	\item - Программирование на лету
\end{icEnumResume}
	
\end{document}
