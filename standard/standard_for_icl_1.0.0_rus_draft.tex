\documentclass[a4paper, 14pt]{extarticle}

\usepackage[top=2.5cm, bottom=1.5cm, left=2cm, right=1cm]{geometry}
\usepackage{fancyvrb}
\fvset{tabsize=2}
\usepackage{polyglossia}
\setmainlanguage{russian}
\setotherlanguage{english}
\usepackage{setspace}
\usepackage[hidelinks]{hyperref}

\usepackage{longtable}
\usepackage{ragged2e}
\setcounter{tocdepth}{2}

\setmainfont{Liberation Serif}
\newfontfamily\cyrillicfont{Liberation Serif}
\setmonofont{Liberation Mono}
\setsansfont{Liberation Sans}
\newfontfamily\cyrillicfontmono{Liberation Mono}
\newfontfamily\cyrillicfontsans{Liberation Sans}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage[singlelinecheck=false]{caption}
\usepackage{listings, lstautogobble}
\usepackage{color}
\usepackage[table]{xcolor}

\usepackage{caption}
\DeclareCaptionFont{black}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{codeheaderbg}
	{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]
	{format=listing,labelfont=black,textfont=black}

\usepackage{enumitem}

\lstdefinestyle{framed}
{
     frame=none,
     belowcaptionskip=2pt,
     xleftmargin=8pt,
     framexleftmargin=7pt,
     framexrightmargin=5pt,
     framextopmargin=10pt,
     framexbottommargin=5pt,
     framesep=0pt,
     rulesep=0pt,
     texcl=true
}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\definecolor{codebg}{rgb}{0.97, 0.97, 0.97}
\definecolor{codeheaderbg}{rgb}{0.90, 0.90, 0.90}
\definecolor{orange}{rgb}{0.8, 0.4, 0.0}
\definecolor{bluemarin}{RGB}{12, 134, 145}
\definecolor{grey}{rgb}{0.5, 0.5, 0.5}
\definecolor{function}{RGB}{11, 145, 89}
\definecolor{blue2}{RGB}{15, 92, 198}

\newcommand{\ferror}[1]{{\fontsize{11pt}{12pt} \tt \colorbox{function}{\textcolor{white}{#1}}}}

\newcommand{\cerror}[1]{{\fontsize{11pt}{12pt} \tt \colorbox{red!75!blue}{\textcolor{white}{#1}}}}

\lstdefinelanguage{icL}{
	keywords={if, else, for, filter, range, exists, while, do, any,emit, emiter, slot, @, \#},
	keywordstyle=\color{blue2},
	keywords=[2]{bool, int, double, string, list, element, set, item, object, function, void, request, char, regex},
	keywordstyle=[2]\color{bluemarin},
	classoffset=3,
	morekeywords={_log, _define, _tab, _dom, _define, _import, true, false, _numbers, _types, _key, _alert},
	keywordstyle=\color{orange},
	classoffset=4,
	morekeywords={info, warm, error, signal, at, query, queryAll, null, prepend, append, insert, merge, popFront, popBack, remove, removeOnce, removeAll, get, indexOf, lastIndexOf, join, sumUp, max, min, logicAnd, logicOr, length, text, html, width, height, click, scrollTo, sendKeys, isValid, copy, add, filter, query, queryAll, visible, clickable, next, prev, parent, child, closest, addClass, hasClass, removeClass, all, functions, none, run, close, process, setProcess, restoreProcess, product, sum, min, max, empty, out, typeName, typeId, rValue, lValue, readOnly, link, last, ensureRValue, split, right, replace, mid, leftJustified, rightJustified, left, right, endsWith, beginsWith, count, compare, substring, trim, contains, clear, move, removeAt, removeDuplicates, removeFirst, removeLast, removeOne, replaceInStrings, sort, capacity, applicate, getField, insertBoolField, insertIntField, insertDoubleField, insertListField, insertStringField, removeField, attr, css, enabled, prop, rect, selected, tag, queryAllByXPath, queryByXPath, queryLink, queryLinks, queryTags, queryTag, screenshot, ctrl, shift, alt, title, source, url, back, forward, refresh, canGoBack, canGoForward, accept, dismiss},
	keywordstyle=\color{function},
	classoffset=5,
	morekeywords={UnrealCast, StringParse, EmptyList, MultipleValues, NullElement, NotVisible,  WrongName, OutOfBounds, OutOfScreen, FileNotFound, icL, w3c},
	keywordstyle=\color{red},
	classoffset=0,
	identifierstyle=\color{black},
	sensitive=true,
	comment=[l]{``},
	morecomment=[s]{```}{```},
	morecomment=[s]{`c}{t`},
	commentstyle=\color{grey},
	stringstyle=\color{purple},
	morestring=[b]",
	morestring=[b]//
}

\let\counterwithout\relax
\let\counterwithin\relax
\usepackage{chngcntr}

\newenvironment{icItems}
	{ \begin{itemize} [noitemsep,nolistsep] }
	{ \end{itemize} }

\newenvironment{icEnumResume}
	{ \begin{enumerate}[noitemsep,nolistsep,resume] }
	{ \end{enumerate} }

\newenvironment{icEnum}
	{ \begin{enumerate}[noitemsep,nolistsep] }
	{ \end{enumerate} }

\begin{document}

%\renewcommand{\rmdefault}{ftm}
\counterwithin{lstlisting}{section}
\counterwithin{table}{section}

\renewcommand{\lstlistingname}{Листинг}

\setlength\abovecaptionskip{2pt}
\setlength\belowcaptionskip{1pt}

\lstset{
	language=icL,
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	showtabs=false,
	numbers=left,
	stepnumber=1,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=true,
	backgroundcolor=\color{codebg},
	style=framed,
	lineskip=0pt,
	aboveskip=0pt,
	autogobble=true
}

\setlength{\LTleft}{0pt}
\onehalfspacing

\newcommand{\greycell}[1]{\cellcolor{lightgray}\centering\textbf{#1}}

\newcommand{\code}[1]{ \lstinline|#1| }
\newcommand{\true}{\lstinline|true|}
\newcommand{\false}{\lstinline|false|}
\newcommand{\bool}{\lstinline|bool|}
\newcommand{\integer}{\lstinline|int|}
\newcommand{\double}{\lstinline|double|}
\newcommand{\str}{\lstinline|string|}
\newcommand{\listtype}{\lstinline|list|}
\newcommand{\element}{\lstinline|element|}
\newcommand{\set}{\lstinline|set|}
\newcommand{\setitem}{\lstinline|item|}
\newcommand{\object}{\lstinline|object|}
\newcommand{\function}{\lstinline|function|}
\newcommand{\void}{\lstinline|void|}
\newcommand{\request}{\lstinline|request|}
\newcommand{\chartype}{\lstinline|char|}
\newcommand{\regex}{\lstinline|regex|}
% \newcommand{}{ \lstinline|| }

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\tabletwo}[7]{
	\begin{longtable}[h]{p{#1}}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\stabletwo}[7]{
	\begin{longtable}[h]{|p{#1}|p{#2}|}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\tablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\stablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\tableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	#2
	#3
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	#3
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#6
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\stableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	#2
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	#2
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#5
	\end{longtable}
}

% Содержимое докимента
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Стандарт языка описания сценариев icL v1.0.0 Черновик}
\author{Лелицак Василе}

\maketitle

\newpage
\renewcommand{\contentsname}{\textsf{Оглавление}}
\tableofcontents

\newpage

\section{Введение}

\indent \textbf{icL} - \textbf{язык описания сценариев}, оптимизирован под описания сценариев тестирования веб-приложений.

\subsection{Читатели}

Этот документ предназначен для всех тех людей, которые ищут отравную точку, откуда можно начать изучать язык icL. Также данный документ используется при разработке интерпретатора, поведения командного процессора во всех ситуациях неописанных в данном документе считается неопределённой.

\subsection{Что вы должны уметь}

Прежде чем выступать к изучению этого языка, вам желательно иметь базовое представление о компьютерном программировании.

\subsection{Обзор языка icL}

icL - язык сценариев тестирования веб-приложений. Его разработка началась в году, и первый выпуск планируется к 2020 году. В настоящий момент он находится в активной разработке.

icL - \textbf{язык с С-подобным синтаксисом}, который использует статическую типизацию. В icL нельзя определить собственные типы данных, так как он разработан не для программистов, знания получены в школе на уроках информатики должны быть достаточны. Язык icL поддерживает только одну парадигму программирования - процедурная. При необходимости обработать данные, можно использовать экспорт/импорт в/из cvs и базы данных.

\subsection{Пример кода}

В icL точка входа в программе - начало файла, программа \textit{Hello world!} иллюстрирована на листинге \ref{example0}.

\begin{lstlisting}[caption=Пример, label=example0]
`` comment example
_log.info "Hello world";
\end{lstlisting}

\subsection{Изучение icL}

Самое важное при изучении icL - это сосредоточиться на идеях и не потеряться в технических деталях его реализации.

\subsection{Области применения icL}

Язык icL является частью \textbf{программы icL}, с его помощью можно управлять браузером, а именно:
\begin{icItems}
\item
	открыть вкладку;
\item
	закрыть вкладку;
\item
	перейти на веб-страницу;
\item
	симулировать события клавиатуры и мышке;
\item
	взаимодействовать с веб-страницей;
\item
	выполнить код на языке javascript;
\item
	управлять веб-страницей;
\item
	обменять информацию с веб-страничкой;
\item
	сделать screenshot;
\item
	сохранить страницу в формате pdf;
\item
	управлять памятью;
\item
	экспортировать данные в csv файле;
\item
	импортировать данные из csv файл;
\item
	выполнить запросы на языке SQL.
\end{icItems}

\subsection{Начало работы}

Чтобы начать работать достаточно установить и запустить программу icL.

\newpage
\part{Материал для продвинутых пользователях}

Данная часть предназначено для основных принципов построения языка icL. Рассчитана она на продвинутых пользователях с минимальных знания программирования.

\section{Базовый синтаксис}

icL достаточно прост в освоении, вставите код с листинга \ref{first} в icL и выполняете его. Первую программу можно уже сохранить в файле с расширением icl.

\begin{lstlisting}[caption=Первая программа, label=first]
_log.info "Test!";
\end{lstlisting}

В консоль можем увидеть следующий \textbf{вывод программы}:

\begin{lstlisting}[numbers=none]
Test!
\end{lstlisting}

\subsection{Импорт в icL}

Все \textbf{стандартные библиотеки} встроены в языке, но можно написать импортировать \textbf{пользовательские}, с помощью:

\begin{icItems}
\item
	\lstinline|_import.none "path/to/file.iclib"| - выполнить код, который содержатся в файле, ничего не импортировать.
\item
	\lstinline|_import.functions "path/to/file.iclib"| - выполнить код и импортировать функций; {\color{red}Важно:} импортированные функций не должны использовать глобальные переменные.
\item
	\lstinline|_import.all "path/to/file.iclib"| -  выполнить код, импортировать функций и глобальные переменные;
\item
	\lstinline|_import.run "path/to/file.iclib"| - выполнить код в текущем контексте, все функции и глобальные переменные импортируется и экспортируется;
\end{icItems}

\subsection{Токены в icL}

Программа на icL состоит из различных \textbf{токенов} (литералов, семантических конструкциях), а токен может являться ключевым словом, идентификатором, константной, строковым литералом, либо символом. Например следующая команда состоит из четырёх токенов: \lstinline`_log.info "Hello world!";`

Отдельными токенами являются:

\begin{icItems}
\item
	\lstinline`_log` - идентификатор объекта;
\item
	\lstinline`.info` - идентификатор метода;
\item
	\lstinline`"Hello world!"` - строковый литерал;
\item
	\lstinline`;` - разделитель, конец команды.
\end{icItems}

\subsection{Комментарии}

\textbf{Комментарии} - это вспомогательный текст, который помогает понимать написанных сценариях, они полностью игнорируется командного процессора.

\textbf{Комментарии в линии} (\textit{inline}) являются строковым литералом ограниченным специальными кавычками \texttt{`}, как показано на листинге \ref{inlinecomment}.

\begin{lstlisting}[caption=Комментарий в линии,label=inlinecomment]
No comment `comment` no comment
\end{lstlisting}

\textbf{Одиночный комментарий} записывается с использованием символов \texttt{``} в начале, смотрите листинг \ref{linecomment}.

\begin{lstlisting}[caption=Одиночный комментарий,label=linecomment]
No comment `` comment
\end{lstlisting}

\textbf{Многострочный комментарий} начинается и заканчивается с \texttt{```}, пример многострочного комментария приведён на листинге \ref{multilinecomment}.

\begin{lstlisting}[caption=Многострочный комментарий,label=multilinecomment]
No comment
``` comment 1
	comment 2
	comment 3
``` No comment
\end{lstlisting}

\subsection{Идентификторы}

\textbf{Идентификатор} в icL - это имя, используемое для идентификации переменной, функций, методов и свойств. Идентификатор начинается с символов обозначающий его предназначение(\lstinline`@`, \lstinline`#`, \lstinline`!`, \lstinline`_`, \lstinline`.` или \lstinline`'`), за которым следует от 2 до 32 букв(английского или национального алфавита) и цифр (от 0 до 9).

icL - чувствительный к регистру язык. Таким образом \textit{@var} и \textit{@Var} являются двумя разными идентификаторами. Вот несколько примеров допустимых идентификаторов:

\begin{lstlisting}[numbers=none]
#loop		_tab		.Append		'Length	_dom	@ii 	@VAR
@variable	!sumPoints	#global		.Merge	.Get	#01		!SIN
\end{lstlisting}

\subsection{Ключевые слова}

В icL \textbf{ключевые слова} не зарезервированные. Их всего 11: \lstinline`if`, \lstinline`for`, \lstinline`filter`, \lstinline`range`, \lstinline`exists`, \lstinline`while`, \lstinline`do`, \lstinline`any`, \lstinline`emit`, \lstinline`emiter` и \lstinline`slot`. В данном документе они выделены синим цветом.

\subsection{Пробельные символы и разделители}

\textbf{Пробельный символ} (\textit{whitespace}) - этот термин используется в icL для описания пробелов, символов табуляции, символов новой строкой и комментариев. Пробельные символы не обязательные, они используются для улучшения читабельности кода. На листинге \ref{unreadable} показан пример кода без пробельных символов, а на листинге \ref{readable} с пробельными символами.

\begin{lstlisting}[caption=Koд без пробельных символов,label=unreadable]
if(_tab.get"mai.ru"){(_dom.query"button").Click;}else{_log.error"The site mai.ru is unaviable";};
\end{lstlisting}

\begin{lstlisting}[caption=Koд с пробельных символов,label=readable]
`` the begin of program

`` try to go to mai.ru
if (_tab.get "mai.ru") {
	`` site loaded successfull
	`` click the button
	(_dom.query "button").Click;
}
else {
	`` try again later
	`` now log the error
	_log.error "The site mai.ru is unaviable";
};

`` end of the program
\end{lstlisting}

В icL присутствует только один разделитель - \textbf{разделитель команд} \lstinline`;`. Команда - это набор токенов, распределенных в определённом порядке и характеризующее действие. Примеры команд: открыть сайт - \lstinline`_tab.get "URL"`, закрыть вкладку - \lstinline`_tab.close`.

При описании последовательности действий, их надо разделить, например последовательность вышеперечисленных команд описывается так:

\begin{lstlisting}[numbers=none]
_tab.get "URL"; _tab.close
\end{lstlisting}

Таким образом из команд собираем сценарии. Перед закрывающих скобок ставить разделитель команд опционально.

\subsubsection{Дополнительные сведение}

Если у вас нет знании в программировании перейдите, пожалуйста, на третью главу.

icL отсутствуют разделители между значениями в списке. Примеры:

\begin{icItems}
	\item Инициализация списка в С++:
\begin{lstlisting}[numbers=none, language=C++]
std::list<std::string> list = {"one", "two", "three"};
\end{lstlisting}
	Инициализация списка в icL:
\begin{lstlisting}[numbers=none]
@list = ["one" "two" "three"];
\end{lstlisting}
	\item Функция в С++:
\begin{lstlisting}[numbers=none, language=C++]
int sum (int number1, int number2) { return number1 + number2; };
\end{lstlisting}
	Функция в icL:
\begin{lstlisting}[numbers=none]
!sum = <int>number1 <int>number2 : int { @ = number1 + number2 };
\end{lstlisting}
	\item Вызов функций в С++:
\begin{lstlisting}[numbers=none, language=C++]
int s = sum (100, 200);
\end{lstlisting}
	Вызов функций в icL:
\begin{lstlisting}[numbers=none]
@sum = !sum 100 200;
\end{lstlisting}
	\item Код на С++:
\begin{lstlisting}[numbers=none, language=C++]
sum (100 + 50, 200);
\end{lstlisting}
	Эквивалент на icL:
\begin{lstlisting}[numbers=none]
!sum (100 + 50) 200;
\end{lstlisting}
\end{icItems}

\newpage
\section{Переменные}

\textbf{Переменная} - название области хранения, который могут манипулировать сценария. Каждая переменная в icL имеет область видимость (фрагмент кода где можно её использовать) и тип, который определяет размер и способ размещения памяти переменной; диапазон значений можно применить к переменной.

Имя переменной является идентификатором, начинающийся с \lstinline`@` или {\color{blue2}\lstinline`#`}.
\textbf{Основные типы} переменных показаны в таблице \ref{variablestypes}.

\stabletwo{2cm}{15.1cm}{variablestypes}{Типы переменных}%
{Тип}{Описание}%
{
	bool   & Логическое значения, имеет в состояние: истинно или лож. 					 \\ \hline
	int    & Целое число, позволяет хранить значения от -2.147.483.648 до 2.147.483.647. \\ \hline
	double & Дробное число, позволяет хранить вещественные числа. 						 \\
}

icL также присутствуют и \textbf{сложные типы} переменных, такие как строки, списки, множества, объекты, которые мы посмотрим в полеживающих главах. В этой главе изучаем только основные типы.

\subsection{Объявления и инициализация переменных}

\textbf{Объявления и инициализация} переменных, также операция \textit{присваивание} в icL неотличимы, и имеют общий вид \lstinline`a = b`, где \lstinline`a` новая или существующая переменная, а \lstinline`b` - значение. В тех случаев когда переменная \textbf{встречается первый раз}, мы её объявляем и инициализируем. В противном случае мы присваиваем ей значение.

На листинге \ref{initexample} показаны несколько пример объявлений и инициализации переменных, обратите внимание что дробные числа пишется через точку, а не через запятую как принято в Европе и Российском Федераций.

\begin{lstlisting}[caption=Пример объявлений и инициализации переменных,label=initexample]
@bool = false;
@catched = true;
@int = 234;
@double = 23.4;
#pi = 3.14;
#negative = -100.0;
\end{lstlisting}

\subsection{Локальные переменные}

\textbf{Локальные переменные} имею узкую область видимость, ограниченные фигурными скобками которые их охватывает, и только после их объявлений.

{\bf Идентификаторы} локальных переменных начинается с символом \lstinline`@`.

На листинге \ref{localvars} показана область видимость переменной \lstinline`@var`, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test6` - она не видна, когда в точках объявления переменных \lstinline`@test3`, \lstinline`@test4` и \lstinline`@test5` - да.
\begin{lstlisting}[caption=Область видимости локальных перемен, label=localvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var;
	`` initialization
	@var = 0;
	`` ok
	@test3 = @var;
	if (@) {
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var;
}
`` error
@test6 = @var;
\end{lstlisting}

\subsection{Глобальные переменные}

\textbf{Глобальные переменные} имеют самую широкую область видимости, их видны из любой точке программы после их инициализации. Использовать глобальные переменные не рекомендуется, так как они могут привести к серьезных ошибок.

{\bf Идентификаторы} глобальных переменных начинается с символом {\color{blue2}\lstinline`#`}. Локальные переменные с одинаковым названием могут быть несколько, когда глобальные - нет. Идентификатор глобальной переменной - уникальный.

Как указано на листинге \ref{globalvars}, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test3` переменная \lstinline`@var` не видна, когда в точках объявления переменных \lstinline`@test4`, \lstinline`@test5` и \lstinline`@test6` - да.

\begin{lstlisting}[caption=Область видимости глобальных перемен, label=globalvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var;
	if (@) {
		`` error
		@test3 = @var;
		`` initialization
		@var = 0;
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var;
}
`` ok
@test6 = @var;
\end{lstlisting}

\subsection{Левые и правые значения в icL}

В icL присутствуют 3 типа значении:

\begin{icEnum}
\item
	левые значения {\it lvalue} - переменные;
\item
	правые значения {\it rvalue} - переменные и константы;
\item
	javascript значения {\it jsvalue} - их будем рассматривать позже.
\end{icEnum}

Левые значения могут находиться с обеих сторон знака {\it присваивание}, когда правые - только справа. Примеры правильно и неправильно кода иллюстрированы на листинге \ref{rlvalues};

\begin{lstlisting}[caption=Левые и правые значения, label=rlvalues]
@a1 = @a2; @a3 = 123; `` ok
123 = @a1; 125 = 456; `` error
\end{lstlisting}

\subsection{Выводы}

{\bf Работа с переменными в icL} - максимально проста, но продвинутых пользователях без знания в программировании рекомендуется не использовать глобальные переменные. Для написания сценариев средней и низкой сложности, локальные переменные лучше подходят.

\section{Типы данных}

В языке описания сценариев icL, типы данных выполняют очень важную роль, они определяют как данные и будут храниться, обработаться в процессе выполнения программы. Классификация типов данных представлена в таблице \ref{datatypeclasses}.

\stabletwo{3.5cm}{13.6cm}
{datatypeclasses}{Категории типов данных}
{Категория}{Описание}
{
	Базовые     & Типы данных описанных в предыдущем главе: \bool{}{} - логический, \integer{} - целое - числа, \double{} - дробные числа. \\ \hline
	Сложные     & Типы данные содержащие несколько значений в контейнерах, примеры таких данных: строки, списки, множество. \\ \hline
	Системные   & Типы данных которых нельзя создать и хранить в пользовательских переменных, но доступ к ними можно получить через системные (предопределённых) переменных, примеры таких данных: браузер, вкладка, история браузера, окно. \\ \hline
	Тип \void{} & Тип данных обозначающий отсутствия данных.
}

\subsection{Основные типы данных}

{\bf Основные типы данных} участвуют в логических и арифметических операциях языка icL. Логическими операциями являются конъюнкция, дизъюнкция, исключающий или, эквиваленция и инверсия. Арифметическими операциями являются сложения, вычитания, умножения, деления, извлечения корня и возведения в степень.

\subsection{Сложные типы данных}

{\bf Сложные типы данных} специализированные под хранения больших массивов данных. Строка позволяет хранить более двух миллиардов символов. Список позволяет хранить более двух миллиардов строк. А множество позволяет хранить большой объём данных ограничен только оперативной памяти. Объект позволяет инкапсулировать данные разного рода по одном именем. Элемент позволяет хранить ссылку на один или несколько HTML-тэгов.

\subsection{Системные типы данных}

{\bf Системные типы данных} позволяют взаимодействовать с веб-страницей и браузером. Подробную информацию можно найти в главах \ref{webelments} и \ref{dataexchange}.

\subsection{Тип данных {\color{bluemarin} void}}

{\bf Тип данных \void{}} означает отсутствия информации, он используется в самых различных целях:

\begin{icItems}
\item
	указать то что функция ничего не возвращает;
\item
	указать на то что в процессе работы функций произошла ошибка;
\item
	выбрать источник данных;
\item
	фильтровать данные;
\item
	удалить переменных состояния;
\item
	и другие.
\end{icItems}


\subsection{Свойства}

Некоторые типы данных имеют свойства. Свойства позволяют получить характеристики хранимых данных. Вне зависимо от типа данные любой объект имеет следующие свойства (перечисленные свойства доступны только для чтения):

\begin{icItems}
\item
	\code{any'typeName : string} - при чтении получаем строку содержащая названия типа хранимых данных;
\item
	\code{any'typeId : int} - при чтении получаем число содержащее идентификатор типа хранимых данных;
\item
	\code{any'rValue : bool} - при чтении получаем \true{} если значение предназначено для правой части операции присваивания, иначе \false{};
\item
	\code{any'readOnly : bool} - при чтении получаем \true{} если объект доступен только для чтения, иначе \false{};
\item
	\code{any'lValue : bool} - при чтении получаем \true{} если объект доступен только для чтения и записи, иначе \false{};
\item
	\code{any'link : bool} - при чтении получаем \true{} если значение объекта хранится во внешнем контейнере и изменение значении объекта будет изменить данные во внешней среде, иначе \false{}.
\end{icItems}

\

\noindent Примеры использования свойств -
\begin{lstlisting}
@int = 2;
@double = 3;
@string = "int";

@int'typeName == @string;		 `` true
@int'typeId == @double'typeId ;	 `` false
@string'typeId == _types'string; `` true

@int'rValue; `` false
1234'rValue; `` true

@int'readOnly; `` false
1234'readOnly; `` true

@int'lValue; `` true
1234'lValue; `` false

@int'link; `` true
1234'link; `` false
\end{lstlisting}

\subsection{Методы}

Методы позволяют изменить состояние объекта. Все типы данных имеют только один общий метод \code{any.ensureRValue}, который гарантирует что изменение значению объекту не будет изменить данные во вне текущего контекста.

\noindent Пример -
\begin{lstlisting}
@int = 123;

@int'rValue;   `` false
@int'readOnly; `` false
@int.ensureRValue;
@int'rValue;   `` true
@int'readOnly; `` false
\end{lstlisting}

\subsection{Преобразование типов}

В icL данные по умолчанию не преобразуется. На пример сложить \integer{} с \double{} нельзя, такой оператор не определён, в этом случае можно преобразовать \integer{} в \double{} или \double{} в \integer{}, в зависимости от типа нужного результата.

Синтаксис преобразований максимально простой \code{data : type}, где \code{data} - любые данные (переменных или константные) а \code{type} - имя нужного типа данных.

{\color{red} Важно:} не все типы данных можно запросить, а только \bool{}, \integer{}, \double{}, \str{}, \listtype{} и \object{}.

\noindent Примеры преобразования:
\begin{lstlisting}
@a = 2 + 2.3; `` error
@a = (2 : double) + 2.3; `` 4.3
@a = 2 + (2.3 : int); `` 4

@b = 12 + " utils"; `` error
@b = (12 : string) + " utils"; `` "12 utils"

@c = "55" - 12; `` error
@c = ("55" : int) - 12; `` 43

@d = 23 + 12 : double; `` @d = 35.0
@e = 234.0 / 5.0 : int; `` @e = 46
\end{lstlisting}

\newpage
\section{Литералы}

Константные значения, которые присутствуют в скрипте в виде части исходного кода, называются {\bf литералами}.

Литералы могут быть любыми из следующих типов:

\begin{icItems}
	\item
		логическое значение - \bool{};
	\item
		целое число - \integer{};
	\item
		дробное число - \double{};
	\item
		строка - \str{};
	\item
		список - \listtype{};
	\item
		объект - \object{};
	\item
		множество - \set{}.
\end{icItems}

\subsubsection{Логические значения}

Для представления {\bf логических значения} используется следующее литералы:
\begin{icItems}
	\item \true{} - логическое единица, истинно;
	\item \false{} - логической ноль, лож.
\end{icItems}

\subsubsection{Целые числа}

Для представления {\bf целых чисел} используется последовательность цифр, перед которым может присутствовать минус. Между минусом и последовательности цифр разделители должны отсутствовать, иначе минус будет интерпретирован как оператор.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
23; -23; - 23; +23 + 3; 12 + -34; 15 - 24; 89--56; 2-3; `` ok
23-; 23+; -2А; 3f5; 23f; 23l; 12u; 89i; 2w1; 1q1; rt2; `` error
\end{lstlisting}

\subsubsection{Дробные числа}

{\bf Дробный литерал} состоит из двух частей: целая и дробная. Они разделяются точкой. Каждая составная часть является целом числом. Дробная часть не может быть отрицательной.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
23.233452; 29229992.2391; 100.0; -23.29199; -0.23; -0.45 - 1000.5; `` ok
23.-4; 3а.34; 23-.44; 34.+23; -25.f; -23.5f; -w.45; -2.4e10; -2.E2; `` error
\end{lstlisting}

\subsubsection{Строки}

{\bf Строковым литералом} является последовательность символов, ограниченное с обеих сторон кавычками \lstinline`"`. Чтобы добавить \lstinline`"` используется \lstinline`\"`, символ табуляции - \lstinline`\t`, символ {\it новая строка} - \lstinline`\n`, символ {\it возврат на шаг} - \lstinline`\b`, \textbackslash \ - \lstinline`\\`.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
"Hello \"to\" you!"; "Line1\nLine2"; "Tag1\n\bTag2\n\b"; "text"; "\\ \\ \n \\ \\";
\end{lstlisting}

\subsubsection{Списки}

{\bf Литералом списка} является последовательность строк, ограниченное квадратными скобками.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
@fruits = ["Apple" "Mango" "Banana" "Lime" "Lemon" "Olive"];
@vegetables = ["Cress" "Mustard" "Guar" "Soybean" "Leek" "Ahipa"];
\end{lstlisting}

\subsubsection{Объекты}

{\bf Объектом} является объединение нескольких переменных под общем именем, переменная объявлена внутри объекта называется {\it поле}. Литерал {\it поле} имеет следующий синтаксис \lstinline`<value>name`, где  {\it value} - значение и {\it name} - название. В icL неинициализируемые поля, как и неинициализируемые переменные, нельзя объявить.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
@quotation = [<"author">author <"text">text];
@child = [<4>age <true>hasBrothers <true>hasParents];
@file = [<false>isEmpty <25220>size <true>readOnly];
\end{lstlisting}

\subsubsection{Множества}

Только {\bf пустое множество} можно описать литералом, литерал схож с литералом объекта, только вместо значения указывается тип значения.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
@quotations = [<string>author <string>text];
@children = [<int>age <bool>hasBrothers <bool>hasParents];
@files = [<bool>isEmpty <int>size <bool>readOnly];
\end{lstlisting}

\newpage
\section{Операторы}

{\bf Оператор} - это токен, который предписывает выполнение определённой манипуляции данных. Встроенных операторов в icL очень много, по этому будет их разбирать по типу данных, в следующем порядке:

\begin{icEnum}
	\item \bool{};
	\item \integer{};
	\item \double{};
	\item \str{};
	\item \listtype{};
	\item \object{};
	\item \set{};
	\item \void{}.
\end{icEnum}

Операторы имеют ранг, операторы имеющие наивысший ранг выполняются первыми, а имеющие наименьший ранг - последними. Операторы имеющие правая ассоциативность выполняются раньше чем операторы имеющие левое ассоциативность, они отмечены плюсом справа от ранга, например 7$^+$.

{\bf Оператор пристраивания} имеет ранг 0 и правая ассоциативность;

\subsection{\color{bluemarin}bool}

Если у вас отсутствуют знания по алгебры логике, пожалуйста прочтите любую книгу по основы данной науке.

Для типа данных \bool{}, доступны:

\begin{icItems}
	\item
		операции алгебры логике (имеющие ранг 2):
	\begin{icItems}
		\item
			конъюнкция - \lstinline`bool & bool : bool`;
		\item
			дизъюнкция - \lstinline`bool | bool : bool`;
		\item
			эквивалентность - \lstinline`bool ~ bool : bool`;
		\item
			исключающий или - \lstinline`bool ^ bool : bool`;
		\item
			инверсия (имеет ранг 7$^+$) - \lstinline`! bool : bool`;
	\end{icItems}

	\item
		операций сравнения (имеющие ранг 3):
	\begin{icItems}
		\item
			равно - \lstinline`bool == bool : bool`;
		\item
			не равно - \lstinline`bool != bool : bool`;
	\end{icItems}
\end{icItems}

Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{boolopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа bool, label=boolopex]
_log.out "true & false = " (true & false);		`` true \& false = false
_log.out "false | true =  " (false | true);		`` false | true = true
_log.out "true ~ false = " (true ~ false);		`` true \textasciitilde\ false = false
_log.out "false ^ true = " (false ^ true);		`` false \textasciicircum\ true = true`

_log.out "!true = " !true;						`` !true = false
_log.out "!false = " !false;					`` !false = true

_log.out "true == false = " (true == false);	`` true == false = false
_log.out "false != true = " (false != true);	`` false != true = true
\end{lstlisting}

\subsubsection{\lstinline`<bool>a & <bool>b : bool`}

Оператор принимает логическую операцию "конъюнкция" над переменными a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{conjtable}.

\begin{table}[htb]
	\caption{Таблица истинности конъюнкции}
	\label{conjtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \& b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a | <bool>b : bool`}

Оператор принимает логическую операцию "дизъюнкция" над переменными a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{distable}.

\begin{table}[htb]
	\caption{Таблица истинности дизъюнкции}
	\label{distable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \| b} 	\\ \hline
		\false{} & \false{} & \false{} 		\\ \hline
		\false{} & \true{}  & \true{}  		\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \true{}  		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a ~ <bool>b : bool`}

Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logeqtable}.

\begin{table}[htb]
	\caption{Таблица истинности эквивалентности}
	\label{logeqtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \~ b} \\ \hline
		\false{} & \false{} & \true{}   	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline`<bool>a ^ <bool>b : bool`}

Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logdifftable}.

\begin{table}[htb]
	\caption{Таблица истинности исключающего или}
	\label{logdifftable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \^ b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \true{}   	\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \false{}  	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`! <bool>a : bool`}

Оператор принимает логическую операцию "инверсия" над переменной a. Зависимость результата от исходных данных иллюстрирована в таблице \ref{invtable}.

\begin{table}[htb]
	\caption{Таблица истинности инверсии}
	\label{invtable}
	\begin{tabular}{|c|c|}
		\hline
		\code{a} & \code{!a} \\ \hline
		\false{} & \true{} 	 \\ \hline
		\true{}  & \false{}  \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a == <bool>b : bool`}

Возвращает \true{} если a равно b, иначе \false{}.

\subsubsection{\lstinline`<bool>a != <bool>b : bool`}

Возвращает \true{} если a равно b, иначе \false{}.

\subsection{{\color{bluemarin}int} и {\color{bluemarin}double}}

Для чисел доступны операций:
\begin{icItems}
	\item
		3-ого ранга:
		\begin{icItems}
			\item
				равно \lstinline`int == int : bool` и \lstinline`double == double : bool`
			\item
				не равно \lstinline`int != int : bool` и \lstinline`double != double : bool`
			\item
				больше \lstinline`int >> int : bool` и \lstinline`double >> double : bool`
			\item
				больше или равно \lstinline`int >= int : bool` и \lstinline`double >= double : bool`
			\item
				меньше \lstinline`int << int : bool` и \lstinline`double << double : bool`
			\item
				меньше или равно \lstinline`int <= int : bool` и \lstinline`double <= double : bool`
		\end{icItems}
	\item
		4-ого ранга:
		\begin{icItems}
			\item
				сложение \lstinline`int + int : int` и \lstinline`double + double : double`;
			\item
				вычитание \lstinline`int -    int : int` и \lstinline`double -    double : double`.
		\end{icItems}
	\item
		5-ого ранга:
		\begin{icItems}
			\item
				умножение \lstinline`int * int : int` и \lstinline`double * double : double`;
			\item
				деление \lstinline`int / int : int` и \lstinline`double / double : double`;
			\item
				остаток от деления целых чисел \lstinline`int \ int : int`.
		\end{icItems}
	\item
		6$^+$-ого ранга:
		\begin{icItems}
			\item
				возведения в квадрат \lstinline`int** : int` и \lstinline`double** : double`;
			\item
				возведения в степень \lstinline`int ** int : int` и \lstinline`double ** double : double`;
			\item
				извлечения квадратного корня \lstinline`/'int : int` и \lstinline`/'double : double`;
			\item
				извлечения корня \lstinline`int/'int : int` и \lstinline`double/'double : double`.
		\end{icItems}
	\item
		7$^+$-ого ранга:
		\begin{icItems}
			\item
				инверсия знака \lstinline`-int : int` и \lstinline`-double : double`;
			\item
				абсолютное значение \lstinline`+int : int` и \lstinline`+double : double`.
		\end{icItems}
\end{icItems}

Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{numberopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа int и double, label=numberopex]
`` 3rd rank
_log.out "2 == 3 = "		2 == 3;		`` 2 = 3 = false
_log.out "2.5 == 2.5 = "	2.5 == 2.5;	`` 2.5 = 2.5 = true
_log.out "1 != 2 = "		1 != 2;		`` 1 $\neq$ 2 = true
_log.out "2.1 != 2.1 = "	2.1 != 2.1;	`` 2.1 $\neq$ 2.1 = false
_log.out "3 >> 2 = "		3 >> 2;		`` 3 > 2 = true
_log.out "1.1 >> 2.1 = "	1.1 >> 2.1;	`` 1.1 > 2.1 = false
_log.out "5 >= 2 = "		5 >= 2;		`` 5 $\geq$ 2 = true
_log.out "5.1 >= 2 = "		5.1 >= 2;	`` 5.1 $\geq$ 2 = true
_log.out "3 << 9 = "		3 << 9;		`` 3 < 9 = true
_log.out "6.1 << 6.2 = "	6.1 << 6.2;	`` 6.1 < 6.2 = true
_log.out "4 <= 5 = "		4 <= 5;		`` 4 $\leq$ 5 = true
_log.out "5.6 <= 6.5 = "	5.6 <= 6.5;	`` 5.6 $\leq$ 6.5 = true
`` 4th rank
_log.out "2 + 3 = "			2 + 3;		`` 2 + 3 = 5
_log.out "2.1 + 1.1 = "		2.1 + 1.1;	`` 2.1 + 1.1 = 3.2
_log.out "4 - 5 = "			4 - 5;		`` 4 - 5 = -1
_log.out "4.5 - 3.4 = "		4.5 - 3.4;	`` 4.5 - 3.4 = 1.1
`` 5th rank
_log.out "2 * 3 = "			2 * 3;		`` 2 $\cdot$ 3 = 6
_log.out "2.1 * 5.7 = "		2.1 * 5.7;	`` 2.1 $\cdot$ 5.7 = 11.97
_log.out "5 / 7 = "			5 / 7;		`` 5 $\div$ 7 = 0.7142857142857
_log.out "5.0 / 7.1 = "		5.0 / 7.1;	`` 5.0 $\div$ 7.1 = 0.7042253521126
_log.out "45 \ 8 = "		45 \ 8;		`` 45 \textbackslash 8 = 5
`` 6+th rank
_log.out "25** = "			25**;		`` $25^2$ = 625
_log.out "25.1** = "		25.1**;		`` $25.1^2$ = 630,01
_log.out "34 ** 3 = "		34 ** 3;	`` $34^3$ = 39304
_log.out "2.0 ** 1.5 = "	2.0 ** 1.5;	`` $2.0^{1.5}$ = 2.8284271247461
_log.out "/'25 = "			/'25;		`` $\sqrt{25}$ = 5
_log.out "/'125.7 = "		/'125.7;	`` $\sqrt{125.7}$ = 11.211601134539
_log.out "3/'27 = "			3/'27;		`` $\sqrt[3]{27}$ = 3
_log.out "5.0/'125.5 = "	5.0/'125.5;	`` $\sqrt[5.0]{125.5}$ = 2.6286256727378
`` 7+th rank
_log.out "- 35 = "			- 35;		`` - 35 = -35
_log.out "- -56.7 = "		- -56.7;	`` - -56.7 = 56.7
_log.out "+ -100 = "		+ -100;		`` + -100 = 100
_log.out "+ 89.7 = "		+ 89.7;		`` + 89.7 = 89.7
\end{lstlisting}

{\bf Внимание:} несмотря на то что пробелы в icL игнорируются, они влияют на восприятии кода, \code{-23-4} будет восприниматься как \lstinline`(-23) (-4)` а не как \lstinline`(-23) - (4)`. Недоразумение между человеком и машиной решается добавлением пробелов \lstinline`-23  - 4`.

\subsubsection{\lstinline`<int>a == <int>b : bool`}

Возвращает \true{} если \code{a} и \code{b} имеют одинаковое значение, иначе \false{}.

\subsubsection{\lstinline`<double>a == <double>b : bool`}

Возвращает \true{} если \code{a} и \code{b} отличаются довольно мало (например на 10$^{-15}$), иначе \false{}.

\subsubsection{\lstinline`<int>a != <int>b : bool`}

Возвращает \true{} если \code{a} и \code{b} не имеют одинаковое значение, иначе \false{}.

\subsubsection{\lstinline`<double>a != <double>b : bool`}

Возвращает \true{} если \code{a} и \code{b} отличаются больше чем на уровень погрешности машины, иначе \false{}.

\subsubsection{\lstinline`<int>a >> <int>b : bool`}

Возвращает \true{} если целое число \code{a} больше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a >> <double>b : bool`}

Возвращает \true{} если дробное число \code{a} больше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<int>a >= <int>b : bool`}

Возвращает \true{} если целое число \code{a} больше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a >= <double>b : bool`}

Возвращает \true{} если дробное число \code{a} больше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline`<int>a << <int>b : bool`}

Возвращает \true{} если целое число \code{a} меньше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a << <double>b : bool`}

Возвращает \true{} если дробное число \code{a} меньше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<int>a <= <int>b : bool`}

Возвращает \true{} если целое число \code{a} меньше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a <= <double>b : bool`}

Возвращает \true{} если дробное число \code{a} меньше или равно \code{b}, иначе \false{}.


\subsubsection{\lstinline`<int>a + <int>b : int`}

Возвращает сумму целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a + <double>b : double`}

Возвращает сумму дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a - <int>b : int`}

Возвращает разницу между целыми числами \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a - <double>b : double`}

Возвращает разницу между дробными числами \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a * <int>b : int`}

Возвращает результат умножения целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a * <double>b : double`}

Возвращает результат умножения дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a / <int>b : int`}

Возвращает результат деления целых чисел \code{a} и \code{b}, остаток отбрасывается.

\subsubsection{\lstinline`<double>a / <double>b : double`}

Возвращает результат деления дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a \ <int>b : int`}

Возвращает результат от деления целых чисел \code{a} и \code{b}.


\subsubsection{\lstinline`<int>a ** : int`}

Возвращает квадрат целого числа \code{a} (a$^2$);

\subsubsection{\lstinline`<double>a ** : double`}

Возвращает квадрат дробного числа \code{a} (a$^2$);

\subsubsection{\lstinline`<int>a ** <int>b : int`}

Возвращает результат возведения целого числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`<double>a ** <double>b : double`}

Возвращает результат возведения дробного числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`/' <int>a : int`}

Возвращает корень целого числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`/' <double>a : double`}

Возвращает корень дробного числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`<int>n /' <int>a : int`}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<int>n /' <double>a : double`}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<double>n /' <double>a : double`}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).


\subsubsection{\lstinline`- <int>a : int`}

Возвращает $0-a$;

\subsubsection{\lstinline`- <double>b : double`}

Возвращает $0.0-a$;

\subsubsection{\lstinline`+ <int>a : int`}

Возвращает абсолютное значение целого числа \code{a}.

\subsubsection{\lstinline`+ <double>a : double`}

Возвращает абсолютное значение дробного числа \code{a}.

\subsection{{\color{bluemarin}string} и {\color{bluemarin}list}}

	Для строк и списков доступны операций:
\begin{icItems}
	\item
		3-ого ранга:
		\begin{icItems}
		\item
			равно \lstinline`string == string : bool` и \lstinline`list == list : bool`;
		\item
			не равно \lstinline`string != string : bool` и \lstinline`list != list : bool`;
		\item
			содержит \lstinline`list << string : bool` и \lstinline`string << string : bool`;
		\item
			содержит строку подходящая по шаблону \lstinline`list <* string : bool`.
		\end{icItems}
	\item
		4-ого ранга:
		\begin{icItems}
		\item
			конкатенация \lstinline`string + string : string`;
		\item
			вставка \lstinline`string + list : list`, \lstinline`list + string : list` и \lstinline`list + list : list`.
		\end{icItems}
	\item
		5-ого ранга: шаблонное сравнение \lstinline`string * string : bool`, \lstinline`list * string : bool` и \lstinline`list * list : bool`;
	\item
		6$^+$-ого ранга: эквивалентность \lstinline`string ** string : double`.
\end{icItems}

Примеры использование операторов присутствуют на листинге \ref{stringlistopex}.

Чтобы из несколько строк получить список, оператор вставки рекомендуется не использовать, вместо него использовать литерал:
\begin{lstlisting}[numbers=none]
[@str1 @str2 "Const string" (!func) (37.1 : string) (@bool : string) @list.Join]
\end{lstlisting}

\begin{lstlisting}[caption=Примеры использования операторов над данными типа string и list, label=stringlistopex]
"String1" == "String2";					`` false
["a" "b"] == ["a" "b"];					`` true
["a" "b"] == ["b" "a"];					`` true
["a" "b"] << "c";						`` false
"abc" << "c";							`` true
"ab" + "c";								`` "abc"
"ab" + ["c"];							`` ["ac" "c"]
["a" "b"] + "c";						`` ["a" "b" "c"]
["a" "b"] + ["c" "d"];					`` ["a" "b" "c" "d"]
"abc" * "*c";							`` true
["ac" "bc"] * "*c";						`` true
["ac" "bc"] * "a*";						`` false
["ad" "ac" "bd" "cc"] * ["*d" "*c"];	`` true
["ad" "ac" "bc" "cd"] * ["*d" "*c"];	`` false
"Tom is a cat" ** "Tom is not a cat";	`` 0.875
\end{lstlisting}

\subsubsection{\lstinline`<string>s1 == <string>s2 : bool`}

Возвращает \true{} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \false{}.

\subsubsection{\lstinline`<list>l1 == <list>l2 : bool`}

Возвращает \true{} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \false{}.

\subsubsection{\lstinline`<string>s1 != <string>s2 : bool`}

Возвращает \false{} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \true{}.

\subsubsection{\lstinline`<list>l1 != <list>l2 : bool`}

Возвращает \false{} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \true{}.

\subsubsection{\lstinline`<list>l << <string>str : bool`}

Возвращает \true{}, если список \code{l} содержит строку \code{str}, иначе \false{}.

\subsubsection{\lstinline`<string>str << <string>substr : bool`}

Возвращает \true{}, если строка \code{str} содержит подстроку \code{substr}, иначе \false{}.

\subsubsection{\lstinline`<list>l <* <string>template : bool`}

Возвращает \true{}, если список \code{l} содержит хотя бы одна строка, подходящая по шаблону \code{template}, иначе \false{}.

{\bf Шаблон} - это строка содержащая данные и специальный символ \lstinline`*`, где \lstinline`*` означает любая последовательность символов. Рассмотрим шаблонную строку \lstinline`"Have a * day!"`, примеры строк подходящие по шаблону: \lstinline`"Have a nice day!"`, \lstinline`"Have a amazing day!"`. Пример неподходящей строки \lstinline`"Have a good day"` (отсутствует восклицательный знак).

\subsubsection{\lstinline`<string>s1 + <string>s2 : string`}

Возвращает строку содержащую все символы строк \code{s1} и \code{s2}. Полученная строка имеет длину равна суммы длин составляющих.

\subsubsection{\lstinline`<string>str + <list>l : list`}

Возвращает новый список, получен при вставке строке \code{str} в начале списка \code{l}.

\subsubsection{\lstinline`<list>l + <string>str : list`}

Возвращает новый список, получен при вставке строке \code{str} в конце списка \code{l}.

\subsubsection{\lstinline`<list>l1 + <list>l2 : list`}

Возвращает новый список, содержащий все элементы списков \code{l1} и \code{l2}.

\subsubsection{\lstinline`<string>str * <string>template : bool`}

Возвращает \true{}, если строка \code{str} подходит по шаблону \code{template}, иначе \false{}.

\subsubsection{\lstinline`<list>l * <string>template : bool`}

Возвращает \true{} если все строки списка \code{l} подходят по шаблону \code{template}, иначе \false{}.

\subsubsection{\lstinline`<list>l * <list>templates : bool`}

Возвращает \true{} если все строки списка \code{l} подходят по соответственному шаблону из списка \code{templates}, иначе \false{}.

\subsubsection{\lstinline`<string>s1 ** <string>s2 : double`}

Возвращает коэффициент эквивалентности получен при сравнении \code{s1} с \code{s2}.

{\bf Эквивалентность} - уровень схожести строк. \lstinline`"Hi! Robert, how do you do?"` относительно \lstinline`"Robert! Hi! How do you do?"` имеет эквивалентность равна единицы. Так как они состоят из одни и те же слова. Но если сравнивать с  \lstinline`"Rich! Hi! How are you?"` оценка снижается до 0,64.

\subsubsection{\lstinline`<list>l1 ** <list>l2 : double`}

Возвращает коэффициент эквивалентности получен при сравнении строк из списка \code{l1} со строками из списка \code{l2}.
Для корректности вычисления, каждая строка должна содержать одно слово.

\subsection{{\color{bluemarin}object} и {\color{bluemarin}set}}

Для строк и списков доступны операций:
\begin{icItems}
	\item
		3-ого ранга:
		\begin{icItems}
		\item
			равно \lstinline`object == object : bool` и \lstinline`set == set : bool`;
		\item
			не равно \lstinline`object != object : bool` и \lstinline`set != set : bool`;
		\item
			включение \lstinline`set << object : bool` и \lstinline|set << set : bool|;
		\item
			включение шаблона \lstinline`set <* object` и \lstinline`object <* object : bool`.
		\end{icItems}
	\item
		4-ого ранга:
		\begin{icItems}
		\item
			объединение \lstinline`set + set : set`;
		\item
			симметрическая разность \lstinline`set -   set : set`.
		\end{icItems}
	\item
		5-ого ранга:
		\begin{icItems}
		\item
			разность \lstinline`set \ set : set`;
		\item
			пересечение \lstinline`set * set : set`.
		\end{icItems}
	\item
		6$^+$-ого ранга: пересекаются \lstinline|set ** set : bool|.
\end{icItems}

Примеры использование операторов присутствуют на листинге \ref{setobjopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа object и set, label=setobjopex]
`` init
@set1 = [<int>age <string>name];
@set2 = [<int>age <string>name];
@set3 = [<int>age <string>name];

@obj1 = [<24>age <"User1">name];
@obj2 = [<23>age <"User2">name];
@obj3 = [<26>age <"User3">name];
@obj4 = [<24>age <80>length <40>height <1>arc];

@set1.insert @obj1;
@set1.insert @obj2;
@set2.insert @obj3;
@set2.insert @obj2;
@set3.insert @obj2;
@set3.insert @obj1;

`` operators
@set1 == @set2;				`` false
@set1 == @set3;				`` true
@obj1 == @obj2;				`` false
@set2 != @set3;				`` true
@obj2 != @obj3;				`` true

@set1 << @obj2;				`` false
@set1 << @set2;				`` false
@set1 <* [<23>age];			`` true
@obj4 <* [<24>age <1>arc];	`` true

@set1 + @set2;				`` [@obj1 @obj2 @obj3]
@set1 - @set2;				`` [@obj1 @obj3]
@set1 \ @set2;				`` [@obj1]
@set1 * @set2;				`` [@obj2]

@set1 ** @set2;				`` true
\end{lstlisting}

\subsubsection{\lstinline`<object>obj1 == <object>obj2 : bool`}

Возвращает \true{} если \code{obj1} и \code{obj2} имеют одни и те же поля, значения полях из первого объекта совпадает с значениям одноимённых полях второго объекта, иначе \false{}.

\subsubsection{\lstinline`<set>set1 == <set>set2 : bool`}

Возвращает \true{} если \code{set1} и \code{set2} имеют один и тоже заголовок, всё объекты из первой множестве приличествуют во вторым и наоборот, иначе \false{}.

\subsubsection{\lstinline`<object>obj1 != <object>obj2 : bool`}

Возвращает \true{} если один из объектов имеет поле, отсутствующее в другом или значения поле первого отличается от значении одноимённой поле второго объекта, иначе \false{}.

\subsubsection{\lstinline`<set>set1 != <set>set2 : bool`}

Возвращает \true{} если количество объектов во втором объекте отличается от количества объектов в первом или существует объект присутствующий только в одной множестве, иначе \false{}.

\subsubsection{\lstinline`<set>s << <object>obj : bool`}

Возвращает \true{}, если множество \code{s} содержит объект \code{obj}, иначе \false{}.

\subsubsection{\lstinline|<set>set1 << <set>set2 : bool|}

Возвращает \true, если множество \code{set1} содержит подмножество \code{set2}, иначе \false.

\subsubsection{\lstinline`<set>s <* <object>subobj : bool`}

Возвращает \true{}, если множество \code{s} содержит под объект \code{subobj}, иначе \false{}.

\subsubsection{\lstinline`<object>obj <* <object>subobj : bool`}

Возвращает \true{} если каждое поле объекта \code{subobj} содержится в объекте \code{obj} и значение одноимённых полях совпадает, иначе \false{}.

\subsubsection{\lstinline`<set>set1 + <set>set2 : set`}

Возвращает новое множество содержащая все объекты множеств \code{set1} и \code{set2}.

\subsubsection{\lstinline`<set>set1 - <set>set2 : set`}

Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}, и все объекты множестве \code{set2}, отсутствующих в \code{set1}.

\subsubsection{\lstinline`<set>set1 \\ <set>set2 : set`}

Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}.

\subsubsection{\lstinline`<set>set1 * <set>set2 : set`}

Возвращает новое множество содержащая все объекты , которые приличествуют в \code{set1} и \code{set2}.

\subsubsection{\lstinline`<set>set1 ** <set>set2 : bool`}

Возвращает \true, если множества \code{set1} и \code{set2} пересекаются, иначе \false.

\subsection{\color{bluemarin}void}

Все \void{} операторы имеют 2-ой ранг. Данные операторы делят данных на 2 типа \void{} и не \void{}. Второй тип в дальнейшем будет отмечен как \code{any}, он может быть один из следующих типов: \integer{}, \double{}, \str{}, \listtype{}, \object{}, \set{}, \element{}.

Список \void{} операторов:

\begin{icItems}
\item
	альтернативный выбор \lstinline`void | void : void`, \lstinline`void | any : any`, \lstinline`any | void : any` и \lstinline`any | any : any`;
\item
	первичный выбор \lstinline|void & void : void|, \lstinline|any & void : void|, \lstinline|void & any : void| и \lstinline|any & any : any|;
\item
	вторичный выбор \lstinline|void ~ void : void|, \lstinline|void ~ any : void|, \lstinline|any ~ void : void| и \lstinline|any ~ any : any|;
\item
	исключающий выбор \lstinline|void ^ void : void|, \lstinline|void ^ any : any|, \lstinline|any ^ void : any| и \lstinline|any ^ any : void|;
\item
	коллекционный выбор \lstinline|void % void : void|, \lstinline|void % any : any|, \lstinline|any % void : any|, \lstinline|int % int : int|, \lstinline|double % double : double|, \lstinline|string % string : list|, \lstinline|list % string : list|, \lstinline|object % object : set| и \lstinline|set % object : set|. Ещё одна перегрузка оператора будет объявлена в главе \ref{webelments}.
\end{icItems}

\subsubsection{\lstinline`<void or any>arg1 | <void or any>arg2 : void or any`}

Возвращаемый результат оператором альтернативного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{orhacktable}.

\begin{table}[htb]
	\caption{Оператор альтернативный выбор}
	\label{orhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \| arg2} \\ \hline
		\void{}     & \void{}     & \void{}  			\\ \hline
		\void{}     & \code{any}  & \code{arg2}  		\\ \hline
		\code{any}  & \void{}     & \code{arg1}  		\\ \hline
		\code{any}  & \code{any}  & \code{arg1}  		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> \& <void or any> : void or any`}

Возвращаемый результат оператором первичного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{andhacktable}.

\begin{table}[htb]
	\caption{Оператор первичный выбор}
	\label{andhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \& arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg1}   		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> ~ <void or any> : void or any`}

Возвращаемый результат оператором вторичного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{eqhacktable}.

\begin{table}[htb]
	\caption{Оператор вторичный выбор}
	\label{eqhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \~ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg2}   		\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline`<void or any> ^ <void or any> : void or any`}

Возвращаемый результат оператором исключающего выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{xorhacktable}.

\begin{table}[htb]
	\caption{Оператор исключающий выбор}
	\label{xorhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \^ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \code{arg2}   		\\ \hline
		\code{any}  & \void{}     & \code{arg1}   		\\ \hline
		\code{any}  & \code{any}  & \void{}   			\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> \% <void or any> : void or any`}

	Возвращаемый результат оператором исключающего выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{centhacktable}.
%\stablethree{1.5cm}{1.5cm}{5cm}
%{centhacktable}{Оператор коллекционный выбор}
%{\code{arg1}}{\code{arg2}}{\code{a \^ b}}
%{
\begin{table}[htb]
	\caption{Оператор коллекционный выбор}
	\label{centhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \% arg2}			\\ \hline
		\void{}     & \void{}     & \void{}						\\ \hline
		\void{}     & \code{any}  & \code{arg2}					\\ \hline
		\code{any}  & \void{}     & \code{arg1}					\\ \hline
		\integer{}  & \integer{}  & \integer{}					\\ \hline
		\double{}   & \double{}   & \double{}					\\ \hline
		\str{}      & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\listtype{} & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\object{}   & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
		\set{}      & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}
%}

Для аргументов типов \integer{} и \double{}, вызывается функция \code{_numbers.process}, перед использованием установите какую операцию нужно выполнять с числами, использую функцию \code{_numbers.setProcess} с одни из следующих аргументов: \code{_numbers'sum} - сумма, \code{_numbers'product} - произведение, \code{_numbers'max} - максимум, \code{_numbers'min} - минимум. После использования оператора, вызываете \code{_numbers.restoreProcess} чтобы восстановить исходные настройки.

\subsection{Дополнительные операторы}

\subsubsection{\lstinline`[string...]`, \lstinline`[arg...]`, \lstinline`[param...]`, \lstinline`[<>]` и \lstinline`[]`}

{\bf Квадратные скобки} или {\bf оператор объединения данных} позволяет создавать объекты следующих типов данных \listtype{}, \set{} и \object{}.

\code{[] : list} создаёт пустой список.

\code{[string ...] : list} создаёт заполненный список, он может содержать как константные литеры, так и вызовы на функций возвращающие строки. Пример: \code{["a" "b" "c"]}.

\code{[list ...] : list} объединяет несколько списков в один.

\code{[string or list ...] : list} - строки и списки можно смешать.

\code{[<>] : object} создаёт пустой объект.

\code{[arg ...] : object} создаёт объект имеющие поля (каждое поле описывается в виде аргумента), аргумент описывается следующим образом \code{<value>name}, где \code{value} - значение, \code{name} - название аргумента. Пример \code{[<2>number <"str">str]}.

\code{[param ...] : set} создаёт множество с указанным заголовкам, каждый столбец описывается в виде параметра, параметр описывается следующим образом \code{<type>name}, где \code{type} - тип значения, \code{name} - название параметра. Создавать множество с пустым заголовком - запрещено. Пример \code{[<int>number <string>str]}.

\code{[object ...] : set} создаёт множество из несколько объектов.

\code{[set ...] : set} объединяет несколько множеств в одной.

\code{[object or set ...] : set} объекты и множества также можно смешать.

\newpage
\section{Условные операторы}

Условные структуры имеют условие, которое будет вычислено. А также и блоки команд, чья выполнение зависит от значения условии.

В icL приличествуют следующее условные операторы:
\begin{icItems}
	\item \code{if};
	\item \code{if else};
	\item каскадное \code{if else};
	\item \code{exists};
	\item \code{if exists};
	\item \code{for any}.
\end{icItems}

\subsubsection{\lstinline`if`}

\code{if} позволяет ставить условия выполнения блока команд. Он имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
if (condition) {
	commands
};
\end{lstlisting}
где \code{condition} любое выражение возвращающее значение типа \bool{} и \code{commands} любой набор команд.

Также допускаются пропустить круглые скобки, синтаксис -
\begin{lstlisting}[numbers=none]
if true  { commands };
if !true { commands };
if @var  { commands };
if !@var { commands };
\end{lstlisting}

\subsubsection{\lstinline`if else`}

\code{if else} позволяет выбирать между двух блоков команд, в случае когда условие истинно - выполняется первый блок, иначе второй блок.

Конструкция \code{if else} имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
if (condition) {
	commands1
}
else {
	commands2
};
\end{lstlisting}

\subsubsection{Каскадное \lstinline`if else`}

Каскадное \code{if else} позволяет выбирать между n блоков команд, но для это нужно предъявить n-1 условии.

Каскадное \code{if else} имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
if (condition1) {
	commands1
} else if (condition2) {
	commands2
} else {
	commands3
};
\end{lstlisting}

\subsubsection{\lstinline`exists`}

\code{exists} позволяет условно возвращать данные, если они подходят под определённому критерия.

Условия по умолчанию:
\begin{icItems}
\item
	для \bool{} - \code{# == true};
\item
	для \integer{} - \code{# != 0};
\item
	для \double{} - \code{# != 0.0};
\item
	для \str{} - \code{!#'empty};
\item
	для \listtype{} - \code{!#'empty};
\item
	для \object{} - \code{!#'empty};
\item
	для \set{} - \code{!#'empty};
\item
	для \request{} - \code{!#'empty};
\item
	для \element{} - \code{#.isValid}.
\end{icItems}

Если использовать условию по умолчанию, используется следующий синтаксис -
\begin{lstlisting}[numbers=none]
exists(expression);
\end{lstlisting}
При необходимости задать своё условие, синтаксис чуть изменяется -
\begin{lstlisting}[numbers=none]
exists(expression, condition);
\end{lstlisting}

\subsubsection{\lstinline`if exists`}

Конструкция \code{if exists} позволяет выполнять блок команд в зависимости от результата работы конструкции \code{exists}. Также повторно использовать значения выражения. В случае когда условие конструкции \code{exists} истинно, то блок команд выполняется и в нём передаётся данный полученные от \code{exists} под именем \code{@}.
Простой и элементарный пример представлен на листинге \ref{ifexistsex}.

\begin{lstlisting}[caption=Использование if exist, label=ifexistsex]
if exists(23 + 3, # > 20) {
	_log.out "@ = " @; `` @ = 26
};
\end{lstlisting}

\subsubsection{\lstinline`for any`}

\code{for any} позволяет повторно использовать любое значение. Пример использования представлен на листинге \ref{foranyex}.

\begin{lstlisting}[caption=Использование for any, label=foranyex]
for any(23 + 3) {
	_log.out "@ = " @; `` @ = 26
};
\end{lstlisting}

\newpage
\section{Циклы}

Может возникнуть нужность в том, чтобы выполнить блок кода несколько раз. Для этого совсем не обязательно писать один то тоже код несколько раз, достаточно использовать цикл.

Язык icL предоставляет следующие типы циклов:

\begin{icItems}
\item
	\code{for} - универсальный цикл;
\item
	\code{while} - условное повторение кода;
\item
	\code{do while} - цикл с постусловий;
\item
	\code{for} - прохождение коллекций;
\item
	\code{filter} - выборочное прохождение коллекций;
\item
	\code{range} - частичное прохождение коллекций.
\end{icItems}


\subsubsection{\lstinline`for` - универсальный цикл}

{\bf Универсальный цикл} позволяет полностью управлять ход выполнения кода. Он содержит:

\begin{icItems}
\item
	\code{initialization} - код отвечающий за инициализацию;
\item
	\code{condition} - условие, которая проверяется перед запуском цикла;
\item
	\code{step} - код, отвечающий за перехода на следующую итерацию цикла.
\item
	\code{commands} - тело цикла.
\end{icItems}

Универсальный цикл имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
for (initialization, condition, step) {
	commands
};
\end{lstlisting}

На листинге \ref{uniloopex} показан пример использование цикла \code{for}, цикл будет выводить числа от нуля до четырёх.

\begin{lstlisting}[caption=Универсальный цикл, label=uniloopex]
for (@i = 0, i < 5, @i = @i + 1) {
	_log:out @i;
};
\end{lstlisting}

\subsubsection{\lstinline`while` - условное повторение кода}

{\bf Условное повторение кода} будет выполнить блок команд, пока условие остаётся истиной. Условие проверяется перед запуском цикла и если условие изначально - лож, тела цикла не будет выполниться ни разу.

Главное его преимущества - его простота. В сравнения с универсального цикла, в конструкции \code{while} отсутствуют фрагменты кода для инициализации и перехода на следующую итерацию. Он содержит только условие и тело -
\begin{lstlisting}[numbers=none]
while (condition) {
	commands
};
\end{lstlisting}

На листинге \ref{whileex} переставлен код, использующий цикл \code{while}. Переменная \code{@number} объявлено до цикла и будет доступа и после него. При завершении работы цикла \code{@number} будет равен 6-и.

\begin{lstlisting}[caption=Цикл while, label=whileex]
@number = 1;

while (@number <= 5) {
	@number = @number + 1;
};
\end{lstlisting}

\subsubsection{\lstinline`do while` - цикл с постусловий}

{\bf Цикл с постусловий} мало отличается от \code{while}, но он гарантирует что тело цикла будет выполнена минимум 1 раз. Также условие объявляется после тело цикла, указывая на то что она будет проверено после первой итерации. Синтаксис -
\begin{lstlisting}[numbers=none]
do {
	commands
} while (condition);
\end{lstlisting}

На листинге \ref{dowhileex} представлен код, использующий цикл \code{do while}. Несмотря на то что условие изначально \code{false}, первая итерация цикла будет выполнена, в результате чего \code{@number} станет равен 7-и.

\begin{lstlisting}[caption=Цикл do while, label=dowhileex]
@number = 6;

do {
	@number = @number + 1;
} while (@number < 5);
\end{lstlisting}

\subsubsection{\lstinline`for` - прохождение коллекций}

{Коллекция} - объект, содержащий несколько значений. Самый простой пример коллекций это список, он содержит несколько строк. Например, нужно выполнять операцию для каждой строки списка. Можно использовать универсальный цикл (см. листинг \ref{colluniloop}) или использовать упрощенное {\bf прохождение коллекций} (см. листинг \ref{collsimple}). Под коллекции имеется в виду следующие типы данных \code{list}, \code{set} и \code{element}.
\begin{lstlisting}[caption=Прохождение коллекций с помощью универсального цикла, label=colluniloop]
@list = ["apple" "banana" "fruit"];

for (@i = 0; @i < @list'length; @i = @i + 1) {
	@list.at @i; `` get i-th value
}
\end{lstlisting}

\begin{lstlisting}[caption=Упрощённое прохождение коллекций, label=collsimple]
@list = ["apple" "banana" "fruit"];

for (@list) {
	@; `` get i-th value
}
\end{lstlisting}

\subsubsection{\lstinline`filter` - выборочное прохождение коллекций}

{\bf Конструкция \code{filter}} позволяет ставить условие, для каких элементов коллекций выполнять тело цикла, для каких нет.

В условия есть специальные переменные: \lstinline|@| - значение элемента коллекций и \lstinline|#| - индекс текущей значения.

Фильтр имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
filter (collection, condition) {
	commands
};
\end{lstlisting}

Фильтровать элементы можно по данных (см. листинг \ref{filterdataex}, выбирается те которые содержат букву а) или по индексам (см. листинг \ref{filterindexex}, выбирается чётные элементы списка).

\begin{lstlisting}[caption=Фильтрование по данных, label=filterdataex]
@list = ["apple" "banana" "fruit"];

filter (@list, @ << "a") {
	@; `` apple, banana
}
\end{lstlisting}

\begin{lstlisting}[caption=Фильтрование по индексов, label=filterindexex]
@list = ["apple" "banana" "fruit"];

filter (@list, # \ 2 == 0) {
	@; `` apple, fruit
}
\end{lstlisting}

\subsubsection{\lstinline`range` - частичное прохождение коллекций}

{\bf Частичное прохождение} позволяет выполнить код для интервала коллекций. Интервал определяется одной или двум условий. Первое условие используется для поиска начала интервала. Второе условие - для поиска конца, если оно отсутствует, будет использоваться первое условие. В отсутствия подходящих элементов, тела цикла не будет выполнена. Чтобы выбирать первый или последний элемент (в зависимость от предназначения условии), использует выражение \true{}.

Синтаксис для интервала с одним условием -
\begin{lstlisting}[numbers=none]
range (collection, condition) {
	commands
};
\end{lstlisting}

Синтаксис для интервала с отдельным условием для начало и конца -
\begin{lstlisting}[numbers=none]
range (collection, condition_for_begin, condition_for_end) {
	commands
};
\end{lstlisting}

Выбрать первый и последний элемент можно по значении (см. листинг \ref{bananakiwiex}, интервал от значений \code{banana} до \code{kiwi}) или по индексам (см. листинг \ref{seclastex}, интервал от второго до последнего).

\begin{lstlisting}[caption=Интервал: от banana до kiwi, label=bananakiwiex]
@list = ["apple" "banana" "fruit" "kiwi"];

range (@list, @ == "banana", @ == "kiwi") {
	@; `` banana, fruit, kiwi
}
\end{lstlisting}

\begin{lstlisting}[caption=Интервал: от второго до последнего, label=seclastex]
@list = ["apple" "banana" "fruit" "kiwi"];

range (@list, # == 2, true) {
	@; `` fruit, kiwi
}
\end{lstlisting}

\newpage
\section{Интеграция с Javascript}

В языке icL {\bf интеграция с Javascript} отличается в разных режимах работы. {\bf Режимы работы} всего 2: тестирование и автоматизация. В дальнейшем параграфы будут отмечены следующим меткам: \code{[icL]} - относиться к автоматизации и расширенных возможностях icL, \code{[w3c]} - относиться к тестированию и стандарту WebDriver предложен World Wide Web Consortium.

\subsection{JS-Значения}

{\bf JS-Значения} - главное нововведение по интеграцию с JavaScript. Оно позволяет использовать переменные JavaScript удобно, как и переменных icL. Они также могут быть доступны только для чтения или для записи и чтения.

Каждое JS-Значение имеет геттер, но только переменные доступны для записи и чтения имеют сеттер. Геттеры и сеттеры являются фрагментами кода на языке JavaScript. В сеттере установленное значение передаётся следующим кодом \code{@{value}} Синтаксис JS-Значений:
\begin{lstlisting}[numbers=none]
$value {getter, setter};
\end{lstlisting}

Упрощённый синтаксис JS-Значений:
\begin{lstlisting}[numbers=none]
$value {getter};
\end{lstlisting}

В качестве JS-Значений может объявить любое переменное, на пример название страницы (см. листинг \ref{jsvalueex}), она остаётся доступной даже после перехода на другой странице.

\begin{lstlisting}[caption=Использование JS-Значений, label=jsvalueex]
@title = $value {document.title, document.title = @{value}};
_log.out @title;
@title = "Yet another title.";
\end{lstlisting}

\subsection{Выполнение кода на языке JavaScript}

Команда \lstinline|$run| позволяет выполнить {\bf код на языке JavaScript}.

\code{[icL]} Команда \lstinline|$run| получает один аргумент - код, в коде могут присутствовать переменные icL. Глобальные переменные предаются следующим образом \lstinline|#{name}|, локальные - \lstinline|@{name}|. Пример передачи значений перемены в JavaScript представлен на листинге \ref{jsrunex1}. Код можно выполнить асинхронно используя \lstinline|$runAsync|.

\begin{lstlisting}[caption=Выполнение кода на языке JavaScript (icL), label=jsrunex1]
@var = 2;
$run { window.a = @{var} }
\end{lstlisting}

\code{[w3c]} Команда \lstinline|$run| получает переменное количество переменных. Они передаются в коде на языке JavaScript в виде аргументов вызова функций. Доступ к ним осуществляется с помощью переменной \code{arguments}. Код использующий данную тактику представлен на листинге \ref{jsrunex2}, его можно сравнивать с листингом \ref{jsrunex1}. Код можно выполнить асинхронно используя \lstinline|$runAsync|.

\begin{lstlisting}[caption=Выполнение кода на языке JavaScript (w3c), label=jsrunex2]
@var = 2;
$run @var { window.a = arguments[0] }
\end{lstlisting}

\subsection{Выполнения файлов}

Команда \lstinline|$file| {\bf выполняет файлы} JavaScript (.js). Для этого достаточно передать путь к файлу в качестве аргумента.

Синтаксис -
\begin{lstlisting}[numbers=none]
$file "path/to/file.js";
\end{lstlisting}

Возможные ошибки: \ferror{FileNotFound}.

\subsection{Пользовательские скрипты}

\lstinline|[icL]| {\bf Пользовательские скрипты} выполняются до загрузки страницы, при переходе на страницу. Скрипт можно подкрепить как к текущей вкладке (\lstinline|$user|) так и ко всех вкладок из сессии (\lstinline|$always|).

\lstinline|[icL]| Синтаксис -
\begin{lstlisting}[numbers=none]
$user "path/to/file.js";
$always "path/to/file.js";
\end{lstlisting}

Возможные ошибки: \ferror{FileNotFound}.

\newpage
\section{Функции}

{\bf Функции} в icL позволяют повторное использовать код, и структурировать код. Все функций в icL - глобальные.

\subsubsection{Определение функции}

{\bf Определение функции} состоит из заголовка и тела функции.

\noindent Синтаксис -
\begin{lstlisting}[numbers=none]
!name = parameters : return_type {
	commands
}
\end{lstlisting}

Описание всех частей функции:
\begin{icItems}
\item
	\code{name} - {\bf название функции};
\item
	\code{parameters} - {\bf список параметров}. Когда функция вызывается вы передаёте значения параметру. Список параметров определяет тип, количество и порядок параметров. Список параметров необязателен (см. листинги \ref{fullfunc} и \ref{noargsfunc});
\item
	\code{return_type} - {\bf тип данных которых} функция будет возвращать. Если функция ничего не возвращает тип данных можно пропустить или указать явно \void{}. Чтобы возвращать значение используется команда \code{@ = value} (см. листинги \ref{fullfunc}, \ref{notypefunc} и \ref{minfunc});
\item
	\code{commands} - {\bf тело функции} содержит команды, которые определяют что делает функция.
\end{icItems}

\begin{lstlisting}[caption=Полноценная функция, label=fullfunc]
!sum = <int>a <int>b : int {
	@ = @a + @b;
};
\end{lstlisting}

\begin{lstlisting}[caption=Функция без аргументов, label=noargsfunc]
!pi = double {
	@ = 3.14;
};
\end{lstlisting}

\begin{lstlisting}[caption=Функция без типа возвращаемой значений, label=notypefunc]
!out = <int>a <int>b {
	_log.out @a @b;
};
\end{lstlisting}

\begin{lstlisting}[caption=Функция без аргументов и тип возвращаемой значений, label=minfunc]
!do = {
	_log.out "It's work!";
};
\end{lstlisting}

\subsubsection{Вызов функции}

Вы можете вызвать функцию следующим образом -
\begin{lstlisting}[numbers=none]
!name arguments;
\end{lstlisting}
где \code{name} - {\bf название функции}, \code{arguments} - {\bf список аргументов} (он должен быть совместим со списком параметров функции). Как вызвать функций, объявленные на листингов \ref{fullfunc} - \ref{minfunc}, показано на листинге \ref{callfunc}.


\begin{lstlisting}[caption=Вызов функций, label=callfunc]
!sum 2 3; 	`` returns 5
!pi; 		`` returns 3.14
!out 4 5; 	`` returns void
!do; 		`` returns void

!sum (!sum 1 2) 3;	`` returns 6
!out 1 (!sum 4 5);	`` returns void
\end{lstlisting}

\newpage
\section{Строки}

{\bf Строки} (тип \str{}) позволяет хранить и манипулировать фрагменты текста. 

В контексте строк появляется ещё один тип данных \chartype{}, он представляет символ в составе строки, и позволяет редактировать строку.

Тип данных \chartype{} имеет свойство \code{code : int} - код символа. Символ можно преобразовать в \str{} и он преобразуется автоматически при вызове функций. Тип \chartype{} нельзя передать как параметр функций.

\subsection{Свойства}

Строки имеют следующее дополнительные свойства:
\begin{icItems}
\item
	\code{string'empty : bool};
\item
	\code{string'length : int};
\item
	\code{string'last : char};
\item
	\lstinline|string'(<int>n) : char|.
\end{icItems}

\

На листинге \ref{stringprop} представлен код, использующий выше перечисленных свойства.

\begin{lstlisting}[caption=Свойства класса string, label=stringprop]
@empty = "";
@fonts = "Arial, Helvetica, Times, Courier";

@empty'empty; `` true
@fonts'empty; `` false

@empty'length; `` 0
@fonts'length; `` 32

@empty'last; `` error
@fonts'last; `` "r"

@empty'0; `` error
@fonts'0; `` "A"
\end{lstlisting}

\subsubsection{\code{string'empty : bool}}

Строка считается пустой если количество содержащих символов равна нулю (доступно только для чтения);

\subsubsection{\code{string'length : int}}

Длина строки равна количеству символов в строке;

\subsubsection{\code{string'last : char}}

Последний символ строки, то же самое что и \lstinline|string.at (string'length - 1)|.

Возможные ошибки: \ferror{OutOfBounds}.

\subsubsection{\lstinline|string'(<int> n) : char|}

n-й символ строки. n должен быть целым литералов, примеры \lstinline|@str'0; @string'2|.

Возможные ошибки: \ferror{OutOfBounds}.

\subsection{Методы}

Строки имеют следующий набор дополнительных методов:
\begin{icItems}
\item
	\lstinline|string.append <string>str : string|;
\item
	\lstinline|string.at <int>i : char|;
\item
	\lstinline|string.beginsWith <string>str : bool|;
\item
	\lstinline|string.compare <string>str <bool>caseSensitive = true : bool|;
\item
	\lstinline|string.count <string>str : int|;
\item
	\lstinline|string.endsWith <string>str : bool|;
\item
	\lstinline|string.indexOf <string>str <int>startPos = 0 : int|;
\item
	\lstinline|string.insert <string>str <int>pos : string|;
\item
	\lstinline|string.lastIndexOf <string>str <int>startPos = -1 : int|;
\item
	\lstinline|string.left <int>n : string|;
\item
	\lstinline|string.leftJustified <int>width <string>fillChar <bool>truncate = false : string|;
\item
	\lstinline|string.mid <int>pos <int>n = -1 : string|;
\item
	\lstinline|string.prepend <string>str : string|;
\item
	\lstinline|string.remove <int>pos <int>n : string|;
\item
	\lstinline|.remove <string>str <bool>caseSensitive = true : string|;
\item
	\lstinline|string.replace <int>pos <int>n <string>after : string|;
\item
	\lstinline|string.replace <string>before <string>after : string|;
\item
	\lstinline|string.right <int>n : string|;
\item
	\lstinline|string.rightJustified <int>width <string>fillChar <bool>truncate = false : string|;
\item
	\lstinline|string.split <string>separator <bool>keepEmptyParts = true <bool>caseSensitive = true : list|;
\item
	\lstinline|string.substring <int>begin <int>end : string|;
\item
	\lstinline|string.trim <bool>justWhitespace = true : string|.
\end{icItems}

Некоторые методы пропущены, они будут представлены в главе \ref{regex}; Код, использующий выше перечисленных методов представлен на листинге \ref{stringmethods}.

\begin{lstlisting}[caption=Методы класса string, label=stringmethods]
@empty = "";
@fonts = "Arial, Helvetica, Times, Courier";
@index = 2;

@empty.append "data";   `` "data"
@empty.append @fonts'0; `` "dataA"
@empty = "";

@empty.at @index; `` error
@fonts.at @index; `` i
@fonts.at 1;	  `` r

@empty.beginsWith "";      `` true
@fonts.beginsWith "Arial"; `` true

@empty.compare "data"; `` false
@empty.compare "";     `` true

@fonts.count ",";      `` 3
@fonts.count @fonts'0; `` 1

@fonts.endsWith "Courier"; `` true
@fonts.endsWith "Arial";   `` false

@fonts.indexOf "Courier"; `` 25
@fonts.indexOf @fonts'11; `` 8

@data = "10"
@data.insert "data" 1;   `` "1data0"
@data.insert @fonts'0 2; `` "1dAata0"

@fonts.lastIndexOf "e";      `` 30
@fonts.lastIndexOf @fonts'8; `` 30

@fonts.left 5; `` "Arial"

@data = "10";
@data.leftJustified 4 "0"; `` "0010"
@data.mid 1 2;             `` "01"

@data.prepend "11";     `` "1100010"
@data.prepend @fonts'0; `` "A1100010"

@data.remove 2 2;  `` "11010"
@data.remove "01"; `` "110"

@data.replace 2 1 "0101"; `` "110101"
@data.replace "01" "01";  `` "111010"

@data.right 4; 				`` "1010"
@data.rightJustified 8 "0"; `` "11101000"

@fonts.split ", ";     `` ["Arial" "Helvica" "Times" "Curier"]
@fonts.split @fonts'5; `` ["Arial" " Helvica" " Times" " Curier"];

@data.substring 1 3; `` "11"

@str = " , 34px \n";
@str.trim;       `` ", 34px"
@str.trim false; `` "34px"
\end{lstlisting}

\subsubsection{\lstinline|string.append <string>str : string|}

Вставит строку \code{str} в конце строки.

\subsubsection{\lstinline|string.at <int>i : char|}

Возвращает ссылка на \code{i}-й символ.

Возможные ошибки: \ferror{OutOfBounds}.

\subsubsection{\lstinline|string.beginsWith <string>str : bool|}

Возвращает \true{}, если начало строки совпадает с \code{str}, иначе \false{}.

\subsubsection{\lstinline|string.compare <string>str <bool>caseSensitive = true : bool|}

Сравнивает строки, возвращает \true{} если они равны, иначе \false{}. Аргумент \code{caseSensitive} может быть пропущен, если установить его в \false{}, то регистр букв будет проигнорирован.

\subsubsection{\lstinline|string.count <string>str : int|}

Считает сколько раз подстрока \code{str} встречается в строке.

\subsubsection{\lstinline|string.endsWith <string>str : bool|}

Возвращает \true{}, если конец строки совпадает с \code{str}, иначе \false{}.

\subsubsection{\lstinline|string.indexOf <string>str <int>startPos = 0 : int|}

Возвращает индекс первой нахождения подстроки \code{str} в строке, ища вперёд с позиции \code{startPos}, если подстрока не найдено возвращает -1.

\subsubsection{\lstinline|string.insert <string>str <int>pos : string|}

Вставит строку \code{str} в позиции \code{pos}.

\subsubsection{\lstinline|string.lastIndexOf <string>str <int>startPos = -1 : int|}

Возвращает индекс первой нахождения подстроки \code{str} в строке, ища назад с позиции \code{startPos}, если подстрока не найдена возвращает -1.

\subsubsection{\lstinline|string.left <int>n : string|}

Возвращает подстроку содержащая первый \code{n} символы.

\subsubsection{\lstinline|string.leftJustified <int>width <string>fillChar <bool>truncate = false : string|}

Возвращает строку длины \code{width}, содержащую эту строку, в конце ставится \code{width - .length} символов \code{fillChar}. Если \code{truncate == true} и \code{width < .length}, то последние \code{.length - width} символы будут удалены.

\subsubsection{\lstinline|string.mid <int>pos <int>n = -1 : string|}

Возвращает строку содержащую \code{n} символы строки, начиная с позиции \code{pos}. Будет возвращена пустая строка если установленный интервал выходит за рамки строки. Если \code{n == -1} то будут возвращены все доступные символы начиная с позицией \code{pos}.

\subsubsection{\lstinline|string.prepend <string>str : string|}

Вставит строку \code{str} в начале строки.

\subsubsection{\lstinline|string.remove <int>pos <int>n : string|}

Удаляет \code{n} символы строки начиная с позицией \code{pos}.

\subsubsection{\lstinline|string.remove <string>str <bool>caseSensitive = true : string|}

Удаляет каждое нахождения подстроки \code{str} в строке. Аргумент \code{caseSensitive} может быть пропущен, если установить его в \false{} то регистр букв будет проигнорирован.

\subsubsection{\lstinline|string.replace <int>pos <int>n <string>after : string|}

Заменяет интервал установленный позицией \code{pos} и количеством символов \code{n} строкой \code{after}.

\subsubsection{\lstinline|string.replace <string>before <string>after : string|}

Заменяет каждое нахождение подстроки \code{before} подстрокой \code{after}.

\subsubsection{\lstinline|string.right <int>n : string|}

Возвращает строку содержащую последние \code{n} символы строки.

\subsubsection{\lstinline|string.rightJustified <int>width <string>fillChar <bool>truncate = false : string|}

Возвращает строку длины \code{width}, содержащую эту строку, в начале ставится \code{width - .length} символов \code{fillChar}. Если \code{truncate == true} и \code{width < .length}, то первые \code{.length - width} символы будут удалены.

\subsubsection{\lstinline|string.split <string>separator <bool>keepEmptyParts = true <bool>caseSensitive = true : list|}

Разрывает строку на подстроки при каждой нахождения подстроки \code{separator} и собирает список из этих строк. Если \code{separator} не встречается ни разу, будет возвращён список из одной строки - этой строки. Если \code{keepEmptyParts == false} то пустые строки пропускаются.

\subsubsection{\lstinline|string.split <char>separator <bool>keepEmptyParts = true <bool>caseSensitive = true : list|}

Разрывает строку на подстроки при каждой нахождения символа \code{separator} и собирает список из этих строк. Это перегруженная функция.

\subsubsection{\lstinline|string.substring <int>begin <int>end : string|}

Возвращает подстроку содержащую символы строки, от позиции \code{begin} до \code{end}.

\subsubsection{\lstinline|string.trim <bool>justWhitespace = true : string|}

Возвращает строку, копия текущей из которого удаляются пробельные символы с начало и конце строки. Если \lstinline|justWhitespace == false|, то будут удалены все знаки которые не является буквой или цифрой.

% \subsubsection{}

\newpage
\section{Списки}

{\bf Списки} (тип \code{string}) позволяет хранить несколько строк в одной переменной. Доступ к ним обеспечивается через индекс - номер по порядку строке в списке.

\subsection{Свойства}

Списки имеют следующее дополнительные свойства:
\begin{icItems}
\item
	\lstinline|list'empty : bool|;
\item
	\lstinline|list'length : int|;
\item
	\lstinline|list'last : string|;
\item
	\lstinline|list'(<int>n) : string|.
\end{icItems}

На листинге \ref{listprop} представлен код, использующий выше перечисленных свойства.

\begin{lstlisting}[caption=Свойства класса list, label=listprop]
@empty = [];
@fonts = ["Arial" "Helvetica" "Times" "Courier"];

@empty'empty; `` true
@fonts'empty; `` false

@empty'length; `` 0
@fonts'length; `` 4

@empty'last; `` error
@fonts'last; `` "Courier"

@empty'0; `` error
@fonts'0; `` "Arial"
\end{lstlisting}

\subsubsection{\lstinline|list'empty : bool|}

Список считается пустым если он не содержит ни одну строку.

\subsubsection{\lstinline|list'length : int|}

Длина списка равна количеству строк в списке.

\subsubsection{\lstinline|list'last : string|}

Последняя строка в списке, то же соме что и \lstinline|list'at (list'length - 1)|.

Возможные ошибки: \ferror{OutOfBounds}.

\subsubsection{\lstinline|list'(<int>n) : string|}

n-я строка списка, n должен быть целым литералом.

Возможные ошибки: \ferror{OutOfBounds}.

\subsection{Методы}

Списки имеют следующий набор дополнительных методов:
\begin{icItems}
\item \lstinline|list.append <string>str : list|;
\item \lstinline|list.at <int>i : string|;
\item \lstinline|list.contains <string>str <bool>caseSensitive = true : bool|;
\item \lstinline|list.clear : list|;
\item \lstinline|list.count <string>what : int|;
\item \lstinline|list.filter <string>str <bool>caseSensitive = true : bool|;
\item \lstinline|list.indexOf <string>str <int>start = 0 : int|;
\item \lstinline|list.insert <int>index <string>str : list|;
\item \lstinline|list.join <string>separator : string|;
\item \lstinline|list.lastIndexOf <string>str <int>start = -1|;
\item \lstinline|list.mid <int>pos <int>n = -1 : list|;
\item \lstinline|list.prepend <string>str : list|;
\item \lstinline|list.move <int>from <int>to : list|;
\item \lstinline|list.removeAll <string>str : list|;
\item \lstinline|list.removeAt <int>i : list|;
\item \lstinline|list.removeDuplicates : list|;
\item \lstinline|list.removeFirst : list|;
\item \lstinline|list.removeLast : list|;
\item \lstinline|list.removeOne <string>str : bool|;
\item \lstinline|list.replaceInStrings <string>before <string>after : list|;
\item \lstinline|list.sort <bool>caseSensitive = true : list|.
\end{icItems}

Некоторые методы пропущены, они будут представлены в главе \ref{regex}; Код, использующий выше перечисленных методов представлен на листинге \ref{listmethods}. 

\begin{lstlisting}[caption=Методы класса list, label=listmethods]
@empty = [];
@fonts = ["Arial" "Helvetica" "Times" "Courier"];

@empty.append "";              `` [""]
@fonts.at 2;                   `` "Times"
@fonts.contains "arial";       `` false
@fonts.contains "arial" false; `` true
@empty.clear;                  `` []
@fonts.count "Arial";          `` 1

@fonts.filter "e";          `` ["Helvetica" "Times" "Courier"]
@fonts.indexOf "Times";     `` 2
@fonts.insert 1 "DejaVu";   `` ["Arial" "DejaVu" "Helvetica" "Times" "Courier"]
@fonts.join ", ";           `` "Arial, DejaVu, Helvetica, Times, Courier"
@fonts.lastIndexOf "Arial"; `` 0

@fonts.mid 2 2;          `` ["Times" "Courier"]
@fonts.prepend "DejaVu"; `` ["DejaVu" "Arial" "DejaVu" .. "Courier"]
@fonts.move 1 2;         `` ["DejaVu" "DejaVu" "Arial" "Helvetica" ..]

@fonts.removeAll "Helvetica"; `` ["DejaVu" "DejaVu" "Arial" "Times" "Courier"]
@fonts.removeAt 3;            `` ["DejaVu" "DejaVu" "Arial" "Courier"]
@fonts.removeDuplicates;      `` ["DejaVu" "Arial" "Courier"]
@fonts.removeFirst;           `` ["Arial" "Courier"]
@fonts.removeLast;            `` ["Arial"]
@fonts.removeOne "Arial";     `` []

@fonts = ["Arial" "Helvetica" "Times" "Courier"];

@fonts.replaceInStrings "e" "-"; `` ["Arial" "H-lv-tica" "Tim-s" "Couri-r"];
@fonts.sort;                     `` ["Arial" "Couri-r" "H-lv-tica" "Tim-s"];
\end{lstlisting}

Параметр \code{caseSensitive} во всех функциях отвечает за чувствительность к регистру. Его установка гарантирует что регистр букв будет проигнорирован.

\subsubsection{\lstinline|list.append <string>str : list|}

Вставит строку \code{str} в конце списка.

\subsubsection{\lstinline|list.at <int>i : string|}

Возвращает \code{i}-й строка.

Возможные ошибки: \ferror{OutOfBounds}.

\subsubsection{\lstinline|list.contains <string>str <bool>caseSensitive = true : bool|}

Возвращает \true, если список содержит строка, ровна \code{str}, иначе \false.

\subsubsection{\lstinline|list.clear : list|}

Очищает список.

\subsubsection{\lstinline|list.count <string>what : int|}

Возвращает сколько раз строка \code{what} повторяется в списке.

\subsubsection{\lstinline|list.filter <string>str <bool>caseSensitive = true : bool|}

Возвращает новый список строк, содержащий только строки этого списка, содержащие подстроку \code{str}. 

\subsubsection{\lstinline|list.indexOf <string>str <int>start = 0 : int|}

Возвращает индекс первой нахождения строки \code{str} в списке, ища вперёд с позиции \code{start}, если строка не найдено возвращает -1.

\subsubsection{\lstinline|list.insert <int>index <string>str : list|}

Вставит строку \code{str} в позиции \code{index}, если \code{index <= 0} то значение вставится в начале списка, если \code{index >= list'length} то значение вставится в конце списка.

\subsubsection{\lstinline|list.join <string>separator : string|}

Создаёт новую строку, из строк списка, путём последовательной конкатенации, между значениями вставится \code{separator}, он может быть пустой строкой.

\subsubsection{\lstinline|list.lastIndexOf <string>str <int>start = -1|}

Возвращает индекс первой нахождения строки \code{str} в списке, ища назад с позиции \code{start}, если строка не найдена возвращает -1.

\subsubsection{\lstinline|list.mid <int>pos <int>n = -1 : list|}

Возвращает новый список, содержащий \code{n} строки, начиная со строкой с индексом \code{pos}. Если \code{n} имеет значение \code{-1} то будут добавлены все значение до конца списка.

\subsubsection{\lstinline|list.prepend <string>str : list|}

Вставит строку \code{str} в начале списка.

\subsubsection{\lstinline|list.move <int>from <int>to : list|}

Переставит строку с индексом \code{from} в позиции с индексом \code{to}.

Возможные ошибки: \ferror{OutOfBounds}.

\subsubsection{\lstinline|list.removeAll <string>str : list|}

Удаляет все нахождения строке \code{str}.

\subsubsection{\lstinline|list.removeAt <int>i : list|}

Удаляет \code{i}-я строка.

Возможные ошибки: \ferror{OutOfBounds}.

\subsubsection{\lstinline|list.removeDuplicates : list|}

Удаляет повторы строк.

\subsubsection{\lstinline|list.removeFirst : list|}

Удаляет первую строку.

Возможные ошибки: \ferror{OutOfBounds}.

\subsubsection{\lstinline|list.removeLast : list|}

Удаляет последнюю строку.

Возможные ошибки: \ferror{OutOfBounds}.

\subsubsection{\lstinline|list.removeOne <string>str : bool|}

Удаляет первое нахождение строке \code{str}. Возвращает \true, если строка была найдена, иначе \false.

\subsubsection{\lstinline|list.replaceInStrings <string>before <string>after : list|}

Заменяет подстроку \code{before} с подстрокой \code{after} в каждом строке.

\subsubsection{\lstinline|list.sort <bool>caseSensitive = true : list|}

Сортирует строки в алфавитном порядке.

\newpage
\section{Множества}

{\bf Множества} (тип \set) позволяют хранить несколько объектов (тип \object) без повторений, для множеств доступны операции как пересечение, объединение.

\subsection{{\color{bluemarin} object}}

Объект позволяет хранить несколько переменных, каждая хранимая переменная имеет тип и название. Доступ к переменным осуществляется через свойства объекта, где название свойств и есть название переменных.

Поле объектов множества описаны в заголовке множества.

\subsection{Свойства}

Множества имеют следующие свойства:
\begin{icItems}
\item \lstinline|set'capacity : int|;
\item \lstinline|set'empty : bool|;
\end{icItems}

\subsubsection{\lstinline|set'capacity : int|}

Возвращает количество объектов которых можно хранить в память без дополнительных выделений.

\subsubsection{\lstinline|set'empty : bool|}

Множество считается пустой если оно не содержит ни один объект.

\subsection{Методы}

Множество имеет следующие методы:
\begin{icItems}
\item \lstinline|set.applicate <list ...>data|;
\item \lstinline|set.clear : set|;
\item \lstinline|set.getField <string>name <list>value : list|;
\item \lstinline|set.insert <any ...>data : set|;
\item \lstinline|set.insert <object>obj : set|;
\item \lstinline|set.insertBoolField <string>name <list>values : set|;
\item \lstinline|set.insertDoubleField <string>name <list>values : set|;
\item \lstinline|set.insertIntField <string>name <list>values : set|;
\item \lstinline|set.insertListField <string>name <list>value : set|;
\item \lstinline|set.insertStringField <string>name <list>values : set|;
\item \lstinline|set.remove <any ...>data : set|;
\item \lstinline|set.remove <object>obj : set|;
\item \lstinline|set.removeField <string>name : set|.
\end{icItems}

Код использующий выше перечисленных методов представлен на листинге \ref{setmethods};

\begin{lstlisting}[caption=Методы класса set, label=setmethods]
@set = [<int>age <string>name <string>sex]

@set.applicate 
	["23"    "45"     "67"]
	["Basil" "Nataly" "Siri"]
	["m"     "f"      "f"];
``` set = [
	[<23>age <"Basil">name  <"m">sex]
	[<45>age <"Nataly">name <"f">sex]
	[<67>age <"Siri">name   <"f">sex]
	] ```

@set.getField "name"; `` ["Basil" "Nataly" "Siri"]

@set.insert 34 "Critiano" "m";
``` set = [
	[<23>age <"Basil">name    <"m">sex]
	[<45>age <"Nataly">name   <"f">sex]
	[<67>age <"Siri">name     <"f">sex]
	[<34>age <"Cristiano"name <"m">sex]
	] ```

@set.insert [<"f">sex <"Sofia">name <19>age];
``` set = [
	[<23>age <"Basil">name    <"m">sex]
	[<45>age <"Nataly">name   <"f">sex]
	[<67>age <"Siri">name     <"f">sex]
	[<34>age <"Cristiano"name <"m">sex]
	[<19>age <"Sofia">name    <"f">sex]
	] ```

@set.insertStringField "parity" ["odd" "even"];
``` set = [
	[<23>age <"Basil">name    <"m">sex <"odd">parity]
	[<45>age <"Nataly">name   <"f">sex <"even">parity]
	[<67>age <"Siri">name     <"f">sex <"odd">parity]
	[<34>age <"Cristiano"name <"m">sex <"even">parity]
	[<19>age <"Sofia">name    <"f">sex <"odd">parity]
	] ```

@set.remove 45 "Nataly" "f" "even";
``` set = [
	[<23>age <"Basil">name    <"m">sex <"odd">parity]
	[<67>age <"Siri">name     <"f">sex <"odd">parity]
	[<34>age <"Cristiano"name <"m">sex <"even">parity]
	[<19>age <"Sofia">name    <"f">sex <"odd">parity]
	] ```

@set.remove [<34>age <"Cristiano"name <"m">sex <"even">parity];
``` set = [
	[<23>age <"Basil">name <"m">sex <"odd">parity]
	[<67>age <"Siri">name  <"f">sex <"odd">parity]
	[<19>age <"Sofia">name <"f">sex <"odd">parity]
	] ```

@set.removeField "parity";
``` set = [
	[<23>age <"Basil">name <"m">sex]
	[<67>age <"Siri">name  <"f">sex]
	[<19>age <"Sofia">name <"f">sex]
	] ```

@set.clear; `` set = []
\end{lstlisting}

\subsubsection{\lstinline|set.applicate <list ...>data|}

Количество полученных списков должна быть равна количеству полей объектов множества. Количество добавленных объектов будет ровна длине самого длинного списка из \code{data}. Из списков в которых не хватает строк, элементы будут добавлены повторно.

\subsubsection{\lstinline|set.clear : set|}

Очищает множество.

\subsubsection{\lstinline|set.getField <string>name : list|}

Возвращает список значений поле \code{name} всех объектов.

Возможные ошибки: \ferror{FieldNotFound}.

\subsubsection{\lstinline|set.hasField <string>name : bool|}

Возвращает \true, если заголовок содержит поле \code{name}, иначе \false.

\subsubsection{\lstinline|set.insert <any ...>data : set|}

Вставит новый объект, значения полей (массив \code{data}) должна полностью соблюдать порядок и тип данных, определён заголовком множество.

\subsubsection{\lstinline|set.insert <object>obj : set|}

Вставит новый объект, поля объекта \code{obj} должна быть совместимы полностью с заголовком множество.

\subsubsection{\lstinline|set.insertBoolField <string>name <list>values : set|}

Создаёт новое поле типа \bool. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные ошибки: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertDoubleField <string>name <list>values : set|}

Создаёт новое поле типа \double. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные ошибки: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertIntField <string>name <list>values : set|}

Создаёт новое поле типа \integer. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные ошибки: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertListField <string>name <list>value : set|}

Создаёт новое поле типа \bool. Все объекты множеству получат новое поле со значением \code{value}.

Возможные ошибки: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertStringField <string>name <list>values : set|}

Создаёт новое поле типа \str. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные ошибки: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.remove <any ...>data : set|}

Удаляет объект, который подходит по описанию \code{data}.

\subsubsection{\lstinline|set.remove <object>obj : set|}

Удаляет объект \code{obj} из множества.

\subsubsection{\lstinline|set.removeField <string>name : set|}

Удаляет поле \code{name} с заголовка.

Возможные ошибки: \ferror{FieldNotFound}.

\newpage
\section{Веб-элементы}
\label{webelments}

{\bf Веб-элементы} (тип данных \element) представляет собой ссылки на HTML-теги веб-страницы.

\subsection{Свойства}

Веб-элементы имеют следующее свойства:
\begin{icItems}
\item \lstinline|element'attr-* : string|;
\item \lstinline|element'css-* : string|;
\item \lstinline|element'enabled : bool|;
\item \lstinline|element'prop-* : string|;
\item \lstinline|element'rect : obj|;
\item \lstinline|element'selected : bool|;
\item \lstinline|element'tag : string|;
\item \lstinline|element'text : string|;
\item \lstinline|element'(<int> n) : element|;
\end{icItems} 

\subsubsection{\lstinline|element'attr-* : string|}

\code{[w3c]} Возвращает значения атрибута \code{*}, доступно только для чтения. Больше информации: https://www.w3.org/TR/webdriver1/\#get-element-attribute

\code{[icL]} Возвращает JS-значение для запрашиваемого атрибута. Доступно для чтений и записи.

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element'css-* : string|}

\code{[w3c]} Возвращает значения свойства CSS \code{*}, доступно только для чтения. Больше информации: https://www.w3.org/TR/webdriver1/\#get-element-css-value

\code{[icL]} Возвращает JS-значение для запрашиваемой свойства CSS. Доступно для чтений и записи.

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element'enabled : bool|}

Возвращает \false, если элемент является элементом формы и он отключен, иначе \true. Больше информации: https://www.w3.org/TR/webdriver1/\#is\--element\--enabled

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element'prop-* : string|}

\code{[w3c]} Возвращает значения свойства \code{*}, доступно только для чтения. Больше информации: https://www.w3.org/TR/webdriver1/\#get-element-property

\code{[icL]}  Возвращает JS-значение для запрашиваемой свойства. Доступно для чтений и записи.

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element'rect : obj|}

Возвращает положение размер элемента на экране в CSS пикселей, а точнее объект содержащий следующее поля:
\begin{icItems}
	\item \code{x} - координата x относительно левого края;
	\item \code{y} - координата y относительно верхнего края;
	\item \code{width} - ширина;
	\item \code{height} - высота;
\end{icItems}

\code{[icL]} Возвращает \set, если количество элементов отлично от единицы.

Больше информации: https://www.w3.org/TR/webdriver1/\#get-element-rect

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element'selected : bool|}

Возвращает true, если элемент является включённым чекбоксом, отмеченной радио кнопкой или выбранной опцией, иначе false. Больше информации: \\* https://www.w3.org/TR/webdriver1/\#is-element-selected

Возможные ошибки: \ferror{EmptyElement}, \ferror{MultipleElements}, \ferror{NoWindow} и \ferror{NoSuchElement}.

\subsubsection{\lstinline|element'tag : string|}

Возвращает название тега. Больше информации: \\* https://www.w3.org/TR/webdriver1/\#get-element-tag-name

\code{[icL]} Возвращает \listtype, если количество элементов отлично от единицы.

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element'text : string|}

Возвращает текст элемента видимый на экран. Больше информации: \\* https://www.w3.org/TR/webdriver1/\#get-element-text

\code{[icL]} Возвращает \listtype, если количество элементов отлично от единицы.

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element'(<int> n) : element|}

Возвращает новую коллекцию содержащую n-й элемент.

Возможные ошибки: \ferror{OutOfBounds}.

\subsection{Операторы}

В контексте веб-элементов появляются новые операторы:
\begin{icItems}
	\item \lstinline|void % element : element|;
	\item \lstinline|element % void : element|;
	\item \lstinline|element % element : element|;
	\item \lstinline|[element ...] : element|;
\end{icItems}

\subsubsection{\lstinline|void \% element : element|}

Возвращает полученный элемент.

\subsubsection{\lstinline|element \% void : element|}

Возвращает полученный элемент.

\subsubsection{\lstinline|element \% element : element|}

Возвращает новую коллекцию, содержащая обоих элементов.

\subsubsection{\lstinline|[element ...] : element|}

Возвращает новую коллекцию, содержащая всех представленных элементов.

\subsection{Методы}

{\bf Методы} класса \code{element} делится на 2 категории: базовые и расширенные. Базовые методы определены стандартом W3C WebDriver. Расширенные методы определяются стандартом языка icL и могут быть изменены в следующих версиях языка.

\subsection{Базовые методы}

Перечень базовых методов:
\begin{icItems}
	\item \lstinline|element.clear : element|;
	\item \lstinline|element.click : element|;
	\item \lstinline|element.query <string>cssSelector : element|;
	\item \lstinline|element.query <int>by <string>selector : element|;
	\item \lstinline|element.queryAll <string>cssSelector : element|;
	\item \lstinline|element.queryAll <int>by <string>selector : element|;
	\item \lstinline|element.queryAllByXPath <string>xpath : element|;
	\item \lstinline|element.queryByXPath <string>xpath : element|;
	\item \lstinline|element.queryLink <string>name <bool>isFragment = false : element|;
	\item \lstinline|element.queryLinks <string>name <bool>isFragment = false : element|;
	\item \lstinline|element.queryTag <string>name : element|;
	\item \lstinline|element.queryTags <string>name : element|;
	\item \lstinline|element.screenshot : string|;
	\item \lstinline|element.sendKeys <int>modifiers <string>text : element|;
\end{icItems}

\subsubsection{\lstinline|element.clear : element|}

Если элемент является полем ввода данных, то ого значение очищается. Если элемент редактируемый, то его свойство \code{innerHtml} присваивается пустая строка. Больше информации: https://w3c.github.io/webdriver1/\#element-clear.

\code{[icL]} Очищены будут все элементы контейнера.

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element.click : element|}

Симулирует клик по центре элемента, и ждёт загрузка страницы. Больше информации: https://w3c.github.io/webdriver1/\#element-click

\code{[icL]} Клик будет симулирован на все элементы контейнера.

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow}, \ferror{InvalidElement}, \ferror{ElementNotInteractable}, \ferror{ElementClickIntercepted} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element.query <string>cssSelector : element|}

Акроним для \lstinline|element.query _by'cssSelector @cssSelector}|; 

\subsubsection{\lstinline|element.query <int>by <string>selector : element|}

Параметр \code{by} получает одно из следующих значений:
\begin{icItems}
	\item \lstinline|_by'cssSelector| - селектор CSS;
	\item \lstinline|_by'linkText| - текст ссылки;
	\item \lstinline|_by'partialLinkText| - фрагмент текста ссылки;
	\item \lstinline|_by'tagName| - название тега;
	\item \lstinline|_by'xPath| - XPath.
\end{icItems}

Параметр \code{selector} получает селектор CSS, текст ссылки, фрагмент текста ссылки, название тега или XPath, в зависимость от значений первого параметра.

Метод возвращает новый \element{} содержащий все элементы найдены по нужному методу в текущем элементе.

\code{[icL]} Поиск ведётся во всех элементов контейнера.

Больше информации:
\begin{icItems}
\item https://w3c.github.io/webdriver1/\#locator-strategies;
\item https://w3c.github.io/webdriver1/\#find-element-from-element
\end{icItems}

Возможные ошибки: \ferror{EmptyElement}, \ferror{ElementNotFound} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element.queryAll <string>cssSelector : element|}

Акроним для \lstinline|element.queryAll _by'cssSelector @cssSelector}|;

\subsubsection{\lstinline|element.queryAll <int>by <string>selector : element|}

Параметры получают такие же значения, как и в случае с \code{element.query}, только данный метод возвращает все найденные элементы или пустую коллекцию если ничего не нашлось.

\code{[icL]} Поиск ведётся во всех элементов контейнера.

Больше информации: https://w3c.github.io/webdriver1/\#find-elements-from-element

Возможные ошибки: \ferror{EmptyElement} и \ferror{MultipleElements} только в режиме тестирования, также \ferror{NoWindow} и \ferror{NoSuchElement} в любом режиме.

\subsubsection{\lstinline|element.queryAllByXPath <string>xpath : element|}

Акроним для \lstinline|element.queryAll _by'xPath @xpath}|;

\subsubsection{\lstinline|element.queryByXPath <string>xpath : element|}

Акроним для \lstinline|element.query _by'xPath @xpath}|;

\subsubsection{\lstinline|element.queryLink <string>name <bool>isFragment = false : element|}

Акроним для \lstinline|element.query _by'linkText @name}| и \lstinline|element.query _by'partialLinkText @name}|;

\subsubsection{\lstinline|element.queryLinks <string>name <bool>isFragment = false : element|}

Акроним для \lstinline|element.queryAll _by'linkText @name}| и \lstinline|element.queryAll _by'partialLinkText @name}|;

\subsubsection{\lstinline|element.queryTag <string>name : element|}

Акроним для \lstinline|element.query _by'tagName @name}|;

\subsubsection{\lstinline|element.queryTags <string>name : element|}

Акроним для \lstinline|element.queryAll _by'tagName @name}|;

\subsubsection{\lstinline|element.screenshot : string|}

Возвращает строку, содержащая код base64 скриншота элемента. Его можно сохранить как изображение используя \lstinline|_make.image <string>base64 <string>path : void|.

Больше информации: https://w3c.github.io/webdriver1/\#take-element-screenshot

Возможные ошибки: \ferror{EmptyElement}, \ferror{MultipleElements}, \ferror{NoWindow} и \ferror{NoSuchElement}.

\subsubsection{\lstinline|element.sendKeys <int>modifiers <string>text : element|}

Параметр \code{modifiers} получает один из следующих параметров (или сумма нескольких из них):
\begin{icItems}
	\item \lstinline|_key'ctrl| - Control;
	\item \lstinline|_key'shift| - Shift;
	\item \lstinline|_key'alt| - Alt;
\end{icItems}

Параметр \code{text} получает текст, будущим напечатанным на клавиатуре.

Больше информации: https://w3c.github.io/webdriver1/\#element-send-keys

Возможные ошибки: \ferror{EmptyElement}, \ferror{MultipleElements}, \ferror{ElementNotIntractable} \ferror{NoWindow} и \ferror{NoSuchElement}.

\subsubsection{Расширенные методы}

Расширенные методы могут работать медленно в режиме тестирования при использовании внешнего браузера. При содержании нескольких элементов в коллекции, операции принимаются на каждого элемента.

Перечень расширенных методов:
\begin{icItems}
	\item \lstinline|element.add <element>other : element|;
	\item \lstinline|element.child <int>index : element|;
	\item \lstinline|element.closest <string>cssSelector : element|;
	\item \lstinline|element.contains <string>text <bool>asFragment = false : element|;
	\item \lstinline|element.copy : element|;
	\item \lstinline|element.filter <string>cssSelector : element|;
	\item \lstinline|element.next : element|;
	\item \lstinline|element.prev : element|;
	\item \lstinline|element.parent : element|;
\end{icItems}

\subsubsection{\lstinline|element.add <element>other : element|}

Добавит все элементы коллекции \code{other}.

\subsubsection{\lstinline|element.child <int>i : element|}

Возвращает новая коллекция, содержащая \code{i}-й дочерний элемент.

\subsubsection{\lstinline|element.closest <string>cssSelector : element|}

Возвращает новая коллекция, содержащая ближайший родительский элемент, который подходит по селектору \code{cssSelector}.

\subsubsection{\lstinline|element.contains <string>text <bool>asFragment = false : element|}

Возвращает новая коллекция, содержащая все элементы, которые содержат текст/фрагмент \code{text}.

\subsubsection{\lstinline|element.copy : element|}

Возвращает новая коллекция, содержащая все элементы текущей коллекций.

\subsubsection{\lstinline|element.filter <string>cssSelector : element|}

Возвращает новая коллекция, содержащая все элементы, которые подходят по селектору \code{cssSelector}.

\subsubsection{\lstinline|element.next : element|}

Возвращает новая коллекция, содержащая следующий дочерний элемент.

\subsubsection{\lstinline|element.prev : element|}

Возвращает новая коллекция, содержащая предыдущий дочерний элемент.

\subsubsection{\lstinline|element.parent : element|}

Возвращает новая коллекция, содержащая родительский элемент.

\newpage
\section{Обмен данных с веб-странице}
\label{dataexchange}

\subsubsection{Название странице}

Название страницы можно получить вызывая \lstinline|_tab'title : string|.

Больше информации: https://www.w3.org/TR/webdriver1/\#get-title

\code{[icL]} Название страницы можно изменить присваивая нужное значение \lstinline|_tab'title = "title"|.

\subsubsection{Исходный код}

Исходный код страницы можно получить вызывая \lstinline|_tab'source : string|.

Больше информации: https://www.w3.org/TR/webdriver1/\#get-page-source

\subsubsection{Screenshot}

Screenshot страницы в base64 можно получить вызывая \lstinline|_tab'screenshot : string|.

Больше информации: https://www.w3.org/TR/webdriver1/\#take-screenshot

\subsubsection{URL}

Адрес доступен для записи и чтения, он доступен через свойство \lstinline|_tab'url : string|.

Больше информации:
\begin{icItems}
\item https://www.w3.org/TR/webdriver1/\#navigate-to
\item https://www.w3.org/TR/webdriver1/\#get-current-url
\end{icItems}

\subsubsection{Навигация}

\lstinline|_tab.back : void| - позволяет возвращаться на предыдущую страницу. Больше информации: https://www.w3.org/TR/webdriver1/\#back

\lstinline|_tab.forward : void| - позволяет возвращаться на следующую страницу. Больше информации: https://www.w3.org/TR/webdriver1/\#forward

\lstinline|_tab.refresh : void| -  "Да". позволяет перезагрузить страницу. Больше информации: https://www.w3.org/TR/webdriver1/\#refresh

\lstinline|[icL] _tab'canGoBack : bool| - сообщает можно ли перейти на предыдущую страницу.

\lstinline|[icL] _tab'canGoForward : bool| - сообщает можно ли перейти на следующую страницу.


\subsubsection{Предупреждения}

\lstinline|_alert'text : string| - текст предупреждений (доступен только для чтения). Больше информации: https://www.w3.org/TR/webdriver1/\#get-alert-text

\lstinline|_alert.accept : void| - закрыть окно отвечая положительным ответом. Больше информации: https://www.w3.org/TR/webdriver1/\#accept-alert

\lstinline|_alert.desmiss : void| - закрыть окно отвечая отрицательным ответом. Больше информации: https://www.w3.org/TR/webdriver1/\#dismiss-alert

\lstinline|_alert.sendKeys <string>str : void| - ответить текстом \code{str}. Больше информации: https://www.w3.org/TR/webdriver1/\#send-alert-text

% Возможные ошибки: \ferror{NoSuchWindow}, \ferror{NoSuchAlert}, \ferror{ElementNotInteractable}.

\newpage
\part{Материал для программистов}

Для освоение данного материала нужны знания в программирование. В ней не будет прописано обозначения технических терминов. Но Вы не расстраивайтесь, всё можно погуглить. Несмотря на то что язык icL - простой, на него можно реализовать сложные скрипты, работы с базами данных, регулярных выражении и много другое, ожидается сильное развитие данной части в следующих версиях языка icL.

\section{Регулярные выражения {\color{bluemarin} regex}}
\label{regex}

Для объявления {\bf регулярных выражения} используется литерал \lstinline|//pattern//mods|, где \code{pattern} - шаблон регулярней выражений, \code{mods} - модификаторы. В шаблоне группы можно наименовать, анонимная группа имеет следующий синтаксис \lstinline|(content)|, именованная группа - \lstinline|(?<name>content)|.

Внутренний символ может быть не только \code{/}, но и любой другой на свой вкус, кроме апострофа (\lstinline|'|) он конфликтует с оператором {\it корень} (\lstinline|/'|), \lstinline|@|, \lstinline|#|, \lstinline|-|, \lstinline|+| и \lstinline|!|. Например  \lstinline|/"pattern"/mods|, \lstinline|/:pattern:/mods|, \lstinline|/$pattern$/mods|.

Для того чтобы захватить начало строки можно использовать \lstinline|^| и \lstinline|\A|, а для конца строки - \lstinline|$| и \lstinline|\z|. Первый вариант несмотря на его популярность может срабатывать неправильно, так как им захватывается начало и конец строки в контексте многострочного текста.

\subsection{Модификаторы}

В языке icL присутствуют следующее модификаторы: \code{/i}, \code{/s}, \code{/m}, \code{/x}, \code{/u} и \code{/f}. Модификаторы можно скомбинировать, например \code{/xi}.

\subsubsection{Модификатор \code{/i}}

Регистр букв будет проигнорирован. 

\subsubsection{Модификатор \code{/s}}

Точка будет означать любой символ, включая символа {\it новая строка}.

\subsubsection{Модификатор \code{/m}}

Метасимволы \lstinline|^| и \lstinline|$| будут означать начало и конец строки не только в общем смысле, но и в контексте многострочного текста.

\subsubsection{Модификатор \code{/x}}

Все пробельные символы будут проигнорированы, и символ \lstinline|#| будет означать начало комментария, который заканчивается символом {\it новая строка}.

\subsubsection{Модификатор \code{/u}}

Классы символов \lstinline|\w|, \lstinline|\d| и т.д. и их отрицаний \lstinline|\W|, \lstinline|\D| и т.д. будут соответствовать не только английских символов, но и национальных.

\subsubsection{Модификатор \code{/f}}

Инвертирует жадность квантификаторов \lstinline|*|, \lstinline|+|, \lstinline|?| и т.д. и они становятся ленивыми. А их ленивые версии \lstinline|*?|, \lstinline|+?|, \lstinline|??| и т.д. становятся жадными.

{\bf Жадный квантификатор} захватывает максимальное количество символов. {\bf Ленивый квантификатор} - минимальное.

\subsection{Операторы}

Для регулярных выражений доступны следующие операторы:
\begin{icItems}
\item
	3-ого ранга:
	\begin{icItems}
	\item
		\lstinline|string << regex : bool|;
	\item
		\lstinline|string <* regex : list|.
	\end{icItems}

\item 
	6$^+$-ого ранга: \lstinline|string ** regex : object|.
\end{icItems}

Примеры использования операторов приведены на листинге \ref{regexpopsex}.

\begin{lstlisting}[caption=Операторы регулярных выражений, label=regexpopsex]
"string" << //s.r//;            `` true
"string" << //s(.)r//;          `` ["str" "t"]
"string" << //s(?<letter>.)r//; `` [<"t">letter]
\end{lstlisting}

\subsubsection{\lstinline|string << regex : bool|}

Возвращает \true{}, если строка содержит подстроку подходящая по шаблону регулярней выражений, иначе \false{}.

\subsubsection{\lstinline|string <* regex : list|}

Возвращает список захваченных подстрок если строка содержит подстроку подходящая по шаблону регулярней выражений, иначе пустой список.

\subsubsection{\lstinline|string ** regex : object|}

Возвращает объект, содержащий значения всех именованных групп, если строка содержит подстроку подходящая по шаблону регулярней выражений и объявлены именованные группы, иначе пустой объект.

% \subsubsection{}

\subsection{Методы}

Методы классы \str{} и \listtype, имеющие параметры типа \regex{}:
\begin{icItems}
\item
	\lstinline|string.count <regex>re : int|;
\item
	\lstinline|string.indexOf <regex>re <int>startPos = -1 : int|;
\item
	\lstinline|string.lastIndexOf <regex>re <int>startPos = -1 : int|;
\item
	\lstinline|string.remove <regex>re : string|;
\item 
	\lstinline|string.replace <regex>re <string>after : string|;
\item
	\lstinline|string.split <regex>re <bool>keepEmptyParts = true : list|.
\item
	\lstinline|list.filter <regex>re : list|;
\item
	\lstinline|list.indexOf <regex>re <int>start : int|;
\item
	\lstinline|list.lastIndexOf <regex>re <int>start : int|;
\end{icItems}

Примеры использования выше перечисленных методов, представлены на листинге \ref{regexplikearg}.

\begin{lstlisting}[caption=Регулярные выражения в качестве аргумента, label=regexplikearg]
@str = "Hello world, collaborators!";

@str.count //\wo//;       `` 5
@str.indexOf //\w{6}//;   `` 13
@str.lastIndexOf //l+o//; `` 2
@str.remove //\w{2}o//;   `` "He world, collrrs!"
@str.split //,?\s//;      `` ["He" "world" "collrrs!"]

@fonts = ["Arial" "Helvetica" "Times" "Courier"];

@fonts.filter //^[ac]//i;    `` ["Arial" "Courier"]
@fonts.indexOf //e.//;       `` 1
@fonts.indexOf //e.// 2;     `` 2
@fonts.lastIndexOf //e.//;   `` 3
@fonts.lastIndexOf //e.// 2; `` 2
\end{lstlisting}

\subsubsection{\lstinline|string.count <regex>re : int|}

Считает количество подстрок подходящие по шаблону \code{re}.

\subsubsection{\lstinline|string.indexOf <regex>re <int>startPos = -1 : int|}

Возвращает индекс первой подстроки подходящей по шаблону \code{re}, ища вперёд с позицией \code{startPos}; если такая подстрока не нашлось, возвращает -1.

\subsubsection{\lstinline|string.lastIndexOf <regex>re <int>startPos = -1 : int|}

Возвращает индекс первой подстроки подходящей по шаблону \code{re}, ища назад с позицией \code{startPos}; если такая подстрока не нашлось, возвращает -1.

\subsubsection{\lstinline|string.remove <regex>re : string|}

Удаляет из строки все фрагменты подходящие по шаблону \code{re}.

\subsubsection{\lstinline|string.replace <regex>re <string>after : string|}

Заменяет каждый фрагмент, подходящий по шаблону \code{re}, строкой \code{after}.

\subsubsection{\lstinline|string.split <regex>re <bool>keepEmptyParts = true : list|}

Разрывает строку на подстроки при каждой встречи подстроки, подходящей по шаблону \code{re} и собирает список этих строк; если \code{keepEmptyParts == false} то пустые строки пропускаются.

\subsubsection{\lstinline|list.filter <regex>re : list|}

Возвращает новый список строк, содержащий только строки этого списка, подходящих по регулярней выражении \code{re}.

\subsubsection{\lstinline|list.indexOf <regex>re <int>start = 0 : int|}

Возвращает индекс первой строки, подходящей по регулярней выражении \code{re}, ища вперёд с позицией \code{start}, если такой строке не найдено возвращает -1.

\subsubsection{\lstinline|list.lastIndexOf <regex>re <int>start = -1 : int|}

Возвращает индекс первой строки, подходящей по регулярней выражении \code{re}, ища назад с позицией \code{start}, если такой строке не найдено возвращает -1.

% \subsubsection{}

\newpage
\section{Прогресс}

{\color{red}Материал для продвинутых пользователей.}

\begin{icEnum}
	\item + Введение
	\item + Базовый синтаксис
	\item + Переменные
	\item + Типы данных
	\item + Литералы
	\item + Операторы
	\item + Условные операторы
	\item + Циклы
	\item + Интеграция с Javascript
	\item + Функции
	\item + Строки
	\item + Списки
	\item + Множества
	\item + Веб-элементы (симуляция мышки и клавиатуры) webelments
	\item + Обмен данных в веб-странице (конкретные примеры) dataexchange
	\item - DSV / CSV / TSV
	\item - Преобразование типов
\end{icEnum}

{\color{red}далее материал для программистов, дополнительные возможности, просьба не читать далее материал если нету желание или необходимость.}

\begin{icEnumResume}
	\item - Дополнительные возможности tabs files make
	\item - Регулярные выражения regex
	\item - Механизм состояний
	\item - Базы данных (только SQLite в первой версии)
	\item - Обработка ошибок emiter, emit, slot
	\item - Crossfire.js
\end{icEnumResume}

\end{document}
