\documentclass[a4paper, 14pt]{extarticle}

\usepackage[top=2.5cm, bottom=1.5cm, left=2cm, right=1cm]{geometry}
\usepackage{fancyvrb}
\fvset{tabsize=2}
\usepackage{polyglossia}
\setmainlanguage{russian} 
\setotherlanguage{english}
\usepackage{setspace}

\usepackage{longtable}
\usepackage{ragged2e}
\setcounter{tocdepth}{2}
  
\setmainfont{Liberation Serif}
\newfontfamily\cyrillicfont{Liberation Serif}
\setmonofont{Liberation Mono}
\setsansfont{Liberation Sans}
\newfontfamily\cyrillicfontmono{Liberation Mono}
\newfontfamily\cyrillicfontsans{Liberation Sans}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage[singlelinecheck=false]{caption}
\usepackage{listings, lstautogobble}
\usepackage{color}
\usepackage[table]{xcolor}

\usepackage{caption}
\DeclareCaptionFont{black}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{codeheaderbg}
	{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]
	{format=listing,labelfont=black,textfont=black}

\usepackage{enumitem}

\lstdefinestyle{framed}
{
     frame=none,         
     belowcaptionskip=2pt,
     xleftmargin=8pt,
     framexleftmargin=7pt,
     framexrightmargin=5pt,
     framextopmargin=10pt,
     framexbottommargin=5pt,
     framesep=0pt,
     rulesep=0pt,
     texcl=true
}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\definecolor{codebg}{rgb}{0.97, 0.97, 0.97}
\definecolor{codeheaderbg}{rgb}{0.90, 0.90, 0.90}
\definecolor{orange}{rgb}{0.8, 0.4, 0.0}
\definecolor{bluemarin}{RGB}{12, 134, 145}
\definecolor{grey}{rgb}{0.5, 0.5, 0.5}
\definecolor{function}{RGB}{11, 145, 89}
\definecolor{blue2}{RGB}{15, 92, 198}

\lstdefinelanguage{icL}{
	keywords={if, else, for, filter, range, exists, while, do, any,emit, emiter, slot, @, \#},
	keywordstyle=\color{blue2},
	keywords=[2]{bool, int, double, string, list, element, set, item, object, function, void, request},
	keywordstyle=[2]\color{bluemarin},
	classoffset=3,
	morekeywords={_log, _define, _tab, _dom, _define, _import, true, false, _numbers},
	keywordstyle=\color{orange},
	classoffset=4,
	morekeywords={info, warm, error, signal, at, query, queryAll, null, prepend, append, insert, merge, popFront, popBack, remove, removeOnce, removeAll, get, indexOf, lastIndexOf, join, sumUp, max, min, logicAnd, logicOr, length, text, html, width, height, click, scrollTo, sendKeys, isValid, copy, add, filter, query, queryAll, visible, clickable, next, prev, parent, child, closest, addClass, hasClass, removeClass, all, functions, none, run, close, process, setProcess, restoreProcess, product, sum, min, max, empty, out},
	keywordstyle=\color{function},
	classoffset=5,
	morekeywords={UnrealCast, StringParse, EmptyList, MultipleValues, NullElement, NotVisible,  WrongName, OutOfBounds, OutOfScreen, FileNotFound},
	classoffset=0,
	identifierstyle=\color{black},
	sensitive=true,
	comment=[l]{``},
	morecomment=[s]{```}{```},
	morecomment=[s]{`c}{t`},
	commentstyle=\color{grey},
	stringstyle=\color{purple},
	morestring=[b]"
}

\usepackage{chngcntr}

\newenvironment{icItems}
	{ \begin{itemize} [noitemsep,nolistsep] }
	{ \end{itemize} } 

\newenvironment{icEnumResume}
	{ \begin{enumerate}[noitemsep,nolistsep,resume] }
	{ \end{enumerate} } 

\newenvironment{icEnum}
	{ \begin{enumerate}[noitemsep,nolistsep] }
	{ \end{enumerate} } 

\begin{document}

%\renewcommand{\rmdefault}{ftm}
\counterwithin{lstlisting}{section}
\counterwithin{table}{section}

\renewcommand{\lstlistingname}{Листинг}

\setlength\abovecaptionskip{2pt}
\setlength\belowcaptionskip{1pt}

\lstset{
	language=icL,
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	showtabs=false,
	numbers=left,
	stepnumber=1,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=true,
	backgroundcolor=\color{codebg},
	style=framed,
	lineskip=0pt,
	aboveskip=0pt,
	autogobble=true
}
	
\setlength{\LTleft}{0pt}
\onehalfspacing

\newcommand{\greycell}[1]{\cellcolor{lightgray}\centering\textbf{#1}}

\newcommand{\code}[1]{\lstinline`#1`}

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\tabletwo}[7]{
	\begin{longtable}[h]{p{#1}}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\stabletwo}[7]{
	\begin{longtable}[h]{|p{#1}|p{#2}|}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\tablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\stablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\tableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	#2
	#3
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	#3
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#6
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\stableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	#2
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	#2
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#5
	\end{longtable}
}

% Содержимое докимента
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Стандарт языка описания сценариев icL v1.0.0 Черновик}
\author{Лелицак Василе}

\maketitle

\newpage
\renewcommand{\contentsname}{\textsf{Оглавление}}
\tableofcontents
	
\newpage

\section{Введение}	
	
\indent \textbf{icL} - \textbf{язык описания сценариев}, оптимизирован под описания сценариев тестирования веб-приложений.
	
\subsection{Читатели}
	
Этот документ предназначен для всех тех людей, которые ищут отравную точку, откуда можно начать изучать язык icL. Также данный документ используется при разработке интерпретатора, поведения командного процессора во всех ситуациях неописанных в данном документе считается неопределённой.
	
\subsection{Что вы должны уметь}
	
Прежде чем выступать к изучению этого языка, вам желательно иметь базовое представление о компьютерном программировании.
	
\subsection{Обзор языка icL}
	
icL - язык сценариев тестирования веб-приложений. Его разработка началась в году, и первый выпуск планируется к 2020 году. В настоящий момент он находится в активной разработке.
	
icL - \textbf{язык с С-подобным синтаксисом}, который использует статическую типизацию. В icL нельзя определить собственные типы данных, так как он разработан не для программистов, знания получены в школе на уроках информатики должны быть достаточны. Язык icL поддерживает только одну парадигму программирования - процедурная. При необходимости обработать данные, можно использовать экспорт/импорт в/из cvs и базы данных.
	
\subsection{Пример кода}

В icL точка входа в программе - начало файла, программа \textit{Hello world!} иллюстрирована на листинге \ref{example0}.
	
\begin{lstlisting}[caption=Пример, label=example0]
`` comment example
_log.info "Hello world";
\end{lstlisting}
  
\subsection{Изучение icL}
	
Самое важное при изучении icL - это сосредоточиться на идеях и не потеряться в технических деталях его реализации.
	
\subsection{Области применения icL}
	
Язык icL является частью \textbf{программы icL}, с его помощью можно управлять браузером, а именно:
\begin{icItems}
	\item открыть вкладку;
	\item закрыть вкладку;
	\item перейти на веб-страницу;
	\item симулировать события клавиатуры и мышке;
	\item взаимодействовать с веб-страницей;
	\item выполнить код на языке javascript;
	\item управлять веб-страницей;
	\item обменять информацию с веб-страничкой;
	\item сделать screenshot;
	\item сохранить страницу в формате pdf;
	\item управлять памятью;
	\item экспортировать данные в csv файле;
	\item импортировать данные из csv файл;
	\item выполнить запросы на языке SQL.
\end{icItems}
	
\subsection{Начало работы}
	
Чтобы начать работать достаточно установить и запустить программу icL.
	
\newpage
\section{Базовый синтаксис}
	
icL достаточно прост в освоении, вставите код с листинга \ref{first} в icL и выполняете его. Первую программу можно уже сохранить в файле с расширением icl.
	
\begin{lstlisting}[caption=Первая программа, label=first]
_log.info "Test!";
\end{lstlisting}
	
В консоль можем увидеть следующий \textbf{вывод программы}:
	
\begin{lstlisting}[numbers=none]
Test!
\end{lstlisting}
	
\subsection{Импорт в icL}
	
Все \textbf{стандартные библиотеки} встроены в языке, но можно написать импортировать \textbf{пользовательские}, с помощью:

\begin{icItems}
	\item \lstinline`_import.none "path/to/file.iclib"` - выполнить код, который содержатся в файле, ничего не импортировать.
	\item \lstinline`_import.functions "path/to/file.iclib"` - выполнить код и импортировать функций; {\color{red}Важно:} импортированные функций не должны использовать глобальные переменные.
	\item \lstinline`_import.all "path/to/file.iclib"` -  выполнить код, импортировать функций и глобальные переменные;
	\item \lstinline`_import.run "path/to/file.iclib"` - выполнить код в текущем контексте, все функции и глобальные переменные импортируется и экспортируется;
\end{icItems}
	
\subsection{Токены в icL}
	
Программа на icL состоит из различных \textbf{токенов} (литералов, семантических конструкциях), а токен может являться ключевым словом, идентификатором, константной, строковым литералом, либо символом. Например следующая команда состоит из четырёх токенов: \lstinline`_log.info "Hello world!";`
	
Отдельными токенами являются:

\begin{icItems}
	\item \lstinline`_log` - идентификатор объекта;
	\item \lstinline`.info` - идентификатор метода;
	\item \lstinline`"Hello world!"` - строковый литерал;
	\item \lstinline`;` - разделитель, конец команды.
\end{icItems}
	
\subsection{Комментарии}
	
\textbf{Комментарии} - это вспомогательный текст, который помогает понимать написанных сценариях, они полностью игнорируется командного процессора. 
	
\textbf{Комментарии в линии} (\textit{inline}) являются строковым литералом ограниченным специальными кавычками \texttt{`}, как показано на листинге \ref{inlinecomment}.
	
\begin{lstlisting}[caption=Комментарий в линии,label=inlinecomment]
No comment `comment` no comment
\end{lstlisting}
	
\textbf{Одиночный комментарий} записывается с использованием символов \texttt{``} в начале, смотрите листинг \ref{linecomment}.
	
\begin{lstlisting}[caption=Одиночный комментарий,label=linecomment]
No comment `` comment
\end{lstlisting}
	
\textbf{Многострочный комментарий} начинается и заканчивается с \texttt{```}, пример многострочного комментария приведён на листинге \ref{multilinecomment}.
	
\begin{lstlisting}[caption=Многострочный комментарий,label=multilinecomment]
No comment
``` comment 1
	comment 2
	comment 3
``` No comment
\end{lstlisting}
	
\subsection{Идентификторы}
	
\textbf{Идентификатор} в icL - это имя, используемое для идентификации переменной, функций, методов и свойств. Идентификатор начинается с символов обозначающий его предназначение(\lstinline`@`, \lstinline`#`, \lstinline`!`, \lstinline`_`, \lstinline`.` или \lstinline`'`), за которым следует от 2 до 32 букв(английского или национального алфавита) и цифр (от 0 до 9).
	
icL - чувствительный к регистру язык. Таким образом \textit{@var} и \textit{@Var} являются двумя разными идентификаторами. Вот несколько примеров допустимых идентификаторов:
	
\begin{lstlisting}[numbers=none]
#loop		_tab		.Append		'Length	_dom	@ii 	@VAR
@variable	!sumPoints	#global		.Merge	.Get	#01		!SIN
\end{lstlisting}
	
\subsection{Ключевые слова}
	
В icL \textbf{ключевые слова} не зарезервированные. Их всего 11: \lstinline`if`, \lstinline`for`, \lstinline`filter`, \lstinline`range`, \lstinline`exists`, \lstinline`while`, \lstinline`do`, \lstinline`any`, \lstinline`emit`, \lstinline`emiter` и \lstinline`slot`. В данном документе они выделены синим цветом.
  
\subsection{Пробельные символы и разделители}
	
\textbf{Пробельный символ} (\textit{whitespace}) - этот термин используется в icL для описания пробелов, символов табуляции, символов новой строкой и комментариев. Пробельные символы не обязательные, они используются для улучшения читабельности кода. На листинге \ref{unreadable} показан пример кода без пробельных символов, а на листинге \ref{readable} с пробельными символами.
	
\begin{lstlisting}[caption=Koд без пробельных символов,label=unreadable]
if(_tab.get"mai.ru"){(_dom.query"button").Click;}else{_log.error"The site mai.ru is unaviable";};
\end{lstlisting}
	
\begin{lstlisting}[caption=Koд с пробельных символов,label=readable]
`` the begin of program

`` try to go to mai.ru
if (_tab.get "mai.ru") {
	`` site loaded successfull
	`` click the button
	(_dom.query "button").Click;
}
else {
	`` try again later
	`` now log the error
	_log.error "The site mai.ru is unaviable";
};

`` end of the program
\end{lstlisting}
	
В icL присутствует только один разделитель - \textbf{разделитель команд} \lstinline`;`. Команда - это набор токенов, распределенных в определённом порядке и характеризующее действие. Примеры команд: открыть сайт - \lstinline`_tab.get "URL"`, закрыть вкладку - \lstinline`_tab.close`.
	
При описании последовательности действий, их надо разделить, например последовательность вышеперечисленных команд описывается так:

\begin{lstlisting}[numbers=none]
_tab.get "URL"; _tab.close
\end{lstlisting} 
	
Таким образом из команд собираем сценарии. Перед закрывающих скобок ставить разделитель команд опционально.
	
\subsubsection{Дополнительные сведение}
	
Если у вас нет знании в программировании перейдите, пожалуйста, на третью главу.
	
icL отсутствуют разделители между значениями в списке. Примеры:

\begin{icItems}
	\item Инициализация списка в С++:
\begin{lstlisting}[numbers=none, language=C++]
std::list<std::string> list = {"one", "two", "three"};
\end{lstlisting}
	Инициализация списка в icL:
\begin{lstlisting}[numbers=none]
@list = ["one" "two" "three"];
\end{lstlisting}
	\item Функция в С++:
\begin{lstlisting}[numbers=none, language=C++]
int sum (int number1, int number2) { return number1 + number2; };
\end{lstlisting}
	Функция в icL:
\begin{lstlisting}[numbers=none]
!sum = <int>number1 <int>number2 : int { @ = number1 + number2 };
\end{lstlisting}
	\item Вызов функций в С++:
\begin{lstlisting}[numbers=none, language=C++]
int s = sum (100, 200);
\end{lstlisting}
	Вызов функций в icL:
\begin{lstlisting}[numbers=none]
@sum = !sum 100 200;
\end{lstlisting}
	\item Код на С++:
\begin{lstlisting}[numbers=none, language=C++]
sum (100 + 50, 200);
\end{lstlisting}
	Эквивалент на icL:
\begin{lstlisting}[numbers=none]
!sum (100 + 50) 200;
\end{lstlisting}
\end{icItems}

\newpage
\section{Переменные}  
	
\textbf{Переменная} - название области хранения, который могут манипулировать сценария. Каждая переменная в icL имеет область видимость (фрагмент кода где можно её использовать) и тип, который определяет размер и способ размещения памяти переменной; диапазон значений можно применить к переменной.
	
Имя переменной является идентификатором, начинающийся с \lstinline`@` или {\color{blue2}\lstinline`#`}.
\textbf{Основные типы} переменных показаны в таблице \ref{variablestypes}.

\stabletwo{2cm}{15.1cm}{variablestypes}{Типы переменных}%
{Тип}{Описание}%
{ 
	bool & Логическое значения, имеет в состояние: истинно или лож. \\ \hline
	int & Целое число, позволяет хранить значения от -2.147.483.648 до 2.147.483.647. \\ \hline
	double & Дробное число, позволяет хранить вещественные числа. \\
}
	
icL также присутствуют и \textbf{сложные типы} переменных, такие как строки, списки, множества, объекты, которые мы посмотрим в полеживающих главах. В этой главе изучаем только основные типы.
	
\subsection{Объявления и инициализация переменных}
	
\textbf{Объявления и инициализация} переменных, также операция \textit{присваивание} в icL неотличимы, и имеют общий вид \lstinline`a = b`, где \lstinline`a` новая или существующая переменная, а \lstinline`b` - значение. В тех случаев когда переменная \textbf{встречается первый раз}, мы её объявляем и инициализируем. В противном случае мы присваиваем ей значение.
	
На листинге \ref{initexample} показаны несколько пример объявлений и инициализации переменных, обратите внимание что дробные числа пишется через точку, а не через запятую как принято в Европе и Российском Федераций.
  	
\begin{lstlisting}[caption=Пример объявлений и инициализации переменных,label=initexample]
@bool = false;
@catched = true;
@int = 234;
@double = 23.4;
#pi = 3.14;
#negative = -100.0;
\end{lstlisting}

\subsection{Локальные переменные}
	
\textbf{Локальные переменные} имею узкую область видимость, ограниченные фигурными скобками которые их охватывает, и только после их объявлений. 
	
{\bf Идентификаторы} локальных переменных начинается с символом \lstinline`@`. 
	
На листинге \ref{localvars} показана область видимость переменной \lstinline`@var`, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test6` - она не видна, когда в точках объявления переменных \lstinline`@test3`, \lstinline`@test4` и \lstinline`@test5` - да.
\begin{lstlisting}[caption=Область видимости локальных перемен, label=localvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var; 
	`` initialization
	@var = 0;
	`` ok
	@test3 = @var;
	if (@) {
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var; 
}
`` error
@test6 = @var; 
\end{lstlisting}

\subsection{Глобальные переменные}

\textbf{Глобальные переменные} имеют самую широкую область видимости, их видны из любой точке программы после их инициализации. Использовать глобальные переменные не рекомендуется, так как они могут привести к серьезных ошибок. 
	
{\bf Идентификаторы} глобальных переменных начинается с символом {\color{blue2}\lstinline`#`}. Локальные переменные с одинаковым названием могут быть несколько, когда глобальные - нет. Идентификатор глобальной переменной - уникальный.
	
Как указано на листинге \ref{globalvars}, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test3` переменная \lstinline`@var` не видна, когда в точках объявления переменных \lstinline`@test4`, \lstinline`@test5` и \lstinline`@test6` - да.
	
\begin{lstlisting}[caption=Область видимости глобальных перемен, label=globalvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var; 
	if (@) {
		`` error
		@test3 = @var;
		`` initialization
		@var = 0;
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var; 
}
`` ok
@test6 = @var;
\end{lstlisting}

\subsection{Левые и правые значения в icL}

В icL присутствуют 3 типа значении:
	
\begin{icEnum}
	\item левые значения {\it lvalue} - переменные;
	\item правые значения {\it rvalue} - переменные и константы;
	\item javascript значения {\it jsvalue} - их будем рассматривать позже.
\end{icEnum}
	
Левые значения могут находиться с обеих сторон знака {\it присваивание}, когда правые - только справа. Примеры правильно и неправильно кода иллюстрированы на листинге \ref{rlvalues};
	
\begin{lstlisting}[caption=Левые и правые значения, label=rlvalues]
@a1 = @a2; @a3 = 123; `` ok
123 = @a1; 125 = 456; `` error 
\end{lstlisting}

\subsection{Выводы}

{\bf Работа с переменными в icL} - максимально проста, но продвинутых пользователях без знания в программировании рекомендуется не использовать глобальные переменные. Для написания сценариев средней и низкой сложности, локальные переменные лучше подходят. 

\section{Типы данных}

В языке описания сценариев icL, типы данных выполняют очень важную роль, они определяют как данные и будут храниться, обработаться в процессе выполнения программы. Классификация типов данных представлена в таблице \ref{datatypeclasses}.
	
\stabletwo{3.5cm}{13.6cm}
{datatypeclasses}{Категории типов данных}
{Категория}{Описание}
{
	Базовые & Типы данных описанных в предыдущем главе: \code{bool} - логический, \code{int} - целое - числа, \code{double} - дробные числа. \\ \hline
	Сложные & Типы данные содержащие несколько значений в контейнерах, примеры таких данных: строки, списки, множество. \\ \hline
	Системные & Типы данных которых нельзя создать и хранить в пользовательских переменных, но доступ к ними можно получить через системные (предопределённых) переменных, примеры таких данных: браузер, вкладка, история браузера, окно. \\ \hline
	Тип \code{void} & Тип данных обозначающий отсутствия данных.
}
	
\subsection{Основные типы данных}

{\bf Основные типы данных} участвуют в логических и арифметических операциях языка icL. Логическими операциями являются конъюнкция, дизъюнкция, исключающий или, эквиваленция и инверсия. Арифметическими операциями являются сложения, вычитания, умножения, деления, извлечения корня и возведения в степень.
	
\subsection{Сложные типы данных}

{\bf Сложные типы данных} специализированные под хранения больших массивов данных. Строка позволяет хранить более двух миллиардов символов. Список позволяет хранить более двух миллиардов строк. А множество позволяет хранить большой объём данных ограничен только оперативной памяти. Объект позволяет инкапсулировать данные разного рода по одном именем. Элемент позволяет хранить ссылку на один или несколько HTML-тэгов.

\subsection{Системные типы данных}

{\bf Системные типы данных} позволяют взаимодействовать с веб-страницей и браузером. Подробную информацию можно найти в главах \ref{webelments} и \ref{dataexchange}.
	
\subsection{Тип данных {\color{bluemarin} void}}

{\bf Тип данных \code{void}} означает отсутствия информации, он используется в самых различных целях:

\begin{icItems}
	\item указать то что функция ничего не возвращает;
	\item указать на то что в процессе работы функций произошла ошибка;
	\item выбрать источник данных;
	\item фильтровать данные;
	\item удалить переменных состояния;
	\item и другие.
\end{icItems}

\newpage
\section{Литералы}
	
Константные значения, которые присутствуют в скрипте в виде части исходного кода, называются {\bf литералами}.

Литералы могут быть любыми из следующих типов:

\begin{icItems}
	\item логическое значение - \code{bool};
	\item целое число - \code{int};
	\item дробное число - \code{double};
	\item строка - \code{string};
	\item список - \code{list};
	\item объект - \code{object};
	\item множество - \code{set}.
\end{icItems}

\subsubsection{Логические значения}

Для представления {\bf логических значения} используется следующее литералы:
\begin{icItems}
	\item \code{true} - логическое единица, истинно;
	\item \code{false} - логической ноль, лож.
\end{icItems}

\subsubsection{Целые числа}

Для представления {\bf целых чисел} используется последовательность цифр, перед которым может присутствовать минус. Между минусом и последовательности цифр разделители должны отсутствовать, иначе минус будет интерпретирован как оператор.
	
\noindent Примеры:
\begin{lstlisting}[numbers=none]
23; -23; - 23; +23 + 3; 12 + -34; 15 - 24; 89--56; 2-3; `` ok
23-; 23+; -2А; 3f5; 23f; 23l; 12u; 89i; 2w1; 1q1; rt2; `` error 
\end{lstlisting}
	
\subsubsection{Дробные числа}

{\bf Дробный литерал} состоит из двух частей: целая и дробная. Они разделяются точкой. Каждая составная часть является целом числом. Дробная часть не может быть отрицательной.
	
\noindent Примеры:
\begin{lstlisting}[numbers=none]
23.233452; 29229992.2391; 100.0; -23.29199; -0.23; -0.45 - 1000.5; `` ok
23.-4; 3а.34; 23-.44; 34.+23; -25.f; -23.5f; -w.45; -2.4e10; -2.E2; `` error 
\end{lstlisting}

\subsubsection{Строки}

{\bf Строковым литералом} является последовательность символов, ограниченное с обеих сторон кавычками \lstinline`"`. Чтобы добавить \lstinline`"` используется \lstinline`\"`, символ табуляции - \lstinline`\t`, символ {\it новая строка} - \lstinline`\n`, символ {\it возврат на шаг} - \lstinline`\b`, \textbackslash \ - \lstinline`\\`.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
"Hello \"to\" you!"; "Line1\nLine2"; "Tag1\n\bTag2\n\b"; "text"; "\\ \\ \n \\ \\";
\end{lstlisting}

\subsubsection{Списки}

{\bf Литералом списка} является последовательность строк, ограниченное квадратными скобками.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
@fruits = ["Apple" "Mango" "Banana" "Lime" "Lemon" "Olive"];
@vegetables = ["Cress" "Mustard" "Guar" "Soybean" "Leek" "Ahipa"];
\end{lstlisting}

\subsubsection{Объекты}

{\bf Объектом} является объединение нескольких переменных под общем именем, переменная объявлена внутри объекта называется {\it поле}. Литерал {\it поле} имеет следующий синтаксис \lstinline`<value>name`, где  {\it value} - значение и {\it name} - название. В icL неинициализируемые поля, как и неинициализируемые переменные, нельзя объявить. 
	
\noindent Примеры:
\begin{lstlisting}[numbers=none]
@quotation = [<"author">author <"text">text];
@child = [<4>age <true>hasBrothers <true>hasParents];
@file = [<false>isEmpty <25220>size <true>readOnly];
\end{lstlisting}

\subsubsection{Множества}

Только {\bf пустое множество} можно описать литералом, литерал схож с литералом объекта, только вместо значения указывается тип значения.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
@quotations = [<string>author <string>text];
@children = [<int>age <bool>hasBrothers <bool>hasParents];
@files = [<bool>isEmpty <int>size <bool>readOnly];
\end{lstlisting}

\newpage
\section{Операторы}

{\bf Оператор} - это токен, который предписывает выполнение определённой манипуляции данных. Встроенных операторов в icL очень много, по этому будет их разбирать по типу данных, в следующем порядке:
	
\begin{icEnum}
	\item \code{bool};
	\item \code{int};
	\item \code{double};
	\item \code{string};
	\item \code{list};
	\item \code{object};
	\item \code{set};
	\item \code{void}.
\end{icEnum}

Операторы имеют ранг, операторы имеющие наивысший ранг выполняются первыми, а имеющие наименьший ранг - последними. Операторы имеющие правая ассоциативность выполняются раньше чем операторы имеющие левое ассоциативность, они отмечены плюсом справа от ранга, например 7$^+$.
	
{\bf Оператор пристраивания} имеет ранг 0 и правая ассоциативность;

\subsection{\color{bluemarin}bool}

Если у вас отсутствуют знания по алгебры логике, пожалуйста прочтите любую книгу по основы данной науке.

Для типа данных \code{bool}, доступны:
	
\begin{icItems}
	\item операции алгебры логике (имеющие ранг 2):
	\begin{icItems}
		\item конъюнкция - \lstinline`bool & bool : bool`;
		\item дизъюнкция - \lstinline`bool | bool : bool`;
		\item эквивалентность - \lstinline`bool ~ bool : bool`;
		\item исключающий или - \lstinline`bool ^ bool : bool`;
		\item инверсия (имеет ранг 7$^+$) - \lstinline`! bool : bool`;
	\end{icItems}

	\item операций сравнения (имеющие ранг 3):
	\begin{icItems}
		\item равно - \lstinline`bool == bool : bool`;
		\item не равно - \lstinline`bool != bool : bool`;
	\end{icItems}
\end{icItems}

Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{boolopex}.
	
\begin{lstlisting}[caption=Примеры использования операторов над данными типа bool, label=boolopex]
_log.out "true & false = " (true & false);     `` true \& false = false
_log.out "false | true =  " (false | true);     `` false | true = true
_log.out "true ~ false = " (true ~ false);     `` true \textasciitilde\ false = false
_log.out "false ^ true = " (false ^ true);     `` false \textasciicircum\ true = true`

_log.out "!true = " !true;                     `` !true = false
_log.out "!false = " !false;                   `` !false = true

_log.out "true == false = " (true == false);   `` true == false = false
_log.out "false != true = " (false != true);   `` false != true = true
\end{lstlisting}

\subsubsection{\lstinline`<bool>a & <bool>b : bool`}
Оператор принимает логическую операцию "конъюнкция" над переменными a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{conjtable}.
	
\begin{table}[htb]
	\caption{Таблица истинности конъюнкции}
	\label{conjtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a}     & \code{b}     & \code{a \& b} \\ \hline
		\code{false} & \code{false} & \code{false}  \\ \hline
		\code{false} & \code{true}  & \code{false}  \\ \hline
		\code{true}  & \code{false} & \code{false}  \\ \hline
		\code{true}  & \code{true}  & \code{true}   \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a | <bool>b : bool`}
Оператор принимает логическую операцию "дизъюнкция" над переменными a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{distable}.
	
\begin{table}[htb]
	\caption{Таблица истинности дизъюнкции}
	\label{distable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a}     & \code{b}     & \code{a | b} \\ \hline
		\code{false} & \code{false} & \code{false} \\ \hline
		\code{false} & \code{true}  & \code{true}  \\ \hline
		\code{true}  & \code{false} & \code{true}  \\ \hline
		\code{true}  & \code{true}  & \code{true}  \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a ~ <bool>b : bool`}
	Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logeqtable}.
	
\begin{table}[htb]
	\caption{Таблица истинности эквивалентности}
	\label{logeqtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a}     & \code{b}     & \code{a \~ b} \\ \hline
		\code{false} & \code{false} & \code{true}   \\ \hline
		\code{false} & \code{true}  & \code{false}  \\ \hline
		\code{true}  & \code{false} & \code{false}  \\ \hline
		\code{true}  & \code{true}  & \code{true}   \\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline`<bool>a ^ <bool>b : bool`}
Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logdifftable}.

\begin{table}[htb]
	\caption{Таблица истинности исключающего или}
	\label{logdifftable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a}     & \code{b}     & \code{a \^ b} \\ \hline
		\code{false} & \code{false} & \code{false}  \\ \hline
		\code{false} & \code{true}  & \code{true}   \\ \hline
		\code{true}  & \code{false} & \code{true}   \\ \hline
		\code{true}  & \code{true}  & \code{false}  \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`! <bool>a : bool`}
Оператор принимает логическую операцию "инверсия" над переменной a. Зависимость результата от исходных данных иллюстрирована в таблице \ref{invtable}.

\begin{table}[htb]
	\caption{Таблица истинности инверсии}
	\label{invtable}
	\begin{tabular}{|c|c|}
		\hline
		\code{a}     & \code{!a}    \\ \hline
		\code{false} & \code{true}  \\ \hline
		\code{true}  & \code{false} \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a == <bool>b : bool`}
Возвращает \code{true} если a равно b, иначе \code{false}.

\subsubsection{\lstinline`<bool>a != <bool>b : bool`}
Возвращает \code{true} если a равно b, иначе \code{false}.

\subsection{{\color{bluemarin}int} и {\color{bluemarin}double}}

Для чисел доступны операций:
\begin{icItems}
	\item 3-ого ранга:
		\begin{icItems}
			\item равно \lstinline`int == int : bool` и \lstinline`double == double : bool`
			\item не равно \lstinline`int != int : bool` и \lstinline`double != double : bool`
			\item больше \lstinline`int >> int : bool` и \lstinline`double >> double : bool`
			\item больше или равно \lstinline`int >= int : bool` и \lstinline`double >= double : bool`
			\item меньше \lstinline`int << int : bool` и \lstinline`double << double : bool`
			\item меньше или равно \lstinline`int <= int : bool` и \lstinline`double <= double : bool`
		\end{icItems}
	\item 4-ого ранга:
		\begin{icItems}
			\item сложение \lstinline`int + int : int` и \lstinline`double + double : double`;
			\item вычитание \lstinline`int -    int : int` и \lstinline`double -    double : double`.
		\end{icItems}
	\item 5-ого ранга:
		\begin{icItems}
			\item умножение \lstinline`int * int : int` и \lstinline`double * double : double`;
			\item деление \lstinline`int / int : int` и \lstinline`double / double : double`;
			\item остаток от деления целых чисел \lstinline`int \ int : int`.
		\end{icItems}
	\item 6$^+$-ого ранга:
		\begin{icItems}
			\item возведения в квадрат \lstinline`int** : int` и \lstinline`double** : double`;
			\item возведения в степень \lstinline`int ** int : int` и \lstinline`double ** double : double`;
			\item извлечения квадратного корня \lstinline`/'int : int` и \lstinline`/'double : double`;
			\item извлечения корня \lstinline`int/'int : int` и \lstinline`double/'double : double`.
		\end{icItems}
	\item 7$^+$-ого ранга:
		\begin{icItems}
			\item инверсия знака \lstinline`-int : int` и \lstinline`-double : double`;
			\item абсолютное значение \lstinline`+int : int` и \lstinline`+double : double`.
		\end{icItems}
\end{icItems}

Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{numberopex}.
	
\begin{lstlisting}[caption=Примеры использования операторов над данными типа int и double, label=numberopex]
`` 3rd rank
_log.out "2 == 3 = "		2 == 3;		`` 2 = 3 = false
_log.out "2.5 == 2.5 = "	2.5 == 2.5;	`` 2.5 = 2.5 = true
_log.out "1 != 2 = "		1 != 2;		`` 1 $\neq$ 2 = true
_log.out "2.1 != 2.1 = "	2.1 != 2.1;	`` 2.1 $\neq$ 2.1 = false
_log.out "3 >> 2 = "		3 >> 2;		`` 3 > 2 = true
_log.out "1.1 >> 2.1 = "	1.1 >> 2.1;	`` 1.1 > 2.1 = false
_log.out "5 >= 2 = "		5 >= 2;		`` 5 $\geq$ 2 = true
_log.out "5.1 >= 2 = "		5.1 >= 2;	`` 5.1 $\geq$ 2 = true
_log.out "3 << 9 = "		3 << 9;		`` 3 < 9 = true
_log.out "6.1 << 6.2 = "	6.1 << 6.2;	`` 6.1 < 6.2 = true
_log.out "4 <= 5 = "		4 <= 5;		`` 4 $\leq$ 5 = true
_log.out "5.6 <= 6.5 = "	5.6 <= 6.5;	`` 5.6 $\leq$ 6.5 = true
`` 4th rank
_log.out "2 + 3 = "			2 + 3;		`` 2 + 3 = 5
_log.out "2.1 + 1.1 = "		2.1 + 1.1;	`` 2.1 + 1.1 = 3.2
_log.out "4 - 5 = "			4 - 5;		`` 4 - 5 = -1
_log.out "4.5 - 3.4 = "		4.5 - 3.4;	`` 4.5 - 3.4 = 1.1
`` 5th rank
_log.out "2 * 3 = "			2 * 3;		`` 2 $\cdot$ 3 = 6
_log.out "2.1 * 5.7 = "		2.1 * 5.7;	`` 2.1 $\cdot$ 5.7 = 11.97
_log.out "5 / 7 = "			5 / 7;		`` 5 $\div$ 7 = 0.7142857142857
_log.out "5.0 / 7.1 = "		5.0 / 7.1;	`` 5.0 $\div$ 7.1 = 0.7042253521126
_log.out "45 \ 8 = "		45 \ 8;		`` 45 \textbackslash 8 = 5
`` 6+th rank
_log.out "25** = "			25**;		`` $25^2$ = 625
_log.out "25.1** = "		25.1**;		`` $25.1^2$ = 630,01
_log.out "34 ** 3 = "		34 ** 3;	`` $34^3$ = 39304
_log.out "2.0 ** 1.5 = "	2.0 ** 1.5;	`` $2.0^{1.5}$ = 2.8284271247461
_log.out "/'25 = "			/'25;		`` $\sqrt{25}$ = 5
_log.out "/'125.7 = "		/'125.7;	`` $\sqrt{125.7}$ = 11.211601134539
_log.out "3/'27 = "			3/'27;		`` $\sqrt[3]{27}$ = 3
_log.out "5.0/'125.5 = "	5.0/'125.5;	`` $\sqrt[5.0]{125.5}$ = 2.6286256727378
`` 7+th rank
_log.out "- 35 = "			- 35;		`` - 35 = -35
_log.out "- -56.7 = "		- -56.7;	`` - -56.7 = 56.7
_log.out "+ -100 = "		+ -100;		`` + -100 = 100
_log.out "+ 89.7 = "		+ 89.7;		`` + 89.7 = 89.7
\end{lstlisting}

{\bf Внимание:} несмотря на то что пробелы в icL игнорируются, они влияют на восприятии кода, \code{-23-4} будет восприниматься как \lstinline`(-23) (-4)` а не как \lstinline`(-23) - (4)`. Недоразумение между человеком и машиной решается добавлением пробелов \lstinline`-23  - 4`.

\subsubsection{\lstinline`<int>a == <int>b : bool`}
Возвращает \code{true} если \code{a} и \code{b} имеют одинаковое значение, иначе \code{false}.

\subsubsection{\lstinline`<double>a == <double>b : bool`}
Возвращает \code{true} если \code{a} и \code{b} отличаются довольно мало (например на 10$^{-15}$), иначе \code{false}.

\subsubsection{\lstinline`<int>a != <int>b : bool`}
Возвращает \code{true} если \code{a} и \code{b} не имеют одинаковое значение, иначе \code{false}.

\subsubsection{\lstinline`<double>a != <double>b : bool`}
Возвращает \code{true} если \code{a} и \code{b} отличаются больше чем на уровень погрешности машины, иначе \code{false}.

\subsubsection{\lstinline`<int>a >> <int>b : bool`}
Возвращает \code{true} если целое число \code{a} больше \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<double>a >> <double>b : bool`}
Возвращает \code{true} если дробное число \code{a} больше \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<int>a >= <int>b : bool`}
Возвращает \code{true} если целое число \code{a} больше или равно \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<double>a >= <double>b : bool`}
Возвращает \code{true} если дробное число \code{a} больше или равно \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<int>a << <int>b : bool`}
Возвращает \code{true} если целое число \code{a} меньше \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<double>a << <double>b : bool`}
Возвращает \code{true} если дробное число \code{a} меньше \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<int>a <= <int>b : bool`}
Возвращает \code{true} если целое число \code{a} меньше или равно \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<double>a <= <double>b : bool`}
Возвращает \code{true} если дробное число \code{a} меньше или равно \code{b}, иначе \code{false}.


\subsubsection{\lstinline`<int>a + <int>b : int`}
Возвращает сумму целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a + <double>b : double`}
Возвращает сумму дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a - <int>b : int`}
Возвращает разницу между целыми числами \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a - <double>b : double`}
Возвращает разницу между дробными числами \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a * <int>b : int`}
Возвращает результат умножения целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a * <double>b : double`}
Возвращает результат умножения дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a / <int>b : int`}
Возвращает результат деления целых чисел \code{a} и \code{b}, остаток отбрасывается.

\subsubsection{\lstinline`<double>a / <double>b : double`}
Возвращает результат деления дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a \ <int>b : int`}
Возвращает результат от деления целых чисел \code{a} и \code{b}.


\subsubsection{\lstinline`<int>a ** : int`}
Возвращает квадрат целого числа \code{a} (a$^2$);

\subsubsection{\lstinline`<double>a ** : double`}
Возвращает квадрат дробного числа \code{a} (a$^2$);

\subsubsection{\lstinline`<int>a ** <int>b : int`}
Возвращает результат возведения целого числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`<double>a ** <double>b : double`}
Возвращает результат возведения дробного числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`/' <int>a : int`}
Возвращает корень целого числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`/' <double>a : double`}
Возвращает корень дробного числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`<int>n /' <int>a : int`}
Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<int>n /' <double>a : double`}
Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<double>n /' <double>a : double`}
Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).


\subsubsection{\lstinline`- <int>a : int`}
Возвращает $0-a$;

\subsubsection{\lstinline`- <double>b : double`}
Возвращает $0.0-a$;

\subsubsection{\lstinline`+ <int>a : int`}
Возвращает абсолютное значение целого числа \code{a}.

\subsubsection{\lstinline`+ <double>a : double`}
Возвращает абсолютное значение дробного числа \code{a}.

\subsection{{\color{bluemarin}string} и {\color{bluemarin}list}}

	Для строк и списков доступны операций:
\begin{icItems}
	\item 3-ого ранга:
		\begin{icItems}
		\item равно \lstinline`string == string : bool` и \lstinline`list == list : bool`;
		\item не равно \lstinline`string != string : bool` и \lstinline`list != list : bool`;
		\item содержит \lstinline`list << string : bool` и \lstinline`string << string : bool`;
		\item содержит строку подходящая по шаблону \lstinline`list <* string : bool`.
		\end{icItems}
	\item 4-ого ранга:
		\begin{icItems}
		\item конкатенация \lstinline`string + string : string`;
		\item вставка \lstinline`string + list : list`, \lstinline`list + string : list` и \lstinline`list + list : list`.
		\end{icItems}
	\item 5-ого ранга: шаблонное сравнение \lstinline`string * string : bool`, \lstinline`list * string : bool` и \lstinline`list * list : bool`;
	\item 6$^+$-ого ранга: эквивалентность \lstinline`string ** string : double`.
\end{icItems}

Примеры использование операторов присутствуют на листинге \ref{stringlistopex}.

Чтобы из несколько строк получить список, оператор вставки рекомендуется не использовать, вместо него использовать литерал:
\begin{lstlisting}[numbers=none]
[@str1 @str2 "Const string" (!func) (37.1 : string) (@bool : string) @list.Join]
\end{lstlisting}

\begin{lstlisting}[caption=Примеры использования операторов над данными типа string и list, label=stringlistopex]
"String1" == "String2";					`` false
["a" "b"] == ["a" "b"];					`` true
["a" "b"] == ["b" "a"];					`` true
["a" "b"] << "c";						`` false
"abc" << "c";							`` true
"ab" + "c";								`` "abc"
"ab" + ["c"];							`` ["ac" "c"]
["a" "b"] + "c";						`` ["a" "b" "c"]
["a" "b"] + ["c" "d"];					`` ["a" "b" "c" "d"]
"abc" * "*c";							`` true
["ac" "bc"] * "*c";						`` true
["ac" "bc"] * "a*";						`` false
["ad" "ac" "bd" "cc"] * ["*d" "*c"];	`` true
["ad" "ac" "bc" "cd"] * ["*d" "*c"];	`` false
"Tom is a cat" ** "Tom is not a cat";	`` 0.875
\end{lstlisting}

\subsubsection{\lstinline`<string>s1 == <string>s2 : bool`}
Возвращает \code{true} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \code{false}.
	
\subsubsection{\lstinline`<list>l1 == <list>l2 : bool`}
Возвращает \code{true} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \code{false}.

\subsubsection{\lstinline`<string>s1 != <string>s2 : bool`}
Возвращает \code{false} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \code{true}.

\subsubsection{\lstinline`<list>l1 != <list>l2 : bool`}
Возвращает \code{false} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \code{true}.

\subsubsection{\lstinline`<list>l << <string>str : bool`}
Возвращает \code{true}, если список \code{l} содержит строку \code{str}, иначе \code{false}.

\subsubsection{\lstinline`<string>str << <string>substr : bool`}
Возвращает \code{true}, если строка \code{str} содержит подстроку \code{substr}, иначе \code{false}.

\subsubsection{\lstinline`<list>l <* <string>template : bool`}
Возвращает \code{true}, если список \code{l} содержит хотя бы одна строка, подходящая по шаблону \code{template}, иначе \code{false}.
	
{\bf Шаблон} - это строка содержащая данные и специальный символ \lstinline`*`, где \lstinline`*` означает любая последовательность символов. Рассмотрим шаблонную строку \lstinline`"Have a * day!"`, примеры строк подходящие по шаблону: \lstinline`"Have a nice day!"`, \lstinline`"Have a amazing day!"`. Пример неподходящей строки \lstinline`"Have a good day"` (отсутствует восклицательный знак).

\subsubsection{\lstinline`<string>s1 + <string>s2 : string`}
Возвращает строку содержащую все символы строк \code{s1} и \code{s2}. Полученная строка имеет длину равна суммы длин составляющих.

\subsubsection{\lstinline`<string>str + <list>l : list`}
Возвращает новый список, получен при вставке строке \code{str} в начале списка \code{l}.

\subsubsection{\lstinline`<list>l + <string>str : list`}
Возвращает новый список, получен при вставке строке \code{str} в конце списка \code{l}.

\subsubsection{\lstinline`<list>l1 + <list>l2 : list`}
Возвращает новый список, содержащий все элементы списков \code{l1} и \code{l2}.

\subsubsection{\lstinline`<string>str * <string>template : bool`}
Возвращает \code{true}, если строка \code{str} подходит по шаблону \code{template}, иначе \code{false}.

\subsubsection{\lstinline`<list>l * <string>template : bool`}
Возвращает \code{true} если все строки списка \code{l} подходят по шаблону \code{template}, иначе \code{false}.

\subsubsection{\lstinline`<list>l * <list>templates : bool`}
Возвращает \code{true} если все строки списка \code{l} подходят по соответственному шаблону из списка \code{templates}, иначе \code{false}.

\subsubsection{\lstinline`<string>s1 ** <string>s2 : double`}
Возвращает коэффициент эквивалентности получен при сравнении \code{s1} с \code{s2}.
	
{\bf Эквивалентность} - уровень схожести строк. \lstinline`"Hi! Robert, how do you do?"` относительно \lstinline`"Robert! Hi! How do you do?"` имеет эквивалентность равна единицы. Так как они состоят из одни и те же слова. Но если сравнивать с  \lstinline`"Rich! Hi! How are you?"` оценка снижается до 0,64.

\subsubsection{\lstinline`<list>l1 ** <list>l2 : double`}
Возвращает коэффициент эквивалентности получен при сравнении строк из списка \code{l1} со строками из списка \code{l2}.
Для корректности вычисления, каждая строка должна содержать одно слово.

\subsection{{\color{bluemarin}object} и {\color{bluemarin}set}}

Для строк и списков доступны операций:
\begin{icItems}
	\item 3-ого ранга:
		\begin{icItems}
		\item равно \lstinline`object == object : bool` и \lstinline`set == set : bool`;
		\item не равно \lstinline`object != object : bool` и \lstinline`set != set : bool`;
		\item включение \lstinline`set << object : bool`;
		\item включение шаблона \lstinline`set <* object` и \lstinline`object <* object : bool`.
		\end{icItems}
	\item 4-ого ранга:
		\begin{icItems}
		\item объединение \lstinline`set + set : set`;
		\item симметрическая разность \lstinline`set -   set : set`.
		\end{icItems}
	\item 5-ого ранга:
		\begin{icItems}
		\item разность \lstinline`set \ set : set`;
		\item пересечение \lstinline`set * set : set`.
		\end{icItems}
\end{icItems}

Примеры использование операторов присутствуют на листинге \ref{setobjopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа object и set, label=setobjopex]
`` init
@set1 = [<int>age <string>name];
@set2 = [<int>age <string>name];
@set3 = [<int>age <string>name];

@obj1 = [<24>age <"User1">name];
@obj2 = [<23>age <"User2">name];
@obj3 = [<26>age <"User3">name];
@obj4 = [<24>age <80>length <40>height <1>arc];

@set1.insert @obj1;
@set1.insert @obj2;
@set2.insert @obj3;
@set2.insert @obj2;
@set3.insert @obj2;
@set3.insert @obj1;

`` operators
@set1 == @set2;				`` false
@set1 == @set3;				`` true
@obj1 == @obj2;				`` false
@set2 != @set3;				`` true
@obj2 != @obj3;				`` true
@set1 << @obj2;				`` false
@set1 <* [<23>age];			`` true
@obj4 <* [<24>age <1>arc];	`` true
@set1 + @set2;				`` [@obj1 @obj2 @obj3]
@set1 - @set2;				`` [@obj1 @obj3]
@set1 \ @set2;				`` [@obj1]
@set1 * @set2;				`` [@obj2]
\end{lstlisting}

\subsubsection{\lstinline`<object>obj1 == <object>obj2 : bool`}
Возвращает \code{true} если \code{obj1} и \code{obj2} имеют одни и те же поля, значения полях из первого объекта совпадает с значениям одноимённых полях второго объекта, иначе \code{false}.

\subsubsection{\lstinline`<set>set1 == <set>set2 : bool`}
Возвращает \code{true} если \code{set1} и \code{set2} имеют один и тоже заголовок, всё объекты из первой множестве приличествуют во вторым и наоборот, иначе \code{false}.

\subsubsection{\lstinline`<object>obj1 != <object>obj2 : bool`}
Возвращает \code{true} если один из объектов имеет поле, отсутствующее в другом или значения поле первого отличается от значении одноимённой поле второго объекта, иначе \code{false}. 

\subsubsection{\lstinline`<set>set1 != <set>set2 : bool`}
Возвращает \code{true} если количество объектов во втором объекте отличается от количества объектов в первом или существует объект присутствующий только в одной множестве, иначе \code{false}.

\subsubsection{\lstinline`<set>s << <object>obj : bool`}
Возвращает \code{true}, если множество \code{s} содержит объект \code{obj}, иначе \code{false}.

\subsubsection{\lstinline`<set>s <* <object>subobj : bool`}
Возвращает \code{true}, если множество \code{s} содержит под объект \code{subobj}, иначе \code{false}.

\subsubsection{\lstinline`<object>obj <* <object>subobj : bool`}
Возвращает \code{true} если каждое поле объекта \code{subobj} содержится в объекте \code{obj} и значение одноимённых полях совпадает, иначе \code{false}.

\subsubsection{\lstinline`<set>set1 + <set>set2 : set`}
Возвращает новое множество содержащая все объекты множеств \code{set1} и \code{set2}.

\subsubsection{\lstinline`<set>set1 - <set>set2 : set`}
Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}, и все объекты множестве \code{set2}, отсутствующих в \code{set1}.

\subsubsection{\lstinline`<set>set1 \\ <set>set2 : set`}
Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}.

\subsubsection{\lstinline`<set>set1 * <set>set2 : set`}
Возвращает новое множество содержащая все объекты , которые приличествуют в \code{set1} и \code{set2}.

\subsection{\color{bluemarin}void}
	
Все \code{void} операторы имеют 2-ой ранг. Данные операторы делят данных на 2 типа \code{void} и не \code{void}. Второй тип в дальнейшем будет отмечен как \code{any}, он может быть один из следующих типов: \code{int}, \code{double}, \code{string}, \code{list}, \code{object}, \code{set}, \code{element}.
	
Список \code{void} операторов:

\begin{icItems}
	\item альтернативный выбор \lstinline`void | void : void`, \lstinline`void | any : any`, \lstinline`any | void : any` и \lstinline`any | any : any`;
	
	\item первичный выбор \lstinline`void & void : void`, \lstinline`any & void : void`, \lstinline`void & any : void` и \lstinline`any & any : any`;

	\item вторичный выбор \lstinline`void ~ void : void`, \lstinline`void ~ any : void`, \lstinline`any ~ void : void` и \lstinline`any ~ any : any`;
	
	\item исключающий выбор \lstinline`void ^ void : void`, \lstinline`void ^ any : any`, \lstinline`any ^ void : any` и \lstinline`any ^ any : void`;

	\item коллекционный выбор \lstinline`void % void : void`, \lstinline`void % any : any`, \lstinline`any % void : any`, \lstinline`int % int : int`, \lstinline`double % double : double`, \lstinline`string % string : list`, \lstinline`list % string : list`, \lstinline`object % object : set` и \lstinline`set % object : set`. Ещё одна перегрузка оператора будет объявлена в главе \ref{webelments}.
\end{icItems}

\subsubsection{\lstinline`<void or any>arg1 | <void or any>arg2 : void or any`}

Возвращаемый результат оператором альтернативного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{orhacktable}.

\begin{table}[htb]
	\caption{Оператор альтернативный выбор}
	\label{orhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 | arg2} \\ \hline
		\code{void} & \code{void} & \code{void}  \\ \hline
		\code{void} & \code{any}  & \code{arg2}  \\ \hline
		\code{any}  & \code{void} & \code{arg1}  \\ \hline
		\code{any}  & \code{any}  & \code{arg1}  \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> \& <void or any> : void or any`}

Возвращаемый результат оператором первичного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{andhacktable}.
	
\begin{table}[htb]
	\caption{Оператор первичный выбор}
	\label{andhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \& arg2} \\ \hline
		\code{void} & \code{void} & \code{void}   \\ \hline
		\code{void} & \code{any}  & \code{void}   \\ \hline
		\code{any}  & \code{void} & \code{void}   \\ \hline
		\code{any}  & \code{any}  & \code{arg1}   \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> ~ <void or any> : void or any`}

Возвращаемый результат оператором вторичного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{eqhacktable}.
	
\begin{table}[htb]
	\caption{Оператор вторичный выбор}
	\label{eqhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \~ arg2} \\ \hline
		\code{void} & \code{void} & \code{void}   \\ \hline
		\code{void} & \code{any}  & \code{void}   \\ \hline
		\code{any}  & \code{void} & \code{void}   \\ \hline
		\code{any}  & \code{any}  & \code{arg2}   \\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline`<void or any> ^ <void or any> : void or any`}

Возвращаемый результат оператором исключающего выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{xorhacktable}.
	
\begin{table}[htb]
	\caption{Оператор исключающий выбор}
	\label{xorhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \^ arg2} \\ \hline
		\code{void} & \code{void} & \code{void}   \\ \hline
		\code{void} & \code{any}  & \code{arg2}   \\ \hline
		\code{any}  & \code{void} & \code{arg1}   \\ \hline
		\code{any}  & \code{any}  & \code{void}   \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> \% <void or any> : void or any`}
	Возвращаемый результат оператором исключающего выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{centhacktable}.
%\stablethree{1.5cm}{1.5cm}{5cm}
%{centhacktable}{Оператор коллекционный выбор}
%{\code{arg1}}{\code{arg2}}{\code{a \^ b}}
%{
\begin{table}[htb]
	\caption{Оператор коллекционный выбор}
	\label{centhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1}   & \code{arg2}   & \code{arg1 \% arg2}        \\ \hline
		\code{void}   & \code{void}   & \code{void}                \\ \hline
		\code{void}   & \code{any}    & \code{arg2}                \\ \hline
		\code{any}    & \code{void}   & \code{arg1}                \\ \hline
		\code{int}    & \code{int}    & \code{int}                 \\ \hline
		\code{double} & \code{double} & \code{double}              \\ \hline
		\code{string} & \code{string} & \code{list - [arg1 arg2]}  \\ \hline
		\code{list}   & \code{string} & \code{list - [arg1 arg2]}  \\ \hline
		\code{object} & \code{object} & \code{set - [arg1 arg2]}   \\ \hline
		\code{set}    & \code{object} & \code{set - [arg1 arg2]} \\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}
%}

Для аргументов типов \code{int} и \code{double}, вызывается функция \code{_numbers.process}, перед использованием установите какую операцию нужно выполнять с числами, использую функцию \code{_numbers.setProcess} с одни из следующих аргументов: \code{_numbers'sum} - сумма, \code{_numbers'product} - произведение, \code{_numbers'max} - максимум, \code{_numbers'min} - минимум. После использования оператора, вызываете \code{_numbers.restoreProcess} чтобы восстановить исходные настройки.

\subsection{Дополнительные операторы}

\subsubsection{\lstinline`[string...]`, \lstinline`[arg...]`, \lstinline`[param...]`, \lstinline`[<>]` и \lstinline`[]`}

{\bf Квадратные скобки} или {\bf оператор объединения данных} позволяет создавать объекты следующих типов данных \code{list}, \code{set} и \code{object}.
	
\code{[]} создаёт пустой список.
	
\code{[string ...]} создаёт заполненный список, он может содержать как константные литеры, так и вызовы на функций возвращающие строки. Пример: \code{["a" "b" "c"]}.
	
\code{[list ...]} объединяет несколько списков в один.
	
\code{[string or list ...]} - строки и списки можно смешать.
	
\code{[<>]} создаёт пустой объект.
	
\code{[arg ...]} создаёт объект имеющие поля (каждое поле описывается в виде аргумента), аргумент описывается следующим образом \code{<value>name}, где \code{value} - значение, \code{name} - название аргумента. Пример \code{[<2>number <"str">str]}.
	
\code{[param ...]} создаёт множество с указанным заголовкам, каждый столбец описывается в виде параметра, параметр описывается следующим образом \code{<type>name}, где \code{type} - тип значения, \code{name} - название параметра. Создавать множество с пустым заголовком - запрещено. Пример \code{[<int>number <string>str]}.
 
\code{[object ...]} создаёт множество из несколько объектов.
	
\code{[set ...]} объединяет несколько множеств в одной.
	
\code{[object or set ...]} объекты и множества также можно смешать.

\newpage
\section{Условные операторы}

Условные структуры имеют условие, которое будет вычислено. А также и блоки команд, чья выполнение зависит от значения условии.
	
В icL приличествуют следующее условные операторы:
\begin{icItems}
	\item \code{if};
	\item \code{if else};
	\item каскадное \code{if else};
	\item \code{exists};
	\item \code{if exists};
	\item \code{for any}.
\end{icItems}
	
\subsubsection{\lstinline`if`}

\code{if} позволяет ставить условия выполнения блока команд. Он имеет следующую форму:
\begin{lstlisting}[numbers=none]
if (condition) {
	commands
};
\end{lstlisting}
где \code{condition} любое выражение возвращающее значение типа \code{bool} и \code{commands} любой набор команд.

Также допускаются и следующее упрощённые формы:
\begin{lstlisting}[numbers=none]
if true  { commands };
if !true { commands };
if @var  { commands };
if !@var { commands };
\end{lstlisting}

\subsubsection{\lstinline`if else`}

\code{if else} позволяет выбирать между двух блоков команд, в случае когда условие истинно - выполняется первый блок, иначе второй блок.
	
\noindent Конструкция \code{if else} выглядит следующим образом -
\begin{lstlisting}[numbers=none]
if (condition) {
	commands1
}
else {
	commands2
};
\end{lstlisting}

\subsubsection{Каскадное \lstinline`if else`}

Каскадное \code{if else} позволяет выбирать между n блоков команд, но для это нужно предъявить n-1 условии.
	
\noindent Простой и наглядный пример -
\begin{lstlisting}[numbers=none]
if (condition1) {
	commands1
} else if (condition2) {
	commands2
} else {
	commands3
};
\end{lstlisting}

\subsubsection{\lstinline`exists`}

\code{exists} позволяет условно возвращать данные, если они подходят под определённому критерия.
	
Условия по умолчанию:
\begin{icItems}
	\item для \code{bool} - \code{# == true};
	\item для \code{int} - \code{# != 0};
	\item для \code{double} - \code{# != 0.0};
	\item для \code{string} - \code{!#'empty};
	\item для \code{list} - \code{!#'empty};
	\item для \code{object} - \code{!#'empty};
	\item для \code{set} - \code{!#'empty};
	\item для \code{request} - \code{!#'empty};
	\item для \code{element} - \code{#.isValid}.
\end{icItems}
	
Если использовать условию по умолчанию, то конструкция будет выглядеть следующим образом -
\begin{lstlisting}[numbers=none]
exists(expression);
\end{lstlisting}
а если добавить пользовательское условие -
\begin{lstlisting}[numbers=none]
exists(expression, condition);
\end{lstlisting}

\subsubsection{\lstinline`if exists`}

Конструкция \code{if exists} позволяет выполнять блок команд в зависимости от результата работы конструкции \code{exists}. Также повторно использовать значения выражения. В случае когда условие конструкции \code{exists} истинно, то блок команд выполняется и в нём передаётся данный полученные от \code{exists} под именем \code{@}.
	
\indent Простой и элементарный пример -
\begin{lstlisting}[numbers=none]
if exists(23 + 3, # > 20) {
	_log.out "@ = " @; `` @ = 26 
};
\end{lstlisting}

\subsubsection{\lstinline`for any`}

\code{for any} позволяет повторно использовать любое значение.
	
\noindent Пример -
\begin{lstlisting}[numbers=none]
for any(23 + 3) {
	_log.out "@ = " @; `` @ = 26
};
\end{lstlisting}

\newpage
\section{Циклы}

Может возникнуть нужность в том, чтобы выполнить блок кода несколько раз. Для этого совсем не обязательно писать один то тоже код несколько раз, достаточно использовать цикл.
	
Язык icL предоставляет следующие типы циклов:

\begin{icItems}
	\item \code{for} - универсальный цикл;
	\item \code{while} - условное повторение кода;
	\item \code{do while} - цикл с постусловий;
	\item \code{for} - прохождение коллекций;
	\item \code{filter} - выборочное прохождение коллекций;
	\item \code{range} - частичное прохождение коллекций.
\end{icItems}
	

\subsubsection{\lstinline`for` - универсальный цикл}

{\bf Универсальный цикл} позволяет полностью управлять ход выполнения кода. Он содержит:

\begin{icItems}
	\item \code{initialization} - код отвечающий за инициализацию;
	\item \code{condition} - условие, которая проверяется перед запуском цикла;
	\item \code{step} - код, отвечающий за перехода на следующую итерацию цикла.
	\item \code{commands} - тело цикла.
\end{icItems}

\noindent Выглядит она следующим образом -
\begin{lstlisting}[numbers=none]
for (initialization, condition, step) {
	commands
};
\end{lstlisting}

\noindent Наглядный пример -
\begin{lstlisting}[numbers=none]
for (@i = 0, i < 5, @i = @i + 1) {
	_log:out @i;
};
\end{lstlisting}

\subsubsection{\lstinline`while` - условное повторение кода}

{\bf Условное повторение кода} будет выполнить блок команд, пока условие остаётся истиной. Условие проверяется перед запуском цикла и если условие изначально - лож, тела цикла не будет выполниться ни разу.

Главное его преимущества - его простота. В сравнения с универсального цикла, в конструкции \code{while} отсутствуют фрагменты кода для инициализации и перехода на следующую итерацию. Он содержит только условие и тело -
\begin{lstlisting}[numbers=none]
while (condition) {
	commands
};
\end{lstlisting}

\noindent Пример (при завершении работы цикла \code{@number} будет равен 6-и) -
\begin{lstlisting}[numbers=none]
@number = 1;

while (@number <= 5) {
	@number = @number + 1;
};
\end{lstlisting}

\subsubsection{\lstinline`do while` - цикл с постусловий}

{\bf Цикл с постусловий} мало отличается от \code{while}, но он гарантирует что тело цикла будет выполнена минимум 1 раз. Также условие объявляется после тело цикла, указывая на то что она будет проверено после первой итерации -
\begin{lstlisting}[numbers=none]
do {
	commands
} while (condition);
\end{lstlisting}

\noindent Пример (при завершении работы цикла \code{@number} будет равен 7-и) -
\begin{lstlisting}[numbers=none]
@number = 6;

do {
	@number = @number + 1;
} while (@number < 5);
\end{lstlisting}

\subsubsection{\lstinline`for` - прохождение коллекций}

{Коллекция} - объект, содержащий несколько значений. Самый простой пример коллекций это список, он содержит несколько строк. Например, нужно выполнять операцию для каждой строки списка. Можно использовать универсальный цикл -
\begin{lstlisting}[numbers=none]
@list = ["apple" "banana" "fruit"];

for (@i = 0; @i < @list'length; @i = @i + 1) {
	@list.at @i; `` get i-th value
}
\end{lstlisting}

Или использовать {\bf прохождение коллекций} -
\begin{lstlisting}[numbers=none]
@list = ["apple" "banana" "fruit"];

for (@list) {
	@; `` get i-th value
}
\end{lstlisting}

\subsubsection{\lstinline`filter` - выборочное прохождение коллекций}

{\bf Конструкция \code{filter}} позволяет ставить условие, для каких элементов коллекций выполнять тело цикла, для каких нет.

В условия есть специальные переменные: \lstinline|@| - значение элемента коллекций и \lstinline|#| - индекс текущей значения.

В общем виде конструкция выглядит следующим образом -
\begin{lstlisting}[numbers=none]
filter (collection, condition) {
	commands
};
\end{lstlisting}

\noindent Пример "Строки, содержащие букву а" -
\begin{lstlisting}[numbers=none]
@list = ["apple" "banana" "fruit"];

filter (@list, @ << "a") {
	@; `` apple, banana
}
\end{lstlisting}

\noindent Пример "Чётные элементы списка" -
\begin{lstlisting}[numbers=none]
@list = ["apple" "banana" "fruit"];

filter (@list, # \ 2 == 0) {
	@; `` apple, fruit
}
\end{lstlisting}

\subsubsection{\lstinline`range` - частичное прохождение коллекций}

{\bf Частичное прохождение} позволяет выполнить код для интервала коллекций. Интервал определяется одной или двум условий. Первое условие используется для поиска начала интервала. Второе условие - для поиска конца, если оно отсутствует, будет использоваться первое условие. В отсутствия подходящих элементов, тела цикла не будет выполнена. Чтобы выбирать первый или последний элемент (в зависимость от предназначения условии), использует выражение \code{true}.

\noindent С одним условием -
\begin{lstlisting}[numbers=none]
range (collection, condition) {
	commands
};
\end{lstlisting}

\noindent С двух условием -
\begin{lstlisting}[numbers=none]
range (collection, condition_for_begin, condition_for_end) {
	commands
};
\end{lstlisting}

\noindent Пример "От banana до kiwi" -
\begin{lstlisting}[numbers=none]
@list = ["apple" "banana" "fruit" "kiwi"];

range (@list, @ == "banana", @ == "kiwi") {
	@; `` banana, fruit, kiwi
}
\end{lstlisting}

\noindent Пример "От второго до последнего" -
\begin{lstlisting}[numbers=none]
@list = ["apple" "banana" "fruit" "kiwi"];

range (@list, # == 2, true) {
@; `` fruit, kiwi
}
\end{lstlisting}

\newpage
\section{Прогресс}

{\color{red}Материал для продвинутых пользователей.}
  	
\begin{icEnum}
	\item + Введение
	\item + Базовый синтаксис
	\item + Переменные
	\item + Типы данных
	\item + Литералы
	\item + Операторы
	\item + Условные операторы
	\item + Циклы
	\item - Интеграция с Javascript
	\item - Функции
	\item - Строки
	\item - Списки
	\item - Многоженства
	\item - Объекты
	\item - Веб-элементы (симуляция мышки и клавиатуры) webelments
	\item - Обмен данных в веб-странницей (конкретные примеры) dataexchange
	\item - DSV / CSV / TSV
\end{icEnum}
  	
{\color{red}далее материал для программистов, дополнительные возможности, просьба не читать далее материал если нету желание или необходимость.}
	
\begin{icEnumResume}
	\item - Регулярные выражения
	\item - Механизм состояний
	\item - Базы данных (только SQLite в первой версии)
	\item - Обработка ошибок emiter, emit, slot
	\item - Программирование errorless
	\item - Программирование на лету
\end{icEnumResume}
	
\end{document}
