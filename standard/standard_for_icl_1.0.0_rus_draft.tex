\documentclass[a4paper, 14pt]{extarticle}

\usepackage[top=2.5cm, bottom=1.5cm, left=2cm, right=1cm]{geometry}
\usepackage{fancyvrb}
\fvset{tabsize=2}
\usepackage{polyglossia}
\setmainlanguage{russian} 
\setotherlanguage{english}
\usepackage{setspace}

\usepackage{longtable}
\usepackage{ragged2e}
\setcounter{tocdepth}{2}
  
\setmainfont{Liberation Serif}
\newfontfamily\cyrillicfont{Liberation Serif}
\setmonofont{Liberation Mono}
\setsansfont{Liberation Sans}
\newfontfamily\cyrillicfontmono{Liberation Mono}
\newfontfamily\cyrillicfontsans{Liberation Sans}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage[singlelinecheck=false]{caption}
\usepackage{listings, lstautogobble}
\usepackage{color}
\usepackage[table]{xcolor}

\usepackage{caption}
\DeclareCaptionFont{black}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{codeheaderbg}
	{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]
	{format=listing,labelfont=black,textfont=black}

\usepackage{enumitem}

\lstdefinestyle{framed}
{
     frame=none,         
     belowcaptionskip=2pt,
     xleftmargin=8pt,
     framexleftmargin=7pt,
     framexrightmargin=5pt,
     framextopmargin=10pt,
     framexbottommargin=5pt,
     framesep=0pt,
     rulesep=0pt,
     texcl=true
}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\definecolor{codebg}{rgb}{0.97, 0.97, 0.97}
\definecolor{codeheaderbg}{rgb}{0.90, 0.90, 0.90}
\definecolor{orange}{rgb}{0.8, 0.4, 0.0}
\definecolor{bluemarin}{RGB}{12, 134, 145}
\definecolor{grey}{rgb}{0.5, 0.5, 0.5}
\definecolor{function}{RGB}{11, 145, 89}
\definecolor{blue2}{RGB}{15, 92, 198}

\lstdefinelanguage{icL}{
	keywords={if, else, for, filter, range, exists, while, do, any,emit, emiter, slot, @, \#},
	keywordstyle=\color{blue2},
	keywords=[2]{bool, int, double, string, list, element, set, item, object, function, void},
	keywordstyle=[2]\color{bluemarin},
	classoffset=3,
	morekeywords={_log, _define, _tab, _dom, _define, _import, true, false},
	keywordstyle=\color{orange},
	classoffset=4,
	morekeywords={info, warm, error, signal, get, query, queryAll, null, Prepend, Append, Insert, Merge, PopFront, PopBack, Remove, RemoveOnce, RemoveAll, Get, IndexOf, LastIndexOf, Join, SumUp, Max, Min, LogicAnd, LogicOr, Length, Text, HTML, Width, Height, Click, ScrollTo, SendKeys, IsValid, Copy, Add, Filter, Query, QueryAll, Visible, Clickable, Next, Prev, Parent, Child, Closest, AddClass, HasClass, RemoveClass, all, functions, none, run, close},
	keywordstyle=\color{function},
	classoffset=5,
	morekeywords={UnrealCast, StringParse, EmptyList, MultipleValues, NullElement, NotVisible,  WrongName, OutOfBounds, OutOfScreen, FileNotFound},
	classoffset=0,
	identifierstyle=\color{black},
	sensitive=true,
	comment=[l]{``},
	morecomment=[s]{```}{```},
	morecomment=[s]{`c}{t`},
	commentstyle=\color{grey},
	stringstyle=\color{purple},
	morestring=[b]"
}

\usepackage{chngcntr}

\newenvironment{icItems}
	{ \begin{itemize} [noitemsep,nolistsep] }
	{ \end{itemize} } 

\newenvironment{icEnumResume}
	{ \begin{enumerate}[noitemsep,nolistsep,resume] }
	{ \end{enumerate} } 

\newenvironment{icEnum}
	{ \begin{enumerate}[noitemsep,nolistsep] }
	{ \end{enumerate} } 

\begin{document}

%\renewcommand{\rmdefault}{ftm}
\counterwithin{lstlisting}{section}
\counterwithin{table}{section}

\renewcommand{\lstlistingname}{Листинг}

\setlength\abovecaptionskip{2pt}
\setlength\belowcaptionskip{1pt}

\lstset{
	language=icL,
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	showtabs=false,
	numbers=left,
	stepnumber=1,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=true,
	backgroundcolor=\color{codebg},
	style=framed,
	lineskip=0pt,
	aboveskip=0pt,
	autogobble=true
}
	
\setlength{\LTleft}{0pt}
\onehalfspacing

\newcommand{\greycell}[1]{\cellcolor{lightgray}\centering\textbf{#1}}

\newcommand{\code}[1]{\lstinline`#1`}

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\tabletwo}[7]{
	\begin{longtable}[h]{p{#1}}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\stabletwo}[7]{
	\begin{longtable}[h]{|p{#1}|p{#2}|}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\tablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\stablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\tableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	#2
	#3
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	#3
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#6
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\stableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	#2
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	#2
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#5
	\end{longtable}
}

% Содержимое докимента
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Стандарт языка описания сценариях icL v1.0.0 черновик}
\author{Лелицак Василе}

\maketitle

\newpage
\renewcommand{\contentsname}{\textsf{Оглавление}}
\tableofcontents
	
\newpage

\section{Введение}	
	
\indent \textbf{icL} - \textbf{язык описания сценариев}, оптимизирован под описания сценариев тестирования веб-приложений.
	
\subsection{Читатели}
	
	Этот документ предназначен для всех тех людей, которые ищут отравную точку, откуда можно начать изучать язык icL. Также данный документ используется при разработке интерпретатора, поведения интерпретатора во всех ситуациях не описанных в данном документе считается не определённой.
	
\subsection{Что вы должны уметь}
	
Прежде чем выступать к изучения этого языка, вам желательно иметь базовое представление о компьютерном программировании.
	
\subsection{Обзор языка icL}
	
	icL - язык сценариев тестирования веб-приложений. Его разработка началась в 2017 году и первый выпуск планируется к 2020 году. В настоящий момент он находится в активном разработке.
	
	icL - \textbf{язык с С-подобным синтаксисом}, который использует статическую типизацию. В icL нельзя определить собственные типы данных, так как он разработан не для программистов, знания получены в школе на уроках информатики должны быть достаточными. Язык icL поддерживает только одну парадигму программирования - процедурная. При необходимости обработать данные, можно использовать экспорт/импорт в/из cvs и базы данных.
	
\subsection{Пример кода}

	В icL точка входа в программе - начало файла, программа \textit{Hello world!} иллюстрирована на листинге \ref{example0}.
	
\begin{lstlisting}[caption=Пример, label=example0]
`` comment example
_log.info "Hello world";
\end{lstlisting}
  
\subsection{Изучение icL}
	
	Самое важное при изучении icL - это сосредоточиться на идеях и не потеряться в технических деталях его реализации.
	
\subsection{Области применения icL}
	
	Язык icL является частью \textbf{программы icL}, с его помощью можно управлять браузером, а именно:
\begin{icItems}
	\item открыть вкладку;
	\item закрыть вкладку;
	\item перейти на веб-страницу;
	\item симулировать события клавиатуры и мышке;
	\item взаимодействовать с веб-страницей;
	\item выполнить код на языке javascript;
	\item управлять веб-страницей;
	\item обменять информацию с веб-страничкой;
	\item сделать screenshot;
	\item сохранить страницу в формате pdf;
	\item управлять памятью;
	\item экспортировать данные в csv файле;
	\item импортировать данные из csv файл;
	\item выполнить запросы на языке SQL.
\end{icItems}
	
\subsection{Начало работы}
	
	Чтобы начать работать достаточно установить и запустить программу icL.
	
\newpage
\section{Базовый синтаксис}
	
	icL достаточно прост в освоении, вставите код с листинга \ref{first} в icL и выполняете его. Первую программу можно уже сохранить в файле с расширением icl.
	
\begin{lstlisting}[caption=Первая программа, label=first]
_log.info "Test!";
\end{lstlisting}
	
	В консоль можем увидеть следующий \textbf{вывод программы}:
	
\begin{lstlisting}[numbers=none]
Test!
\end{lstlisting}
	
\subsection{Импорт в icL}
	
	Все \textbf{стандартные библиотеки} встроены в языке, но можно написать импортировать \textbf{пользовательские}, с помощью:
\begin{icItems}
	\item \lstinline`_import.none "path/to/file.iclib"` - выполнить код, который содержатся в файле, ничего не импортировать.
	\item \lstinline`_import.functions "path/to/file.iclib"` - выполнить код и импортировать функций; {\color{red}Важно:} импортированные функций не должны использовать глобальные переменные.
	\item \lstinline`_import.all "path/to/file.iclib"` -  выполнить код, импортировать функций и глобальные переменные;
	\item \lstinline`_import.run "path/to/file.iclib"` - выполнить код в текущем контексте, все функции и глобальные переменные импортируется и экспортируется;
\end{icItems}
	
\subsection{Токены в icL}
	
	Программа на icL состоит из различных \textbf{токенов} (литералов, семантических конструкциях), а токен может являться ключевым словом, идентификатором, константной, строковым литералом, либо символом. Например следующая команда состоит из четырёх токенов: \lstinline`_log.info "Hello world!";`
	
	Отдельными токенами являются:
\begin{icItems}
	\item \lstinline`_log` - идентификатор объекта;
	\item \lstinline`.info` - идентификатор метода;
	\item \lstinline`"Hello world!"` - строковый литерал;
	\item \lstinline`;` - разделитель, конец команды.
\end{icItems}
	
\subsection{Комментарии}
	
	\textbf{Комментарии} - это вспомогательный текст, который помогает понимать написанных сценариях, они полностью игнорируется командного процессора. 
	
	\textbf{Комментарии в линии} (\textit{inline}) являются строковым литералом ограниченным специальными кавычками \texttt{`}, как показано на листинге \ref{inlinecomment}.
	
\begin{lstlisting}[caption=Комментарий в линии,label=inlinecomment]
No comment `comment` no comment
\end{lstlisting}
	
	\textbf{Одиночный комментарий} записывается в использованием символов \texttt{``} в начале, смотрите листинг \ref{linecomment}.
	
\begin{lstlisting}[caption=Одиночный комментарий,label=linecomment]
No comment `` comment
\end{lstlisting}
	
	\textbf{Многострочный комментарий} начинается и заканчивается с \texttt{```}, пример многострочного комментария приведён на листинге \ref{multilinecomment}.
	
\begin{lstlisting}[caption=Многострочный комментарий,label=multilinecomment]
No comment
``` comment 1
	comment 2
	comment 3
``` No comment
\end{lstlisting}
	
\subsection{Идентификторы}
	
	\textbf{Идентификатор} в icL - это имя, используемое для идентификации переменной, функций, методов и свойств. Идентификатор начинается с символов обозначающий его предназначение(\lstinline`@`, \lstinline`#`, \lstinline`!`, \lstinline`_`, \lstinline`.` или \lstinline`'`), за которым следует от 2 до 32 букв(английского или национального алфавита) и цифр (от 0 до 9).
	
	icL - чувствительный к регистру язык. Таким образом \textit{@var} и \textit{@Var} являются двумя разными идентификаторами. Вот несколько примеров допустимых идентификаторов:
	
\begin{lstlisting}[numbers=none]
#loop		_tab		.Append		'Length	_dom	@ii 	@VAR
@variable	!sumPoints	#global		.Merge	.Get	#01		!SIN
\end{lstlisting}
	
\subsection{Ключевые слова}
	
	В icL \textbf{ключевые слова} не зарезервированные. Их всего 11: \lstinline`if`, \lstinline`for`, \lstinline`filter`, \lstinline`range`, \lstinline`exists`, \lstinline`while`, \lstinline`do`, \lstinline`any`, \lstinline`emit`, \lstinline`emiter` и \lstinline`slot`. В данном документе они выделены синим цветом.
  
\subsection{Пробельные символы и разделители}
	
	\textbf{Пробельный символ} (\textit{whitespace}) - этот термин используется в icL для описания пробелов, символов табуляции, символов новой строкой и комментариев. Пробельные символы не обязательные, они используется для улучшения читабельности кода. На листинге \ref{unreadable} показан пример кода без пробельных символов, а на листинге \ref{readable} с пробельными символами.
	
\begin{lstlisting}[caption=Koд без пробельных символов,label=unreadable]
if(_tab.get"mai.ru"){(_dom.query"button").Click;}else{_log.error"The site mai.ru is unaviable";};
\end{lstlisting}
	
\begin{lstlisting}[caption=Koд с пробельных символов,label=readable]
`` the begin of program

`` try to go to mai.ru
if (_tab.get "mai.ru") {
	`` site loaded successfull
	`` click the button
	(_dom.query "button").Click;
}
else {
	`` try again later
	`` now log the error
	_log.error "The site mai.ru is unaviable";
};

`` end of the program
\end{lstlisting}
	
	В icL присутствует только один разделитель - \textbf{разделитель команд} \lstinline`;`. Команда - это набор токенов, распределенных в определённом порядке и характеризующее действие. Примеры команд: открыть сайт - \lstinline`_tab.get "URL"`, закрыть вкладку - \lstinline`_tab.close`.
	
	При описании последовательности действий, их надо разделить, например последовательность вышеперечисленных команд описывается так:	
\begin{lstlisting}[numbers=none]
_tab.get "URL"; _tab.close
\end{lstlisting} 
	
	Таким образом из команд собираем сценарии. Перед закрывающих скобок ставить разделитель команд опционально.
	
\subsubsection{Дополнительные сведение}
	
	Если у вас нет знании в программировании перейдите пожалуйста на третью главу.
	
	В icL отсутствуют разделители между значениями в списке. Примеры:
\begin{icItems}
  \item Инициализация списка в С++:
\begin{lstlisting}[numbers=none, language=C++]
std::list<std::string> list = {"one", "two", "three"};
\end{lstlisting}
	Инициализация списка в icL:
\begin{lstlisting}[numbers=none]
@list = ["one" "two" "three"];
\end{lstlisting}
  \item Функция в С++:
\begin{lstlisting}[numbers=none, language=C++]
int sum (int number1, int number2) { return number1 + number2; };
\end{lstlisting}
	Функция в icL:
\begin{lstlisting}[numbers=none]
!sum = <int>number1 <int>number2 : int { @ = number1 + number2 };
\end{lstlisting}
  \item Вызов функций в С++:
\begin{lstlisting}[numbers=none, language=C++]
int s = sum (100, 200);
\end{lstlisting}
	Вызов функций в icL:
\begin{lstlisting}[numbers=none]
@sum = !sum 100 200;
\end{lstlisting}
  \item Код на С++:
\begin{lstlisting}[numbers=none, language=C++]
sum (100 + 50, 200);
\end{lstlisting}
	Эквивалент на icL:
\begin{lstlisting}[numbers=none]
!sum (100 + 50) 200;
\end{lstlisting}
\end{icItems}

\newpage
\section{Переменные}  
	
	\textbf{Переменная} - название области хранения, который могут манипулировать сценария. Каждая переменная в icL имеет область видимость (фрагмент кода где можно её использовать) и тип, который определяет размер и способ размещения памяти переменной; диапазон значений которые можно применить к переменной.
	
	Имя переменной является идентификатором, начинающийся с \lstinline`@` или {\color{blue2}\lstinline`#`}.
	\textbf{Основные типы} переменных показаны в таблице \ref{variablestypes}.

\stabletwo{2cm}{15.1cm}{variablestypes}{Типы переменных}%
	{Тип}{Описание}%
	{ 
	bool & Логическое значения, имеет в состояние: истинно или лож. \\ \hline
	int & Целое число, позволяет хранить значения от -2.147.483.648 до 2.147.483.647. \\ \hline
	double & Дробное число, позволяет хранить вещественные числа. \\
	}
	
	icL также присутствуют и \textbf{сложные типы} переменных, такие как строки, списки, множества, объекты, которые мы посмотрим в полеживающих главах. В этой главе изучаем только основные типы.
	
\subsection{Объявления и инициализация переменных}
	
	\textbf{Объявления и инициализация} переменных, также операция \textit{присваивание} в icL неотличимы, и имеют общий вид \lstinline`a = b`, где \lstinline`a` новая или существующая переменная, а \lstinline`b` - значение. В тех случаев когда переменная \textbf{встречается первый раз}, мы её объявляем и инициализируем. В противном случае мы присваиваем ей значение.
	
	На листинге \ref{initexample} показаны несколько пример объявлений и инициализации переменных, обратите внимание что дробные числа пишется через точку, а не через запятую как принято в Европе и Российском Федераций.
  	
\begin{lstlisting}[caption=Пример объявлений и инициализации переменных,label=initexample]
@bool = false;
@catched = true;
@int = 234;
@double = 23.4;
#pi = 3.14;
#negative = -100.0;
\end{lstlisting}

\subsection{Локальные переменные}
	
	\textbf{Локальные переменные} имею узкую область видимость, ограниченные фигурными скобками которые их охватывает, и только после их объявлений. 
	
	{\bf Идентификаторы} локальных переменных начинается с символом \lstinline`@`. 
	
	На листинге \ref{localvars} показана область видимость переменной \lstinline`@var`, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test6` - она не видна, когда в точках объявления переменных \lstinline`@test3`, \lstinline`@test4` и \lstinline`@test5` - да.
\begin{lstlisting}[caption=Область видимости локальных перемен, label=localvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var; 
	`` initialization
	@var = 0;
	`` ok
	@test3 = @var;
	if (@) {
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var; 
}
`` error
@test6 = @var; 
\end{lstlisting}

\subsection{Глобальные переменные}

	\textbf{Глобальные переменные} имеют самую широкую область видимости, их видны из любой точке программы после их инициализации. Использовать глобальные переменные не рекомендуется, так как они могут привести к серьезных ошибок. 
	
	{\bf Идентификаторы} глобальных переменных начинается с символом {\color{blue2}\lstinline`#`}. Локальные переменные с одной названий могут быть несколько, когда глобальные - нет. Идентификатор глобальной переменной уникальный.
	
	Как указано на листинге \ref{globalvars}, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test3` переменная \lstinline`@var` не видна, когда в точках объявления переменных \lstinline`@test4`, \lstinline`@test5` и \lstinline`@test6` - да.
	
\begin{lstlisting}[caption=Область видимости глобальных перемен, label=globalvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var; 
	if (@) {
		`` error
		@test3 = @var;
		`` initialization
		@var = 0;
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var; 
}
`` ok
@test6 = @var;
\end{lstlisting}

\subsection{Левые и правые значения в icL}

	В icL присутствуют 3 типа значении:
\begin{icEnum}
	\item левые значения {\it lvalue} - переменные;
	\item правые значения {\it rvalue} - переменные и константы;
	\item javascript значения {\it jsvalue} - их будем рассматривать позже.
\end{icEnum}
	
	Левые значения могут находится с обеих сторон знака {\it присваивание}, когда правые - только справа. Примеры правильно и неправильно кода иллюстрированы на листинге \ref{rlvalues};
\begin{lstlisting}[caption=Левые и правые значения, label=rlvalues]
@a1 = @a2; @a3 = 123; `` ok
123 = @a1; 125 = 456; `` error 
\end{lstlisting}

\subsection{Выводы}

	{\bf Работа с переменными в icL} - максимально проста, но продвинутых пользователях без знания в программировании рекомендуется не использовать глобальные переменные. Для написания сценариях средней и низкой сложности, локальные переменные лучше подходят. 

\section{Типы данных}

	В языке описания сценариев icL, типы данных выполняют очень важную роль, они определяют как данные будут храниться и обработаться в процессе выполнения программы. Классификация типов данных представлена в таблице \ref{datatypeclasses}.
	
\stabletwo{3.5cm}{13.6cm}{datatypeclasses}{Категории типов данных}
	{Категория}{Описание}
	{
	Базовые & Типы данных описанных в предыдущем главе: \code{bool} - логический, \code{int} - целое - числа, \code{double} - дробные числа. \\ \hline
	Сложные & Типы данные содержащие несколько значении в контейнерах, примеры таких данных: строки, списки, множество. \\ \hline
	Системные & Типы данных которых нельзя создать и хранить в пользовательских переменных, но доступ к ними можно получить через системные (предопределённых) переменных, примеры таких данных: браузер, вкладка, история браузера, окно. \\ \hline
	Тип \code{void} & Тип данных обозначающий отсутствия данных.
	}
	
\subsection{Основные типы данных}

	{\bf Основные типы данных} участвуют в логических и арифметических операциях языка icL. Логическими операциями являются конъюнкция, дизъюнкция, исключающий или, эквиваленция и инверсия. Арифметическими операциями являются сложения, вычитания, умножения, деления, извлечения корня и возведения в степень.
	
\subsection{Сложные типы данных}

	{\bf Сложные типы данных} специализированные под хранения больших массивов данных. Строка позволяет хранить более двух миллиардов символов. Список позволяет хранить более двух миллиардов строк. А множество позволяет хранить большой объём данных ограничен только оперативной памяти. Объект позволяет инкапсулировать данные разного рода по одном именем. Элемент позволяет хранить ссылку на один или несколько HTML-тэгов.

\subsection{Системные типы данных}

	{\bf Системные типы данных} позволяют взаимодействовать с веб-страницей и браузером. Подробную информацию можно найти в главах \ref{webelments} и \ref{dataexchange}.
	
\subsection{Тип данных {\color{bluemarin} void}}

	{\bf Тип данных \code{void}} означает отсутствия информации, он используется в самых различных целях:
\begin{icItems}
	\item указать то что функция ничего не возвращает;
	\item указать на то что в процессе работы функций произошла ошибка;
	\item выбрать источник данных;
	\item фильтровать данные;
	\item удалить переменных состояния;
	\item и другие.
\end{icItems}

\newpage
\section{Литералы}
	
	Константные значения, которые присутствуют в скрипте в виде часть исходного кода, называются {\bf литералами}.
	Литералы могут быть любыми из следующих типов:
\begin{icItems}
	\item логическое значение - \code{bool};
	\item целое число - \code{int};
	\item дробное число - \code{double};
	\item строка - \code{string};
	\item список - \code{list};
	\item объект - \code{object};
	\item множество - \code{set}.
\end{icItems}

\subsubsection{Логические значения}

	Для представления {\bf логических значения} используется следующее литералы:
\begin{icItems}
	\item \code{true} - логическое единица, истинно;
	\item \code{false} - логической ноль, лож.
\end{icItems}

\subsubsection{Целые числа}

	Для представления {\bf целых чисел} используется последовательность цифр, перед которым может присутствовать минус. Между минусом и последовательности цифр разделители должны отсутствовать, иначе минус будет интерпретирован как оператор.
	
\noindent Примеры:
\begin{lstlisting}[numbers=none]
23; -23; - 23; +23 + 3; 12 + -34; 15 - 24; 89--56; 2-3; `` ok
23-; 23+; -2А; 3f5; 23f; 23l; 12u; 89i; 2w1; 1q1; rt2; `` error 
\end{lstlisting}
	
\subsubsection{Дробные числа}

	{\bf Дробный литерал} состоит из двух частей: целая и дробная. Они разделяются точкой. Каждая составная часть является целом числом. Дробная часть не может быть отрицательной.
	
\noindent Примеры:
\begin{lstlisting}[numbers=none]
23.233452; 29229992.2391; 100.0; -23.29199; -0.23; -0.45 - 1000.5; `` ok
23.-4; 3а.34; 23-.44; 34.+23; -25.f; -23.5f; -w.45; -2.4e10; -2.E2; `` error 
\end{lstlisting}

\subsubsection{Строки}

	{\bf Строковым литералом} является последовательность символов, ограниченное с обеих сторон кавычками \lstinline`"`. Чтобы добавить \lstinline`"` используется \lstinline`\"`, символ табуляции - \lstinline`\t`, символ {\it новая строка} - \lstinline`\n`, символ {\it возврат на шаг} - \lstinline`\b`, \textbackslash \ - \lstinline`\\`.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
"Hello \"to\" you!"; "Line1\nLine2"; "Tag1\n\bTag2\n\b"; "text"; "\\ \\ \n \\ \\";
\end{lstlisting}

\subsubsection{Списки}

	{\bf Литералом списка} является последовательность строк, ограниченное квадратными скобками.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
@fruits = ["Apple" "Mango" "Banana" "Lime" "Lemon" "Olive"];
@vegetables = ["Cress" "Mustard" "Guar" "Soybean" "Leek" "Ahipa"];
\end{lstlisting}

\subsubsection{Объекты}

	{\bf Объектом} является объединение нескольких переменных под общем именем, переменная объявлена внутри объекта называется {\it поле}. Литерал {\it поле} имеет следующий синтаксис \lstinline`<value>name`, где  {\it value} - значение и {\it name} - название. В icL неинициализируемые поля, как и неинициализируемые переменные, нельзя объявить. 
	
\noindent Примеры:
\begin{lstlisting}[numbers=none]
@quotation = [<"author">author <"text">text];
@child = [<4>age <true>hasBrothers <true>hasParents];
@file = [<false>isEmpty <25220>size <true>readOnly];
\end{lstlisting}

\subsubsection{Множества}

	Только {\bf пустое множество} можно описать литералом, литерал схож с литералом объекта, только вместо значении указывается тип значения.
	
\noindent Примеры:
\begin{lstlisting}[numbers=none]
@quotations = [<string>author <string>text];
@children = [<int>age <bool>hasBrothers <bool>hasParents];
@files = [<bool>isEmpty <int>size <bool>readOnly];
\end{lstlisting}

\newpage
\section{Операторы}

	{\bf Оператор} - это токен, который предписывает выполнение определённой манипуляции данных. Встроенных операторов в icL очень много, по этому будет их разбирать по типу данных, в следующем порядке:
\begin{icEnum}
	\item \code{bool};
	\item \code{int};
	\item \code{double};
	\item \code{string};
	\item \code{list};
	\item \code{object};
	\item \code{set};
	\item \code{void}.
\end{icEnum}

	Операторы имеют ранг, операторы имеющие наивысший ранг выполняются первыми, а имеющие наименьший ранг - последними. Операторы имеющие правое ассоциативность выполняются раньше чем операторы имеющие левое ассоциативность, они отмечены плюсом справа от ранга, например 7$^+$.
	
	{\bf Оператор пристраивания} имеет ранг 0 и правое ассоциативность;

\subsection{\color{bluemarin}bool}

	Если у вас отсутствуют знания по алгебры логике, пожалуйста прочтите любую книгу по основы данной науке.

	Для типа данных \code{bool}, доступны:
\begin{icItems}
	\item операции алгебры логике (имеющие ранг 2):
	\begin{icItems}
		\item конъюнкция - \lstinline`bool & bool : bool`;
		\item дизъюнкция - \lstinline`bool | bool : bool`;
		\item эквивалентность - \lstinline`bool ~ bool : bool`;
		\item исключающий или - \lstinline`bool ^ bool : bool`;
		\item инверсия (имеет ранг 7$^+$) - \lstinline`! bool : bool`;
	\end{icItems}

	\item операций сравнения (имеющие ранг 3):
	\begin{icItems}
		\item равно - \lstinline`bool == bool : bool`;
		\item не равно - \lstinline`bool != bool : bool`;
	\end{icItems}
\end{icItems}

	Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{boolopex}.
	
\begin{lstlisting}[caption=Примеры использования операторов над данными типа bool, label=boolopex]
_log:out "true & false = " (true & false);     `` true \& false = false
_log:out "false | true =  " (false | true);     `` false | true = true
_log:out "true ~ false = " (true ~ false);     `` true \textasciitilde\ false = false
_log:out "false ^ true = " (false ^ true);     `` false \textasciicircum\ true = true`

_log:out "!true = " !true;                     `` !true = false
_log:out "!false = " !false;                   `` !false = true

_log:out "true == false = " (true == false);   `` true == false = false
_log:out "false != true = " (false != true);   `` false != true = true
\end{lstlisting}

\subsubsection{\lstinline`<bool>a & <bool>b : bool`}
	Оператор принимает логическую операцию "конъюнкция" над переменных a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{conjtable}.
\begin{table}[htb]
\caption{Таблица истинности конъюнкции}
\label{conjtable}
\begin{tabular}{|c|c|c|}
\hline
\code{a} & \code{b} & \code{a \& b} \\ \hline
\code{false} & \code{false} & \code{false} \\ \hline
\code{false} & \code{true} & \code{false} \\	 \hline
\code{true} & \code{false} & \code{false} \\ \hline
\code{true} & \code{true} & \code{true} \\ \hline
\end{tabular}
\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a | <bool>b : bool`}
	Оператор принимает логическую операцию "дизъюнкция" над переменных a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{distable}.
\begin{table}[htb]
\caption{Таблица истинности дизъюнкции}
\label{distable}
\begin{tabular}{|c|c|c|}
\hline
\code{a} & \code{b} & \code{a | b} \\ \hline
\code{false} & \code{false} & \code{false} \\ \hline
\code{false} & \code{true} & \code{true} \\	 \hline
\code{true} & \code{false} & \code{true} \\ \hline
\code{true} & \code{true} & \code{true} \\ \hline
\end{tabular}
\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a ~ <bool>b : bool`}
	Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logeqtable}.
\begin{table}[htb]
\caption{Таблица истинности эквивалентности}
\label{logeqtable}
\begin{tabular}{|c|c|c|}
\hline
\code{a} & \code{b} & \code{a \~ b} \\ \hline
\code{false} & \code{false} & \code{true} \\ \hline
\code{false} & \code{true} & \code{false} \\	 \hline
\code{true} & \code{false} & \code{false} \\ \hline
\code{true} & \code{true} & \code{true} \\ \hline
\end{tabular}
\vspace{0em}
\end{table}

\subsubsection{\lstinline`<bool>a ^ <bool>b : bool`}
	Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logdifftable}.
\begin{table}[htb]
\caption{Таблица истинности исключающего или}
\label{logdifftable}
\begin{tabular}{|c|c|c|}
\hline
\code{a} & \code{b} & \code{a \^ b} \\ \hline
\code{false} & \code{false} & \code{false} \\ \hline
\code{false} & \code{true} & \code{true} \\	 \hline
\code{true} & \code{false} & \code{true} \\ \hline
\code{true} & \code{true} & \code{false} \\ \hline
\end{tabular}
\vspace{-2em}
\end{table}

\subsubsection{\lstinline`! <bool>a : bool`}
	Оператор принимает логическую операцию "инверсия" над переменной a. Зависимость результата от исходных данных иллюстрирована в таблице \ref{distable}.
\begin{table}[htb]
\caption{Таблица истинности инверсии}
\label{distable}
\begin{tabular}{|c|c|}
\hline
\code{a} & \code{!a} \\ \hline
\code{false} & \code{true} \\ \hline
\code{true} & \code{false} \\ \hline
\end{tabular}
\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a == <bool>b : bool`}
	Возвращает \code{true} если a равно b, иначе \code{false}.
\subsubsection{\lstinline`<bool>a != <bool>b : bool`}
	Возвращает \code{true} если a равно b, иначе \code{false}.

\subsection{{\color{bluemarin}int} и {\color{bluemarin}double}}

	Для чисел доступны операций:
\begin{icItems}
	\item 3-ого ранга:
		\begin{icItems}
			\item равно \lstinline`int == int : bool` и \lstinline`double == double : bool`
			\item не равно \lstinline`int != int : bool` и \lstinline`double != double : bool`
			\item больше \lstinline`int >> int : bool` и \lstinline`double >> double : bool`
			\item больше или равно \lstinline`int >= int : bool` и \lstinline`double >= double : bool`
			\item меньше \lstinline`int << int : bool` и \lstinline`double << double : bool`
			\item меньше или равно \lstinline`int <= int : bool` и \lstinline`double <= double : bool`
		\end{icItems}
	\item 4-ого ранга:
		\begin{icItems}
			\item сложение \lstinline`int + int : int` и \lstinline`double + double : double`;
			\item вычитание \lstinline`int -    int : int` и \lstinline`double -    double : double`.
		\end{icItems}
	\item 5-ого ранга:
		\begin{icItems}
			\item умножение \lstinline`int * int : int` и \lstinline`double * double : double`;
			\item деление \lstinline`int / int : int` и \lstinline`double / double : double`;
			\item остаток от деления целых чисел \lstinline`int \ int : int`.
		\end{icItems}
	\item 6$^+$-ого ранга:
		\begin{icItems}
			\item возведения в квадрат \lstinline`int** : int` и \lstinline`double** : double`;
			\item возведения в степень \lstinline`int ** int : int` и \lstinline`double ** double : double`;
			\item извлечения квадратного корня \lstinline`/'int : int` и \lstinline`/'double : double`;
			\item извлечения корня \lstinline`int/'int : int` и \lstinline`double/'double : double`.
		\end{icItems}
	\item 7$^+$-ого ранга:
		\begin{icItems}
			\item инверсия знака \lstinline`-int : int` и \lstinline`-double : double`;
			\item абсолютное значение \lstinline`+int : int` и \lstinline`+double : double`.
		\end{icItems}
\end{icItems}

	Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{numberopex}.
	
\begin{lstlisting}[caption=Примеры использования операторов над данными типа int и double, label=numberopex]
`` 3rd rank
_log:out "2 == 3 = "		2 == 3;		`` 2 = 3 = false
_log:out "2.5 == 2.5 = "	2.5 == 2.5;	`` 2.5 = 2.5 = true
_log:out "1 != 2 = "		1 != 2;		`` 1 $\neq$ 2 = true
_log:out "2.1 != 2.1 = "	2.1 != 2.1;	`` 2.1 $\neq$ 2.1 = false
_log:out "3 >> 2 = "		3 >> 2;		`` 3 > 2 = true
_log:out "1.1 >> 2.1 = "	1.1 >> 2.1;	`` 1.1 > 2.1 = false
_log:out "5 >= 2 = "		5 >= 2;		`` 5 $\geq$ 2 = true
_log:out "5.1 >= 2 = "		5.1 >= 2;	`` 5.1 $\geq$ 2 = true
_log:out "3 << 9 = "		3 << 9;		`` 3 < 9 = true
_log:out "6.1 << 6.2 = "	6.1 << 6.2;	`` 6.1 < 6.2 = true
_log:out "4 <= 5 = "		4 <= 5;		`` 4 $\leq$ 5 = true
_log:out "5.6 <= 6.5 = "	5.6 <= 6.5;	`` 5.6 $\leq$ 6.5 = true
`` 4th rank
_log:out "2 + 3 = "			2 + 3;		`` 2 + 3 = 5
_log:out "2.1 + 1.1 = "		2.1 + 1.1;	`` 2.1 + 1.1 = 3.2
_log:out "4 - 5 = "			4 - 5;		`` 4 - 5 = -1
_log:out "4.5 - 3.4 = "		4.5 - 3.4;	`` 4.5 - 3.4 = 1.1
`` 5th rank
_log:out "2 * 3 = "			2 * 3;		`` 2 $\cdot$ 3 = 6
_log:out "2.1 * 5.7 = "		2.1 * 5.7;	`` 2.1 $\cdot$ 5.7 = 11.97
_log:out "5 / 7 = "			5 / 7;		`` 5 $\div$ 7 = 0.7142857142857
_log:out "5.0 / 7.1 = "		5.0 / 7.1;	`` 5.0 $\div$ 7.1 = 0.7042253521126
_log:out "45 \ 8 = "		45 \ 8;		`` 45 \textbackslash 8 = 5
`` 6+th rank
_log:out "25** = "			25**;		`` $25^2$ = 625
_log:out "25.1** = "		25.1**;		`` $25.1^2$ = 630,01
_log:out "34 ** 3 = "		34 ** 3;	`` $34^3$ = 39304
_log:out "2.0 ** 1.5 = "	2.0 ** 1.5;	`` $2.0^{1.5}$ = 2.8284271247461
_log:out "/'25 = "			/'25;		`` $\sqrt{25}$ = 5
_log:out "/'125.7 = "		/'125.7;	`` $\sqrt{125.7}$ = 11.211601134539
_log:out "3/'27 = "			3/'27;		`` $\sqrt[3]{27}$ = 3
_log:out "5.0/'125.5 = "	5.0/'125.5;	`` $\sqrt[5.0]{125.5}$ = 2.6286256727378
`` 7+th rank
_log:out "- 35 = "			- 35;		`` - 35 = -35
_log:out "- -56.7 = "		- -56.7;	`` - -56.7 = 56.7
_log:out "+ -100 = "		+ -100;		`` + -100 = 100
_log:out "+ 89.7 = "		+ 89.7;		`` + 89.7 = 89.7
\end{lstlisting}

	{\bf Внимание:} несмотря на то что пробелы в icL игнорируются, они влияют на восприятии кода, \code{-23-4} будет восприниматься как \lstinline`(-23) (-4)` а не как \lstinline`(-23) - (4)`. Недоразумение между человеком и машиной решается добавлением пробелов \lstinline`-23  - 4`.

\subsubsection{\lstinline`<int>a == <int>b : bool`}
	Возвращает \code{true} если \code{a} и \code{b} имеют одинаковое значение, иначе \code{false}.

\subsubsection{\lstinline`<double>a == <double>b : bool`}
	Возвращает \code{true} если \code{a} и \code{b} отличаются довольно мало (например на 10$^{-15}$), иначе \code{false}.

\subsubsection{\lstinline`<int>a != <int>b : bool`}
	Возвращает \code{true} если \code{a} и \code{b} не имеют одинаковое значение, иначе \code{false}.

\subsubsection{\lstinline`<double>a != <double>b : bool`}
	Возвращает \code{true} если \code{a} и \code{b} отличаются больше чем на уровень погрешности машины, иначе \code{false}.

\subsubsection{\lstinline`<int>a >> <int>b : bool`}
	Возвращает \code{true} если целое число \code{a} больше \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<double>a >> <double>b : bool`}
	Возвращает \code{true} если дробное число \code{a} больше \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<int>a >= <int>b : bool`}
	Возвращает \code{true} если целое число \code{a} больше или равно \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<double>a >= <double>b : bool`}
	Возвращает \code{true} если дробное число \code{a} больше или равно \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<int>a << <int>b : bool`}
	Возвращает \code{true} если целое число \code{a} меньше \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<double>a << <double>b : bool`}
	Возвращает \code{true} если дробное число \code{a} меньше \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<int>a <= <int>b : bool`}
	Возвращает \code{true} если целое число \code{a} меньше или равно \code{b}, иначе \code{false}.

\subsubsection{\lstinline`<double>a <= <double>b : bool`}
	Возвращает \code{true} если дробное число \code{a} меньше или равно \code{b}, иначе \code{false}.


\subsubsection{\lstinline`<int>a + <int>b : int`}
	Возвращает сумму целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a + <double>b : double`}
	Возвращает сумму дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a - <int>b : int`}
	Возвращает разницу между целыми числами \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a - <double>b : double`}
	Возвращает разницу между дробными числами \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a * <int>b : int`}
	Возвращает результат умножения целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a * <double>b : double`}
	Возвращает результат умножения дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a / <int>b : int`}
	Возвращает результат деления целых чисел \code{a} и \code{b}, остаток отбрасывается.

\subsubsection{\lstinline`<double>a / <double>b : double`}
	Возвращает результат деления дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a \ <int>b : int`}
	Возвращает результат от деления целых чисел \code{a} и \code{b}.


\subsubsection{\lstinline`<int>a ** : int`}
	Возвращает квадрат целого числа \code{a} (a$^2$);

\subsubsection{\lstinline`<double>a ** : double`}
	Возвращает квадрат дробного числа \code{a} (a$^2$);

\subsubsection{\lstinline`<int>a ** <int>b : int`}
	Возвращает результат возведения целого числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`<double>a ** <double>b : double`}
	Возвращает результат возведения дробного числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`/' <int>a : int`}
	Возвращает корень целого числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`/' <double>a : double`}
	Возвращает корень дробного числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`<int>n /' <int>a : int`}
	Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<int>n /' <double>a : double`}
	Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<double>n /' <double>a : double`}
	Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).


\subsubsection{\lstinline`- <int>a : int`}
	Возвращает $0-a$;

\subsubsection{\lstinline`- <double>b : double`}
	Возвращает $0.0-a$;

\subsubsection{\lstinline`+ <int>a : int`}
	Возвращает абсолютное значение целого числа \code{a}.

\subsubsection{\lstinline`+ <double>a : double`}
	Возвращает абсолютное значение дробного числа \code{a}.

\subsection{{\color{bluemarin}string} и {\color{bluemarin}list}}

	Для строк и списков доступны операций:
\begin{icItems}
	\item 3-ого ранга:
		\begin{icItems}
		\item равно \lstinline`string == string : bool` и \lstinline`list == list : bool`;
		\item не равно \lstinline`string != string : bool` и \lstinline`list != list : bool`;
		\item содержит \lstinline`list << string : bool` и \lstinline`string << string : bool`;
		\item содержит строку подходящая по шаблону \lstinline`list <* string : bool`.
		\end{icItems}
	\item 4-ого ранга:
		\begin{icItems}
		\item конкатенация \lstinline`string + string : string`;
		\item вставка \lstinline`string + list : list`, \lstinline`list + string : list` и \lstinline`list + list : list`.
		\end{icItems}
	\item 5-ого ранга: шаблонное сравнение \lstinline`string * string : bool`, \lstinline`list * string : bool` и \lstinline`list * list : bool`;
	\item 6$^+$-ого ранга: эквивалентность \lstinline`string ** string : double`.
\end{icItems}

	Примеры использование операторов присутствуют на листинге \ref{stringlistopex}.

	Чтобы из несколько строк получить список, оператор вставки рекомендуется не использовать, вместо него использовать литерал:
\begin{lstlisting}[numbers=none]
[@str1 @str2 "Const string" (!func) (37.1 : string) (@bool : string) @list.Join]
\end{lstlisting}

\begin{lstlisting}[caption=Примеры использования операторов над данными типа string и list, label=stringlistopex]
"String1" == "String2";					`` false
["a" "b"] == ["a" "b"];					`` true
["a" "b"] == ["b" "a"];					`` true
["a" "b"] << "c";						`` false
"abc" << "c";							`` true
"ab" + "c";								`` "abc"
"ab" + ["c"];							`` ["ac" "c"]
["a" "b"] + "c";						`` ["a" "b" "c"]
["a" "b"] + ["c" "d"];					`` ["a" "b" "c" "d"]
"abc" * "*c";							`` true
["ac" "bc"] * "*c";						`` true
["ac" "bc"] * "a*";						`` false
["ad" "ac" "bd" "cc"] * ["*d" "*c"];	`` true
["ad" "ac" "bc" "cd"] * ["*d" "*c"];	`` false
"Tom is a cat" ** "Tom is not a cat";	`` 0.875
\end{lstlisting}

\subsubsection{\lstinline`<string>s1 == <string>s2 : bool`}
	Возвращает \code{true} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \code{false}.
	
\subsubsection{\lstinline`<list>l1 == <list>l2 : bool`}
	Возвращает \code{true} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \code{false}.

\subsubsection{\lstinline`<string>s1 != <string>s2 : bool`}
	Возвращает \code{false} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \code{true}.

\subsubsection{\lstinline`<list>l1 != <list>l2 : bool`}
	Возвращает \code{false} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \code{true}.

\subsubsection{\lstinline`<list>l << <string>str : bool`}
	Возвращает \code{true} если список \code{l} содержит строку \code{str}, иначе \code{false}.

\subsubsection{\lstinline`<string>str << <string>substr : bool`}
	Возвращает \code{true} если строка \code{str} содержит подстроку \code{substr}, иначе \code{false}.

\subsubsection{\lstinline`<list>l <* <string>template : bool`}
	Возвращает \code{true} если список \code{l} содержит хотя бы одна строка, подходящая по шаблону \code{template}, иначе \code{false}.
	
	{\bf Шаблон} - это строка содержащая данные и специальный символ \lstinline`*`, где \lstinline`*` означает любая последовательность символов. Рассмотрим шаблонную строку \lstinline`"Have a * day!"`, примеры строк подходящие по шаблону: \lstinline`"Have a nice day!"`, \lstinline`"Have a amazing day!"`. Пример неподходящей строки \lstinline`"Have a good day"` (отсутствует восклицательный знак).

\subsubsection{\lstinline`<string>s1 + <string>s2 : string`}
	Возвращает строку содержащую все символы строк \code{s1} и \code{s2}. Полученная строка имеет длину равна суммы длин составляющих.

\subsubsection{\lstinline`<string>str + <list>l : list`}
	Возвращает новый список, получен при вставке строке \code{str} в начале списка \code{l}.

\subsubsection{\lstinline`<list>l + <string>str : list`}
	Возвращает новый список, получен при вставке строке \code{str} в конце списка \code{l}.

\subsubsection{\lstinline`<list>l1 + <list>l2 : list`}
	Возвращает новый список, содержащий все элементы списков \code{l1} и \code{l2}.

\subsubsection{\lstinline`<string>str * <string>template : bool`}
	Возвращает \code{true} если строка \code{str} подходит по шаблону \code{template}, иначе \code{false}.

\subsubsection{\lstinline`<list>l * <string>template : bool`}
	Возвращает \code{true} если все строки списка \code{l} подходят по шаблону \code{template}, иначе \code{false}.

\subsubsection{\lstinline`<list>l * <list>templates : bool`}
	Возвращает \code{true} если все строки списка \code{l} подходят по соответственному шаблону из списка \code{templates}, иначе \code{false}.

\subsubsection{\lstinline`<string>s1 ** <string>s2 : double`}
	Возвращает коэффициент эквивалентности получен при сравнении \code{s1} с \code{s2}.
	
	{\bf Эквивалентность} - уровень схожести строк. \lstinline`"Hi! Robert, how do you do?"` относительно \lstinline`"Robert! Hi! How do you do?"` имеет эквивалентность равна единицы. Так как они состоят из одни и те же слова. Но если сравнивать с  \lstinline`"Rich! Hi! How are you?"` оценка снижается до 0,64.

\subsubsection{\lstinline`<list>l1 ** <list>l2 : double`}
	Возвращает коэффициент эквивалентности получен при сравнении строк из списка \code{l1} с строками из списка \code{l2}.
	Для корректности вычисления, каждая строка должна содержать одно слово.

\subsection{{\color{bluemarin}object} и {\color{bluemarin}set}}

	Для строк и списков доступны операций:
\begin{icItems}
	\item 3-ого ранга:
		\begin{icItems}
		\item равно \lstinline`object == object : bool` и \lstinline`set == set : bool`;
		\item не равно \lstinline`object != object : bool` и \lstinline`set != set : bool`;
		\item включение \lstinline`set << object : bool`;
		\item включение шаблона \lstinline`set <* object` и \lstinline`object <* object : bool`.
		\end{icItems}
	\item 4-ого ранга:
		\begin{icItems}
		\item объединение \lstinline`set + set : set`;
		\item симметрическая разность \lstinline`set -   set : set`.
		\end{icItems}
	\item 5-ого ранга:
		\begin{icItems}
		\item разность \lstinline`set \ set : set`;
		\item пересечение \lstinline`set * set : set`.
		\end{icItems}
\end{icItems}

	Примеры использование операторов присутствуют на листинге \ref{setobjopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа object и set, label=setobjopex]
`` init
@set1 = [<int>age <string>name];
@set2 = [<int>age <string>name];
@set3 = [<int>age <string>name];

@obj1 = [<24>age <"User1">name];
@obj2 = [<23>age <"User2">name];
@obj3 = [<26>age <"User3">name];
@obj4 = [<24>age <80>length <40>height <1>arc];

@set1.insert @obj1;
@set1.insert @obj2;
@set2.insert @obj3;
@set2.insert @obj2;
@set3.insert @obj2;
@set3.insert @obj1;

`` operators
@set1 == @set2;				`` false
@set1 == @set3;				`` true
@obj1 == @obj2;				`` false
@set2 != @set3;				`` true
@obj2 != @obj3;				`` true
@set1 << @obj2;				`` false
@set1 <* [<23>age];			`` true
@obj4 <* [<24>age <1>arc];	`` true
@set1 + @set2;				`` [@obj1 @obj2 @obj3]
@set1 - @set2;				`` [@obj1 @obj3]
@set1 \ @set2;				`` [@obj1]
@set1 * @set2;				`` [@obj2]
\end{lstlisting}

\subsection{\color{bluemarin}void}
	
	Все \code{void} операторы имеют 2-ой ранг. Данные операторы делят данных на 2 типа \code{void} и не \code{void}. Второй тип в дальнейшем будет отмечен как \code{any}.
	
	Список \code{void} операторов:
\begin{icItems}
	\item альтернативный выбор \lstinline`void | void : void`, \lstinline`void | any : any`, \lstinline`any | void : any` и \lstinline`any | any : any`;
	\item первичный выбор \lstinline`void & void : void`, \lstinline`any & void : void`, \lstinline`void & any : void` и \lstinline`any & any : any`;
	\item вторичный выбор \lstinline`void ~ void : void`, \lstinline`void ~ any : void`, \lstinline`any ~ void : void` и \lstinline`any ~ any : any`;
	\item исключающий выбор \lstinline`void ^ void : void`, \lstinline`void ^ any : any`, \lstinline`any ^ void : any` и \lstinline`any ^ any : void`;
	\item коллекционный выбор \lstinline`void % void : void`, \lstinline`void % any : any`, \lstinline`any % void : any`, \lstinline`int % int : int`, \lstinline`double % double : double`, \lstinline`string % string : list`, \lstinline`list % string : list`, \lstinline`object % object : set` и \lstinline`set % object : set`. Ещё одна перегрузка оператора будет объявлена в главе \ref{webelments}.
\end{icItems}

\newpage
\section{Прогресс}

{\color{red}Материал для продвинутых пользователей.}
  	
\begin{icEnum}
	\item + Введение
	\item + Базовый синтаксис
	\item + Переменные
	\item + Типы данных
	\item + Литералы
	\item - Операторы
	\item - Циклы
	\item - Условные операторы
	\item - Интеграция с Javascript
	\item - Функции
	\item - Строки
	\item - Списки
	\item - Многоженства
	\item - Объекты
	\item - Веб-элементы (симуляция мышки и клавиатуры) webelments
	\item - Обмен данных в веб-странницей (конкретные примеры) dataexchange
	\item - DSV / CSV / TSV
\end{icEnum}
  	
	{\color{red}далее материал для программистов, дополнительные возможности, просьба не читать далее материал если нету желание или необходимость.}
	
\begin{icEnumResume}
	\item - Регулярные выражения
	\item - Механизм состояний
	\item - Базы данных (только SQLite в первой версии)
	\item - Обработка ошибок
	\item - Программирование errorless
	\item - Программирование на лету
\end{icEnumResume}
	
\end{document}
