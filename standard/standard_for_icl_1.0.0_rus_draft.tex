\documentclass[a4paper, 14pt]{extarticle}

\usepackage[top=2.5cm, bottom=1.5cm, left=2cm, right=1cm]{geometry}
\usepackage{fancyvrb}
\fvset{tabsize=2}
\usepackage{polyglossia}
\setmainlanguage{russian}
\setotherlanguage{english}
\usepackage[htt]{hyphenat}
\usepackage{setspace}
\usepackage[hidelinks]{hyperref}

\setmainfont{Liberation Serif}
\newfontfamily\cyrillicfont{Liberation Serif}
\let\cyrillicfonttt\ttfamily
\setmonofont{Liberation Mono}
\setsansfont{Liberation Sans}
\newfontfamily\cyrillicfontmono{Liberation Mono}
\newfontfamily\cyrillicfontsans{Liberation Sans}
\newfontfamily\cyrillicfonttt{Liberation Mono}
\newfontfamily\cyrillicfontsf{Liberation Serif}

\usepackage{longtable}
\usepackage{ragged2e}
\setcounter{tocdepth}{2}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage{fancyhdr}
\usepackage{lastpage}

\usepackage[singlelinecheck=false]{caption}
\usepackage{listings, lstautogobble}
\usepackage{color}
\usepackage[table]{xcolor}

\usepackage{caption}
\DeclareCaptionFont{black}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{codeheaderbg}
	{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]
	{format=listing,labelfont=black,textfont=black}

\usepackage{enumitem}

\lstdefinestyle{framed}
{
     frame=none,
     belowcaptionskip=2pt,
     xleftmargin=8pt,
     framexleftmargin=7pt,
     framexrightmargin=5pt,
     framextopmargin=10pt,
     framexbottommargin=5pt,
     framesep=0pt,
     rulesep=0pt,
     texcl=true
}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\definecolor{codebg}{rgb}{0.97, 0.97, 0.97}
\definecolor{codeheaderbg}{rgb}{0.90, 0.90, 0.90}
\definecolor{orange}{rgb}{0.8, 0.4, 0.0}
\definecolor{lightblue}{RGB}{12, 134, 145}
\definecolor{grey}{rgb}{0.5, 0.5, 0.5}
\definecolor{function}{RGB}{11, 145, 89}
\definecolor{blue2}{RGB}{15, 92, 198}

\usepackage{soul}

\newcommand{\ferror}[1]{\foreignlanguage{english}{\fontsize{11pt}{12pt}\tt{\sethlcolor{yellow}\hl{#1}}}}

% \colorbox{function}{\textcolor{white}{#1}}

\newcommand{\cerror}[1]{{\fontsize{11pt}{12pt} \tt \colorbox{red!75!blue}{\textcolor{white}{#1}}}}

\lstdefinelanguage{icL}{
	keywords={if, else, for, filter, range, exists, while, do, any,emit, emiter, slot, @, \#, reverse, jammer, SELECT, FROM, WHERE, LIMIT, INSERT, INTO, VALUE},
	keywordstyle=\color{blue2},
	keywords=[2]{bool, int, double, string, list, element, set, item, object, function, void, request, char, regex},
	keywordstyle=[2]\color{lightblue},
	classoffset=3,
	morekeywords={_icL, _log, _define, _tab, _dom, _define, _import, true, false, _numbers, _types, _key, _alert, _by, _dsv, _sessions, _session, _windows, _window, _cookies, _cookie, _tabs, _tab, _files, _file, _make, _math, _wait, _mouse, _move, _stacks, _stack, _states, _db, _query, _dbManager, _code, _signal},
	keywordstyle=\color{orange},
	classoffset=4,
	morekeywords={info, warm, error, signal, at, query, queryAll, null, prepend, append, insert, merge, popFront, popBack, remove, removeOnce, removeAll, get, indexOf, lastIndexOf, join, sumUp, max, min, logicAnd, logicOr, length, text, html, width, height, click, scrollTo, sendKeys, isValid, copy, add, filter, query, queryAll, visible, clickable, next, prev, parent, child, closest, addClass, hasClass, removeClass, all, functions, none, run, close, process, setProcess, restoreProcess, product, sum, min, max, empty, out, typeName, typeId, rValue, lValue, readOnly, link, last, ensureRValue, split, right, replace, mid, leftJustified, rightJustified, left, right, endsWith, beginsWith, count, compare, substring, trim, contains, clear, move, removeAt, removeDuplicates, removeFirst, removeLast, removeOne, replaceInStrings, sort, capacity, applicate, getField, insertBoolField, insertIntField, insertDoubleField, insertListField, insertStringField, removeField, attr, css, enabled, prop, rect, selected, tag, queryAllByXPath, queryByXPath, queryLink, queryLinks, queryTags, queryTag, screenshot, ctrl, shift, alt, title, source, url, back, forward, refresh, canGoBack, canGoForward, accept, dismiss, childNodes, firstChild, innerText, isConnected, lastChild, nodeName, nodeType, nodeValue, parentElement, textContent, className, clientHeight, clientLeft,  clientTop, clientWidth, computedName, computedRole, id, innerHTML, localName, nextElementSibling, outerHTML, prefix, previousElementSibling, scrollHeight, scrollLeft, scrollTop, scrollWidth, tagName, baseURI, accessKey, accessKeyLabel, contentEditable, isContentEditable, dataset, dir, draggable, hidden, inert, lang, offsetHeight, offsetLeft, offsetParent, offsetTop, offsetWidth, spellcheck, download, hash, host, hostname, href, hreflang, media, password, origin, pathname, port, protocol, rel, search, target, type, username, coords, autofocus, disabled, form, formAction, formEnctype, formMethod, formNoValidate, formTarget, labels, name, value, willValidate, options, elements, action, encoding, enctype, acceptCharset, autocomplete, noValidate, allowPaymentRequest, complete, crossOrigin, isMap, naturalHeight, naturalWidth, src, useMap, checked, defaultChecked, defaultValue, dirName, indeterminate, maxLength, multiple, pattern, placeholder, required, selectionStart, selectionEnd, selectionDirection, size, step, validity, validationMessage, valueAsNumber, control, htmlFor, as, areas, autoplay, controls, currentSrc, currentTime, defaultMuted, defaultPlaybackRate, disableRemotePlayback, duration, ended, loop, mediaGroup, muted, networkState, paused, playbackRate, preload, readyState, seeking, volume, content, httpEquiv, high, low, cite, reversed, start, defaultSelected, index, label, position, charset, async, defer, noModule, selectedIndex, selectedOptions, abbr, cellIndex, colSpan, rowSpan, scope, span, caption, tBodies, tHead, tFoot, cells, rowIndex, cols, textLength, wrap, dateTime, kind, srclang, label, default, poster, videoHeight, videoWidth, cssSelector, linkText, partialLinkText, xPath, load, loadCSV, loadTSV, write, sync, closeAll, new, implicitTimeout, pageLoadTimeout, scriptTimeout, switchTo, x, y, focus, fullscreen, maximize, minimize, switchToDefault, switchToFrame, switchToParent, deleteAll, domain, expiry, httpOnly, path, secure, save, current, first, previous, closeByTitle, closeToLeft, closeToRight, closeOthers, open, create, createDir, createPath, csv, tsv, format, valid, delete, image, stack, state, 1divPi, 1divSqrtPi, 2divPi, 2divSqrtPi, e, ln2, ln10, log2e, log10e, pi, piDiv2, piDiv4, sqrt2, degreesToRadians, radiansToDegrees, acos, asin, atan, ceil, cos, exp, floor, ln, round, sin, tan, restore, resetTime, ajax, template, expression, timeout, toBe, present, interactable, keyDown, keyUp, keyPress, paste, fastType, mouseDown, mouseUp, hover, middle, rx, ry, ax, ay, delay, time, func, teleport, linear, quadratic, cubic, bezier, p1x, p1y, p2x, p2y, clickTime, pressTime, moveTime, flashMode, humanMode, ifexists, dowhile, forany, continue, break, newAtEnd, toNext, toPrev, toFirst, toLast, find, findByTitle, openSQLite, exec, getRowsAffected, getError, getLength, seek, forname, programmers, country, person, artists},
	keywordstyle=\color{function},
	classoffset=5,
	morekeywords={UnrealCast, StringParse, EmptyList, MultipleValues, NullElement, NotVisible,  WrongName, OutOfBounds, OutOfScreen, FileNotFound, icL, w3c},
	keywordstyle=\color{red},
	classoffset=0,
	identifierstyle=\color{black},
	sensitive=true,
	comment=[l]{``},
	morecomment=[s]{```}{```},
	morecomment=[s]{`c}{t`},
	commentstyle=\color{grey},
	stringstyle=\color{purple},
	morestring=[b]",
	morestring=[b]//
}

\let\counterwithout\relax
\let\counterwithin\relax
\usepackage{chngcntr}

\newenvironment{icItems}
	{ \begin{itemize} [noitemsep,nolistsep] }
	{ \end{itemize} }

\newenvironment{icEnumResume}
	{ \begin{enumerate}[noitemsep,nolistsep,resume] }
	{ \end{enumerate} }

\newenvironment{icEnum}
	{ \begin{enumerate}[noitemsep,nolistsep] }
	{ \end{enumerate} }

\begin{document}

%\renewcommand{\rmdefault}{ftm}
\counterwithin{lstlisting}{section}
\counterwithin{table}{section}

\renewcommand{\lstlistingname}{Листинг}

\setlength\abovecaptionskip{2pt}
\setlength\belowcaptionskip{1pt}

\pagestyle{fancy}
%\fancyhead[]{}
%\fancyhead[C]{12603 - 01 xx 01}
%\renewcommand{\headrulewidth}{0pt}
\fancyfoot[C]{\thepage{} из \pageref{LastPage}}

\lstset{
	language=icL,
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	showtabs=false,
	numbers=left,
	stepnumber=1,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=true,
	backgroundcolor=\color{codebg},
	style=framed,
	lineskip=0pt,
	aboveskip=0pt,
	autogobble=true
}

\setlength{\LTleft}{0pt}
\onehalfspacing

\newcommand{\greycell}[1]{\cellcolor{lightgray}\centering\textbf{#1}}

\newcommand{\code}[1]{ \lstinline|#1| }
\newcommand{\true}{\lstinline|true|}
\newcommand{\false}{\lstinline|false|}
\newcommand{\bool}{\lstinline|bool|}
\newcommand{\integer}{\lstinline|int|}
\newcommand{\double}{\lstinline|double|}
\newcommand{\str}{\lstinline|string|}
\newcommand{\listtype}{\lstinline|list|}
\newcommand{\element}{\lstinline|element|}
\newcommand{\set}{\lstinline|set|}
\newcommand{\setitem}{\lstinline|item|}
\newcommand{\object}{\lstinline|object|}
\newcommand{\function}{\lstinline|function|}
\newcommand{\void}{\lstinline|void|}
\newcommand{\request}{\lstinline|request|}
\newcommand{\chartype}{\lstinline|char|}
\newcommand{\regex}{\lstinline|regex|}
% \newcommand{}{ \lstinline|| }

\newcommand{\sessions}{\lstinline|_sessions|}
\newcommand{\session}{\lstinline|_session|}
\newcommand{\windows}{\lstinline|_windows|}
\newcommand{\window}{\lstinline|_window|}
\newcommand{\cookies}{\lstinline|_cookies|}
\newcommand{\cookie}{\lstinline|_cookie|}
\newcommand{\alert}{\lstinline|_alert|}
\newcommand{\tabs}{\lstinline|_tabs|}
\newcommand{\tab}{\lstinline|_tab|}
\newcommand{\dom}{\lstinline|_dom|}
\newcommand{\files}{\lstinline|_files|}
\newcommand{\file}{\lstinline|_file|}
\newcommand{\make}{\lstinline|_make|}
\newcommand{\logtype}{\lstinline|_log|}
\newcommand{\numbers}{\lstinline|_numbers|}

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\tabletwo}[7]{
	\begin{longtable}[h]{|p{#1}|p{#2}|}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, label, name,
% row1 name, row2 name, body
\newcommand{\stabletwo}[7]{
	\begin{longtable}[h]{|p{#1}|p{#2}|}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endfirsthead

	\multicolumn{2}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#5}} &
	\multicolumn{1}{p{#2}|}{\greycell{#6}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#7
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\tablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{1}} &
	\multicolumn{1}{p{#2}|}{\greycell{2}} &
	\multicolumn{1}{p{#3}|}{\greycell{3}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% row1 width, row2 width, row3 width, label, name,
% row1 name, row2 name, row3 name, body
\newcommand{\stablethree}[9]{
	\begin{longtable}[h]{|p{#1}|p{#2}|p{#3}|}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	\hline
	\multicolumn{1}{|p{#1}|}{\greycell{#6}} &
	\multicolumn{1}{p{#2}|}{\greycell{#7}} &
	\multicolumn{1}{p{#3}|}{\greycell{#8}} \\
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#9
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\tableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #5} \label{#4} \\

	\hline
	#2
	#3
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #5}} \\
	#3
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#6
	\end{longtable}
}

% rows, header, repeated, label, name, body
\newcommand{\stableuni}[6]{
	\begin{longtable}[h]{#1}
	\caption*{Таблица \thetable{}: #4} \label{#3} \\

	\hline
	#2
	\hline
	\endfirsthead

	\multicolumn{3}{l}%
	{{Продолжение таблицы \thetable{}: #4}} \\
	\hline
	#2
	\hline
	\endhead

	\hline
	\endfoot

	\hline
	\endlastfoot
#5
	\end{longtable}
}

% Содержимое докимента
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Стандарт языка описания сценариев icL v1.0.0 Черновик}
\author{Лелицак Василе}

\maketitle

\newpage
\renewcommand{\contentsname}{\textsf{Оглавление}}
\tableofcontents

%\newpage

\section{Введение}

\indent \textbf{icL} - \textbf{язык описания сценариев}, оптимизирован под описания сценариев тестирования веб-приложений.

\subsection{Читатели}

Этот документ предназначен для всех тех людей, которые ищут отравную точку, откуда можно начать изучать язык icL. Также данный документ используется при разработке интерпретатора, поведения командного процессора во всех ситуациях неописанных в данном документе считается неопределённой.

Чувствуете себя свободным в указаниях на ошибках и представления новых идей и точек зрения, жду ваших письмах по адресу lixcode@vivaldi.net.

\subsection{Что вы должны уметь}

Прежде чем выступать к изучению этого языка, вам желательно иметь базовое представление о компьютерном программировании.

\subsection{Обзор языка icL}

icL - язык сценариев тестирования веб-приложений. Его разработка началась в году, и первый выпуск планируется к 2020 году. В настоящий момент он находится в активной разработке.

icL - \textbf{язык с С-подобным синтаксисом}, который использует статическую типизацию. В icL нельзя определить собственные типы данных, так как он разработан не для программистов, знания получены в школе на уроках информатики должны быть достаточны. Язык icL поддерживает только одну парадигму программирования - процедурная. При необходимости обработать данные, можно использовать экспорт/импорт в/из cvs и базы данных.

\subsection{Пример кода}

В icL точка входа в программе - начало файла, программа \textit{Hello world!} иллюстрирована на листинге \ref{example0}.

\begin{lstlisting}[caption=Пример, label=example0]
`` comment example
_log.info "Hello world";
\end{lstlisting}

\subsection{Изучение icL}

Самое важное при изучении icL - это сосредоточиться на идеях и не потеряться в технических деталях его реализации.

\subsection{Области применения icL}

Язык icL является частью \textbf{программы icL}, с его помощью можно управлять браузером, а именно:
\begin{icItems}
\item
	открыть вкладку;
\item
	закрыть вкладку;
\item
	перейти на веб-страницу;
\item
	симулировать события клавиатуры и мышке;
\item
	взаимодействовать с веб-страницей;
\item
	выполнить код на языке javascript;
\item
	управлять веб-страницей;
\item
	обменять информацию с веб-страничкой;
\item
	сделать screenshot;
\item
	управлять памятью;
\item
	экспортировать данные в csv файле;
\item
	импортировать данные из csv файл;
\item
	выполнить запросы на языке SQL.
\end{icItems}

\subsection{Начало работы}

Чтобы начать работать достаточно установить и запустить программу icL.

\newpage
\part{Материал для продвинутых пользователях}

Данная часть предназначено для основных принципов построения языка icL. Рассчитана она на продвинутых пользователях с минимальных знания программирования.

\section{Базовый синтаксис}

icL достаточно прост в освоении, вставите код с листинга \ref{first} в icL и выполняете его. Первую программу можно уже сохранить в файле с расширением icl.

\begin{lstlisting}[caption=Первая программа, label=first]
_log.info "Test!";
\end{lstlisting}

В консоль можем увидеть следующий \textbf{вывод программы}:

\begin{lstlisting}[numbers=none]
Test!
\end{lstlisting}

\subsection{Импорт в icL}

Все \textbf{стандартные библиотеки} встроены в языке, но можно написать импортировать \textbf{пользовательские}, с помощью:

\begin{icItems}
\item
	\lstinline|_import.none "path/to/file.iclib"| - выполнить код, который содержатся в файле, ничего не импортировать.
\item
	\lstinline|_import.functions "path/to/file.iclib"| - выполнить код и импортировать функций; {\color{red}Важно:} импортированные функций не должны использовать глобальные переменные.
\item
	\lstinline|_import.all "path/to/file.iclib"| -  выполнить код, импортировать функций и глобальные переменные;
\item
	\lstinline|_import.run "path/to/file.iclib"| - выполнить код в текущем контексте, все функции и глобальные переменные импортируется и экспортируется;
\end{icItems}

\subsection{Токены в icL}

Программа на icL состоит из различных \textbf{токенов} (литералов, семантических конструкциях), а токен может являться ключевым словом, идентификатором, константной, строковым литералом, либо символом. Например следующая команда состоит из четырёх токенов: \lstinline`_log.info "Hello world!";`

Отдельными токенами являются:

\begin{icItems}
\item
	\lstinline`_log` - идентификатор объекта;
\item
	\lstinline`.info` - идентификатор метода;
\item
	\lstinline`"Hello world!"` - строковый литерал;
\item
	\lstinline`;` - разделитель, конец команды.
\end{icItems}

\subsection{Комментарии}

\textbf{Комментарии} - это вспомогательный текст, который помогает понимать написанных сценариях, они полностью игнорируется командного процессора.

\textbf{Комментарии в линии} (\textit{inline}) являются строковым литералом ограниченным специальными кавычками \texttt{`}, как показано на листинге \ref{inlinecomment}.

\begin{lstlisting}[caption=Комментарий в линии,label=inlinecomment]
No comment `comment` no comment
\end{lstlisting}

\textbf{Одиночный комментарий} записывается с использованием символов \texttt{``} в начале, смотрите листинг \ref{linecomment}.

\begin{lstlisting}[caption=Одиночный комментарий,label=linecomment]
No comment `` comment
\end{lstlisting}

\textbf{Многострочный комментарий} начинается и заканчивается с \texttt{```}, пример многострочного комментария приведён на листинге \ref{multilinecomment}.

\begin{lstlisting}[caption=Многострочный комментарий,label=multilinecomment]
No comment
``` comment 1
	comment 2
	comment 3
``` No comment
\end{lstlisting}

\subsection{Идентификторы}

\textbf{Идентификатор} в icL - это имя, используемое для идентификации переменной, функций, методов и свойств. Идентификатор начинается с символов обозначающий его предназначение(\lstinline`@`, \lstinline`#`, \lstinline`!`, \lstinline`_`, \lstinline`.` или \lstinline`'`), за которым следует от 1 до 32 букв(английского или национального алфавита) и цифр (от 0 до 9).

icL - чувствительный к регистру язык. Таким образом \textit{@var} и \textit{@Var} являются двумя разными идентификаторами. Вот несколько примеров допустимых идентификаторов:

\begin{lstlisting}[numbers=none]
#loop		_tab		.Append		'Length	_dom	@i	 	@VAR
@variable	!sumPoints	#global		.Merge	.Get	#01		!SIN
\end{lstlisting}

\subsection{Ключевые слова}

В icL \textbf{ключевые слова} не зарезервированные. Их всего 14: \lstinline`if`, \lstinline|else| \lstinline`for`, \lstinline`filter`, \lstinline`range`, \lstinline`exists`, \lstinline`while`, \lstinline`do`, \lstinline`any`, \lstinline`emit`, \lstinline`emiter`, \lstinline`slot`, \lstinline|jammer| и \lstinline|reverse|. В данном документе они выделены синим цветом.

\subsection{Пробельные символы и разделители}

\textbf{Пробельный символ} (\textit{whitespace}) - этот термин используется в icL для описания пробелов, символов табуляции, символов новой строкой и комментариев. Пробельные символы не обязательные, они используются для улучшения читабельности кода. На листинге \ref{unreadable} показан пример кода без пробельных символов, а на листинге \ref{readable} с пробельными символами.

\begin{lstlisting}[caption=Koд без пробельных символов,label=unreadable]
if(_tab.get"mai.ru"){(_dom.query"button").click;}else{_log.error"The site mai.ru is unaviable";};
\end{lstlisting}

\begin{lstlisting}[caption=Koд с пробельных символов,label=readable]
`` the begin of program

`` try to go to mai.ru
if (_tab.get "mai.ru") {
	`` site loaded successfull
	`` click the button
	(_dom.query "button").click;
}
else {
	`` try again later
	`` now log the error
	_log.error "The site mai.ru is unaviable";
};

`` end of the program
\end{lstlisting}

В icL присутствует только один разделитель - \textbf{разделитель команд} \lstinline`;`. Команда - это набор токенов, распределенных в определённом порядке и характеризующее действие. Примеры команд: открыть сайт - \lstinline`_tab.get "URL"`, закрыть вкладку - \lstinline`_tab.close`.

При описании последовательности действий, их надо разделить, например последовательность вышеперечисленных команд описывается так:

\begin{lstlisting}[numbers=none]
_tab.get "URL"; _tab.close
\end{lstlisting}

Таким образом из команд собираем сценарии. Перед закрывающих скобок ставить разделитель команд опционально.

\subsubsection{Дополнительные сведение}

Если у вас нет знании в программировании перейдите, пожалуйста, на третью главу.

icL отсутствуют разделители между значениями в списке. Примеры:

\begin{icItems}
	\item Инициализация списка в С++:
\begin{lstlisting}[numbers=none, language=C++]
std::list<std::string> list = {"one", "two", "three"};
\end{lstlisting}
	Инициализация списка в icL:
\begin{lstlisting}[numbers=none]
@list = ["one" "two" "three"];
\end{lstlisting}
	\item Функция в С++:
\begin{lstlisting}[numbers=none, language=C++]
int sum (int number1, int number2) { return number1 + number2; };
\end{lstlisting}
	Функция в icL:
\begin{lstlisting}[numbers=none]
!sum = <int>number1 <int>number2 : int { @ = number1 + number2 };
\end{lstlisting}
	\item Вызов функций в С++:
\begin{lstlisting}[numbers=none, language=C++]
int s = sum (100, 200);
\end{lstlisting}
	Вызов функций в icL:
\begin{lstlisting}[numbers=none]
@sum = !sum 100 200;
\end{lstlisting}
	\item Код на С++:
\begin{lstlisting}[numbers=none, language=C++]
sum (100 + 50, 200);
\end{lstlisting}
	Эквивалент на icL:
\begin{lstlisting}[numbers=none]
!sum (100 + 50) 200;
\end{lstlisting}
\end{icItems}

%\newpage
\section{Переменные}

\textbf{Переменная} - название области хранения, который могут манипулировать сценария. Каждая переменная в icL имеет область видимость (фрагмент кода где можно её использовать) и тип, который определяет размер и способ размещения памяти переменной; диапазон значений можно применить к переменной.

Имя переменной является идентификатором, начинающийся с \lstinline`@` или {\color{blue2}\lstinline`#`}.
\textbf{Основные типы} переменных показаны в таблице \ref{variablestypes}.

\stabletwo{2cm}{15.1cm}{variablestypes}{Типы переменных}%
{Тип}{Описание}%
{
	bool   & Логическое значения, имеет в состояние: истинно или лож. 					 \\ \hline
	int    & Целое число, позволяет хранить значения от -2.147.483.648 до 2.147.483.647. \\ \hline
	double & Дробное число, позволяет хранить вещественные числа. 						 \\
}

icL также присутствуют и \textbf{сложные типы} переменных, такие как строки, списки, множества, объекты, которые мы посмотрим в полеживающих главах. В этой главе изучаем только основные типы.

\subsection{Объявления и инициализация переменных}

\textbf{Объявления и инициализация} переменных, также операция \textit{присваивание} в icL неотличимы, и имеют общий вид \lstinline`a = b`, где \lstinline`a` новая или существующая переменная, а \lstinline`b` - значение. В тех случаев когда переменная \textbf{встречается первый раз}, мы её объявляем и инициализируем. В противном случае мы присваиваем ей значение.

На листинге \ref{initexample} показаны несколько пример объявлений и инициализации переменных, обратите внимание что дробные числа пишется через точку, а не через запятую как принято в Европе и Российском Федераций.

\begin{lstlisting}[caption=Пример объявлений и инициализации переменных,label=initexample]
@bool = false;
@catched = true;
@int = 234;
@double = 23.4;
#pi = 3.14;
#negative = -100.0;
\end{lstlisting}

\subsection{Локальные переменные}

\textbf{Локальные переменные} имею узкую область видимость, ограниченные фигурными скобками которые их охватывает, и только после их объявлений.

{\bf Идентификаторы} локальных переменных начинается с символом \lstinline`@`.

На листинге \ref{localvars} показана область видимость переменной \lstinline`@var`, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test6` - она не видна, когда в точках объявления переменных \lstinline`@test3`, \lstinline`@test4` и \lstinline`@test5` - да.
\begin{lstlisting}[caption=Область видимости локальных перемен, label=localvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var;
	`` initialization
	@var = 0;
	`` ok
	@test3 = @var;
	if (@) {
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var;
}
`` error
@test6 = @var;
\end{lstlisting}

\subsection{Глобальные переменные}

\textbf{Глобальные переменные} имеют самую широкую область видимости, их видны из любой точке программы после их инициализации. Использовать глобальные переменные не рекомендуется, так как они могут привести к серьезных ошибок.

{\bf Идентификаторы} глобальных переменных начинается с символом {\color{blue2}\lstinline`#`}. Локальные переменные с одинаковым названием могут быть несколько, когда глобальные - нет. Идентификатор глобальной переменной - уникальный.

Как указано на листинге \ref{globalvars}, в точках объявления переменных \lstinline`@test1`, \lstinline`@test2` и \lstinline`@test3` переменная \lstinline`@var` не видна, когда в точках объявления переменных \lstinline`@test4`, \lstinline`@test5` и \lstinline`@test6` - да.

\begin{lstlisting}[caption=Область видимости глобальных перемен, label=globalvars]
`` error
@test1 = @var;
if (@) {
	`` error
	@test2 = @var;
	if (@) {
		`` error
		@test3 = @var;
		`` initialization
		@var = 0;
		`` ok
		@test4 = @var;
	}
	`` ok
	@test5 = @var;
}
`` ok
@test6 = @var;
\end{lstlisting}

\subsection{Левые и правые значения в icL}

В icL присутствуют 3 типа значении:

\begin{icEnum}
\item
	левые значения {\it lvalue} - переменные;
\item
	правые значения {\it rvalue} - переменные и константы;
\item
	javascript значения {\it jsvalue} - их будем рассматривать позже.
\end{icEnum}

Левые значения могут находиться с обеих сторон знака {\it присваивание}, когда правые - только справа. Примеры правильно и неправильно кода иллюстрированы на листинге \ref{rlvalues};

\begin{lstlisting}[caption=Левые и правые значения, label=rlvalues]
@a1 = @a2; @a3 = 123; `` ok
123 = @a1; 125 = 456; `` error
\end{lstlisting}

\subsection{Выводы}

{\bf Работа с переменными в icL} - максимально проста, но продвинутых пользователях без знания в программировании рекомендуется не использовать глобальные переменные. Для написания сценариев средней и низкой сложности, локальные переменные лучше подходят.

\section{Типы данных}

В языке описания сценариев icL, типы данных выполняют очень важную роль, они определяют как данные и будут храниться, обработаться в процессе выполнения программы. Классификация типов данных представлена в таблице \ref{datatypeclasses}.

\stabletwo{3.5cm}{13.6cm}
{datatypeclasses}{Категории типов данных}
{Категория}{Описание}
{
	Базовые     & Типы данных описанных в предыдущем главе: \bool{}{} - логический, \integer{} - целое - числа, \double{} - дробные числа. \\ \hline
	Сложные     & Типы данные содержащие несколько значений в контейнерах, примеры таких данных: строки, списки, множество. \\ \hline
	Системные   & Типы данных которых нельзя создать и хранить в пользовательских переменных, но доступ к ними можно получить через системные (предопределённых) переменных, примеры таких данных: браузер, вкладка, история браузера, окно. \\ \hline
	Тип \void{} & Тип данных обозначающий отсутствия данных.
}

\subsection{Основные типы данных}

{\bf Основные типы данных} участвуют в логических и арифметических операциях языка icL. Логическими операциями являются конъюнкция, дизъюнкция, исключающий или, эквиваленция и инверсия. Арифметическими операциями являются сложения, вычитания, умножения, деления, извлечения корня и возведения в степень.

\subsection{Сложные типы данных}

{\bf Сложные типы данных} специализированные под хранения больших массивов данных. Строка позволяет хранить более двух миллиардов символов. Список позволяет хранить более двух миллиардов строк. А множество позволяет хранить большой объём данных ограничен только оперативной памяти. Объект позволяет инкапсулировать данные разного рода по одном именем. Элемент позволяет хранить ссылку на один или несколько HTML-тэгов.

\subsection{Системные типы данных}

{\bf Системные типы данных} позволяют взаимодействовать с веб-страницей и браузером. Подробную информацию можно найти в главах \ref{webelments} и \ref{dataexchange}.

\subsection{Тип данных {\color{lightblue} void}}

{\bf Тип данных \void{}} означает отсутствия информации, он используется в самых различных целях:

\begin{icItems}
\item
	указать то что функция ничего не возвращает;
\item
	указать на то что в процессе работы функций произошла ошибка;
\item
	выбрать источник данных;
\item
	фильтровать данные;
\item
	удалить переменных состояния;
\item
	и другие.
\end{icItems}


\subsection{Свойства}

Некоторые типы данных имеют свойства. Свойства позволяют получить характеристики хранимых данных. Вне зависимо от типа данные любой объект имеет следующие свойства (перечисленные свойства доступны только для чтения):

\begin{icItems}
\item
	\code{any'typeName : string} - при чтении получаем строку содержащая названия типа хранимых данных;
\item
	\code{any'typeId : int} - при чтении получаем число содержащее идентификатор типа хранимых данных;
\item
	\code{any'rValue : bool} - при чтении получаем \true{} если значение предназначено для правой части операции присваивания, иначе \false{};
\item
	\code{any'readOnly : bool} - при чтении получаем \true{} если объект доступен только для чтения, иначе \false{};
\item
	\code{any'lValue : bool} - при чтении получаем \true{} если объект доступен только для чтения и записи, иначе \false{};
\item
	\code{any'link : bool} - при чтении получаем \true{} если значение объекта хранится во внешнем контейнере и изменение значении объекта будет изменить данные во внешней среде, иначе \false{}.
\end{icItems}

\

\noindent Примеры использования свойств -
\begin{lstlisting}
@int = 2;
@double = 3;
@string = "int";

@int'typeName == @string;		 `` true
@int'typeId == @double'typeId ;	 `` false
@string'typeId == _types'string; `` true

@int'rValue; `` false
1234'rValue; `` true

@int'readOnly; `` false
1234'readOnly; `` true

@int'lValue; `` true
1234'lValue; `` false

@int'link; `` true
1234'link; `` false
\end{lstlisting}

\subsection{Методы}

Методы позволяют изменить состояние объекта. Все типы данных имеют только один общий метод \code{any.ensureRValue}, который гарантирует что изменение значению объекту не будет изменить данные во вне текущего контекста.

\noindent Пример -
\begin{lstlisting}
@int = 123;

@int'rValue;   `` false
@int'readOnly; `` false
@int.ensureRValue;
@int'rValue;   `` true
@int'readOnly; `` false
\end{lstlisting}

\subsection{Преобразование типов}

В icL данные по умолчанию не преобразуется. На пример сложить \integer{} с \double{} нельзя, такой оператор не определён, в этом случае можно преобразовать \integer{} в \double{} или \double{} в \integer{}, в зависимости от типа нужного результата.

Синтаксис преобразований максимально простой \code{data : type}, где \code{data} - любые данные (переменных или константные) а \code{type} - имя нужного типа данных.

\noindent Примеры преобразования:
\begin{lstlisting}
@a = 2 + 2.3; `` error
@a = (2 : double) + 2.3; `` 4.3
@a = 2 + (2.3 : int); `` 4

@b = 12 + " utils"; `` error
@b = (12 : string) + " utils"; `` "12 utils"

@c = "55" - 12; `` error
@c = ("55" : int) - 12; `` 43

@d = 23 + 12 : double; `` @d = 35.0
@e = 234.0 / 5.0 : int; `` @e = 46
\end{lstlisting}

%\newpage
\section{Литералы}

Константные значения, которые присутствуют в скрипте в виде части исходного кода, называются {\bf литералами}.

Литералы могут быть любыми из следующих типов:

\begin{icItems}
	\item
		логическое значение - \bool{};
	\item
		целое число - \integer{};
	\item
		дробное число - \double{};
	\item
		строка - \str{};
	\item
		список - \listtype{};
	\item
		объект - \object{};
	\item
		множество - \set{}.
\end{icItems}

\subsubsection{Логические значения}

Для представления {\bf логических значения} используется следующее литералы:
\begin{icItems}
	\item \true{} - логическое единица, истинно;
	\item \false{} - логической ноль, лож.
\end{icItems}

\subsubsection{Целые числа}

Для представления {\bf целых чисел} используется последовательность цифр, перед которым может присутствовать минус. Между минусом и последовательности цифр разделители должны отсутствовать, иначе минус будет интерпретирован как оператор.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
23; -23; - 23; +23 + 3; 12 + -34; 15 - 24; 89--56; 2-3; `` ok
23-; 23+; -2А; 3f5; 23f; 23l; 12u; 89i; 2w1; 1q1; rt2; `` error
\end{lstlisting}

\subsubsection{Дробные числа}

{\bf Дробный литерал} состоит из двух частей: целая и дробная. Они разделяются точкой. Каждая составная часть является целом числом. Дробная часть не может быть отрицательной.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
23.233452; 29229992.2391; 100.0; -23.29199; -0.23; -0.45 - 1000.5; `` ok
23.-4; 3а.34; 23-.44; 34.+23; -25.f; -23.5f; -w.45; -2.4e10; -2.E2; `` error
\end{lstlisting}

\subsubsection{Строки}

{\bf Строковым литералом} является последовательность символов, ограниченное с обеих сторон кавычками \lstinline`"`. Чтобы добавить \lstinline`"` используется \lstinline`\"`, символ табуляции - \lstinline`\t`, символ {\it новая строка} - \lstinline`\n`, символ {\it возврат на шаг} - \lstinline`\b`, \textbackslash \ - \lstinline`\\`.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
"Hello \"to\" you!"; "Line1\nLine2"; "Tag1\n\bTag2\n\b"; "text"; "\\ \\ \n \\ \\";
\end{lstlisting}

\subsubsection{Списки}

{\bf Литералом списка} является последовательность строк, ограниченное квадратными скобками.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
@fruits = ["Apple" "Mango" "Banana" "Lime" "Lemon" "Olive"];
@vegetables = ["Cress" "Mustard" "Guar" "Soybean" "Leek" "Ahipa"];
\end{lstlisting}

\subsubsection{Объекты}

{\bf Объектом} является объединение нескольких переменных под общем именем, переменная объявлена внутри объекта называется {\it поле}. Литерал {\it поле} имеет следующий синтаксис \lstinline`<value>name`, где  {\it value} - значение и {\it name} - название. В icL неинициализируемые поля, как и неинициализируемые переменные, нельзя объявить.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
@quotation = [<"author">author <"text">text];
@child = [<4>age <true>hasBrothers <true>hasParents];
@file = [<false>isEmpty <25220>size <true>readOnly];
\end{lstlisting}

\subsubsection{Множества}

Только {\bf пустое множество} можно описать литералом, литерал схож с литералом объекта, только вместо значения указывается тип значения.

\noindent Примеры:
\begin{lstlisting}[numbers=none]
@quotations = [<string>author <string>text];
@children = [<int>age <bool>hasBrothers <bool>hasParents];
@files = [<bool>isEmpty <int>size <bool>readOnly];
\end{lstlisting}

%\newpage
\section{Операторы}

{\bf Оператор} - это токен, который предписывает выполнение определённой манипуляции данных. Встроенных операторов в icL очень много, по этому будет их разбирать по типу данных, в следующем порядке:

\begin{icEnum}
	\item \bool{};
	\item \integer{};
	\item \double{};
	\item \str{};
	\item \listtype{};
	\item \object{};
	\item \set{};
	\item \void{}.
\end{icEnum}

Операторы имеют ранг, операторы имеющие наивысший ранг выполняются первыми, а имеющие наименьший ранг - последними. Операторы имеющие правая ассоциативность выполняются раньше чем операторы имеющие левое ассоциативность, они отмечены плюсом справа от ранга, например 7$^+$.

{\bf Оператор пристраивания} имеет ранг 0 и правая ассоциативность;

\subsection{\color{lightblue}bool}

Если у вас отсутствуют знания по алгебры логике, пожалуйста прочтите любую книгу по основы данной науке.

Для типа данных \bool{}, доступны:

\begin{icItems}
	\item
		операции алгебры логике (имеющие ранг 2):
	\begin{icItems}
		\item
			конъюнкция - \lstinline`bool & bool : bool`;
		\item
			дизъюнкция - \lstinline`bool | bool : bool`;
		\item
			эквивалентность - \lstinline`bool ~ bool : bool`;
		\item
			исключающий или - \lstinline`bool ^ bool : bool`;
		\item
			инверсия (имеет ранг 7$^+$) - \lstinline`! bool : bool`;
	\end{icItems}

	\item
		операций сравнения (имеющие ранг 3):
	\begin{icItems}
		\item
			равно - \lstinline`bool == bool : bool`;
		\item
			не равно - \lstinline`bool != bool : bool`;
	\end{icItems}
\end{icItems}

Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{boolopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа bool, label=boolopex]
_log.out "true & false = " (true & false);		`` true \& false = false
_log.out "false | true =  " (false | true);		`` false | true = true
_log.out "true ~ false = " (true ~ false);		`` true \textasciitilde\ false = false
_log.out "false ^ true = " (false ^ true);		`` false \textasciicircum\ true = true`

_log.out "!true = " !true;						`` !true = false
_log.out "!false = " !false;					`` !false = true

_log.out "true == false = " (true == false);	`` true == false = false
_log.out "false != true = " (false != true);	`` false != true = true
\end{lstlisting}

\subsubsection{\lstinline`<bool>a & <bool>b : bool`}

Оператор принимает логическую операцию "конъюнкция" над переменными a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{conjtable}.

\begin{table}[htb]
	\caption{Таблица истинности конъюнкции}
	\label{conjtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \& b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a | <bool>b : bool`}

Оператор принимает логическую операцию "дизъюнкция" над переменными a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{distable}.

\begin{table}[htb]
	\caption{Таблица истинности дизъюнкции}
	\label{distable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \| b} 	\\ \hline
		\false{} & \false{} & \false{} 		\\ \hline
		\false{} & \true{}  & \true{}  		\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \true{}  		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a ~ <bool>b : bool`}

Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logeqtable}.

\begin{table}[htb]
	\caption{Таблица истинности эквивалентности}
	\label{logeqtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \~ b} \\ \hline
		\false{} & \false{} & \true{}   	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline`<bool>a ^ <bool>b : bool`}

Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logdifftable}.

\begin{table}[htb]
	\caption{Таблица истинности исключающего или}
	\label{logdifftable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \^ b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \true{}   	\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \false{}  	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`! <bool>a : bool`}

Оператор принимает логическую операцию "инверсия" над переменной a. Зависимость результата от исходных данных иллюстрирована в таблице \ref{invtable}.

\begin{table}[htb]
	\caption{Таблица истинности инверсии}
	\label{invtable}
	\begin{tabular}{|c|c|}
		\hline
		\code{a} & \code{!a} \\ \hline
		\false{} & \true{} 	 \\ \hline
		\true{}  & \false{}  \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a == <bool>b : bool`}

Возвращает \true{} если a равно b, иначе \false{}.

\subsubsection{\lstinline`<bool>a != <bool>b : bool`}

Возвращает \true{} если a равно b, иначе \false{}.

\subsection{{\color{lightblue}int} и {\color{lightblue}double}}

Для чисел доступны операций:
\begin{icItems}
	\item
		3-ого ранга:
		\begin{icItems}
			\item
				равно \lstinline`int == int : bool` и \lstinline`double == double : bool`
			\item
				не равно \lstinline`int != int : bool` и \lstinline`double != double : bool`
			\item
				больше \lstinline`int >> int : bool` и \lstinline`double >> double : bool`
			\item
				больше или равно \lstinline`int >= int : bool` и \lstinline`double >= double : bool`
			\item
				меньше \lstinline`int << int : bool` и \lstinline`double << double : bool`
			\item
				меньше или равно \lstinline`int <= int : bool` и \lstinline`double <= double : bool`
		\end{icItems}
	\item
		4-ого ранга:
		\begin{icItems}
			\item
				сложение \lstinline`int + int : int` и \lstinline`double + double : double`;
			\item
				вычитание \lstinline`int -    int : int` и \lstinline`double -    double : double`.
		\end{icItems}
	\item
		5-ого ранга:
		\begin{icItems}
			\item
				умножение \lstinline`int * int : int` и \lstinline`double * double : double`;
			\item
				деление \lstinline`int / int : int` и \lstinline`double / double : double`;
			\item
				остаток от деления целых чисел \lstinline`int \ int : int`.
		\end{icItems}
	\item
		6$^+$-ого ранга:
		\begin{icItems}
			\item
				возведения в квадрат \lstinline`int** : int` и \lstinline`double** : double`;
			\item
				возведения в степень \lstinline`int ** int : int` и \lstinline`double ** double : double`;
			\item
				извлечения квадратного корня \lstinline`/'int : int` и \lstinline`/'double : double`;
			\item
				извлечения корня \lstinline`int/'int : int` и \lstinline`double/'double : double`.
		\end{icItems}
	\item
		7$^+$-ого ранга:
		\begin{icItems}
			\item
				инверсия знака \lstinline`-int : int` и \lstinline`-double : double`;
			\item
				абсолютное значение \lstinline`+int : int` и \lstinline`+double : double`.
		\end{icItems}
\end{icItems}

Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{numberopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа int и double, label=numberopex]
`` 3rd rank
_log.out "2 == 3 = "		2 == 3;		`` 2 = 3 = false
_log.out "2.5 == 2.5 = "	2.5 == 2.5;	`` 2.5 = 2.5 = true
_log.out "1 != 2 = "		1 != 2;		`` 1 $\neq$ 2 = true
_log.out "2.1 != 2.1 = "	2.1 != 2.1;	`` 2.1 $\neq$ 2.1 = false
_log.out "3 >> 2 = "		3 >> 2;		`` 3 > 2 = true
_log.out "1.1 >> 2.1 = "	1.1 >> 2.1;	`` 1.1 > 2.1 = false
_log.out "5 >= 2 = "		5 >= 2;		`` 5 $\geq$ 2 = true
_log.out "5.1 >= 2 = "		5.1 >= 2;	`` 5.1 $\geq$ 2 = true
_log.out "3 << 9 = "		3 << 9;		`` 3 < 9 = true
_log.out "6.1 << 6.2 = "	6.1 << 6.2;	`` 6.1 < 6.2 = true
_log.out "4 <= 5 = "		4 <= 5;		`` 4 $\leq$ 5 = true
_log.out "5.6 <= 6.5 = "	5.6 <= 6.5;	`` 5.6 $\leq$ 6.5 = true
`` 4th rank
_log.out "2 + 3 = "			2 + 3;		`` 2 + 3 = 5
_log.out "2.1 + 1.1 = "		2.1 + 1.1;	`` 2.1 + 1.1 = 3.2
_log.out "4 - 5 = "			4 - 5;		`` 4 - 5 = -1
_log.out "4.5 - 3.4 = "		4.5 - 3.4;	`` 4.5 - 3.4 = 1.1
`` 5th rank
_log.out "2 * 3 = "			2 * 3;		`` 2 $\cdot$ 3 = 6
_log.out "2.1 * 5.7 = "		2.1 * 5.7;	`` 2.1 $\cdot$ 5.7 = 11.97
_log.out "5 / 7 = "			5 / 7;		`` 5 $\div$ 7 = 0.7142857142857
_log.out "5.0 / 7.1 = "		5.0 / 7.1;	`` 5.0 $\div$ 7.1 = 0.7042253521126
_log.out "45 \ 8 = "		45 \ 8;		`` 45 \textbackslash 8 = 5
`` 6+th rank
_log.out "25** = "			25**;		`` $25^2$ = 625
_log.out "25.1** = "		25.1**;		`` $25.1^2$ = 630,01
_log.out "34 ** 3 = "		34 ** 3;	`` $34^3$ = 39304
_log.out "2.0 ** 1.5 = "	2.0 ** 1.5;	`` $2.0^{1.5}$ = 2.8284271247461
_log.out "/'25 = "			/'25;		`` $\sqrt{25}$ = 5
_log.out "/'125.7 = "		/'125.7;	`` $\sqrt{125.7}$ = 11.211601134539
_log.out "3/'27 = "			3/'27;		`` $\sqrt[3]{27}$ = 3
_log.out "5.0/'125.5 = "	5.0/'125.5;	`` $\sqrt[5.0]{125.5}$ = 2.6286256727378
`` 7+th rank
_log.out "- 35 = "			- 35;		`` - 35 = -35
_log.out "- -56.7 = "		- -56.7;	`` - -56.7 = 56.7
_log.out "+ -100 = "		+ -100;		`` + -100 = 100
_log.out "+ 89.7 = "		+ 89.7;		`` + 89.7 = 89.7
\end{lstlisting}

{\bf Внимание:} несмотря на то что пробелы в icL игнорируются, они влияют на восприятии кода, \code{-23-4} будет восприниматься как \lstinline`(-23) (-4)` а не как \lstinline`(-23) - (4)`. Недоразумение между человеком и машиной решается добавлением пробелов \lstinline`-23  - 4`.

\subsubsection{\lstinline`<int>a == <int>b : bool`}

Возвращает \true{} если \code{a} и \code{b} имеют одинаковое значение, иначе \false{}.

\subsubsection{\lstinline`<double>a == <double>b : bool`}

Возвращает \true{} если \code{a} и \code{b} отличаются довольно мало (например на 10$^{-15}$), иначе \false{}.

\subsubsection{\lstinline`<int>a != <int>b : bool`}

Возвращает \true{} если \code{a} и \code{b} не имеют одинаковое значение, иначе \false{}.

\subsubsection{\lstinline`<double>a != <double>b : bool`}

Возвращает \true{} если \code{a} и \code{b} отличаются больше чем на уровень погрешности машины, иначе \false{}.

\subsubsection{\lstinline`<int>a >> <int>b : bool`}

Возвращает \true{} если целое число \code{a} больше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a >> <double>b : bool`}

Возвращает \true{} если дробное число \code{a} больше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<int>a >= <int>b : bool`}

Возвращает \true{} если целое число \code{a} больше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a >= <double>b : bool`}

Возвращает \true{} если дробное число \code{a} больше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline`<int>a << <int>b : bool`}

Возвращает \true{} если целое число \code{a} меньше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a << <double>b : bool`}

Возвращает \true{} если дробное число \code{a} меньше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<int>a <= <int>b : bool`}

Возвращает \true{} если целое число \code{a} меньше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a <= <double>b : bool`}

Возвращает \true{} если дробное число \code{a} меньше или равно \code{b}, иначе \false{}.


\subsubsection{\lstinline`<int>a + <int>b : int`}

Возвращает сумму целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a + <double>b : double`}

Возвращает сумму дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a - <int>b : int`}

Возвращает разницу между целыми числами \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a - <double>b : double`}

Возвращает разницу между дробными числами \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a * <int>b : int`}

Возвращает результат умножения целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a * <double>b : double`}

Возвращает результат умножения дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a / <int>b : int`}

Возвращает результат деления целых чисел \code{a} и \code{b}, остаток отбрасывается.

\subsubsection{\lstinline`<double>a / <double>b : double`}

Возвращает результат деления дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a \ <int>b : int`}

Возвращает результат от деления целых чисел \code{a} и \code{b}.


\subsubsection{\lstinline`<int>a ** : int`}

Возвращает квадрат целого числа \code{a} (a$^2$);

\subsubsection{\lstinline`<double>a ** : double`}

Возвращает квадрат дробного числа \code{a} (a$^2$);

\subsubsection{\lstinline`<int>a ** <int>b : int`}

Возвращает результат возведения целого числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`<double>a ** <double>b : double`}

Возвращает результат возведения дробного числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`/' <int>a : int`}

Возвращает корень целого числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`/' <double>a : double`}

Возвращает корень дробного числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`<int>n /' <int>a : int`}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<int>n /' <double>a : double`}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<double>n /' <double>a : double`}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).


\subsubsection{\lstinline`- <int>a : int`}

Возвращает \lstinline|0 - a|;

\subsubsection{\lstinline`- <double>b : double`}

Возвращает \lstinline|0.0 - a|;

\subsubsection{\lstinline`+ <int>a : int`}

Возвращает абсолютное значение целого числа \code{a}.

\subsubsection{\lstinline`+ <double>a : double`}

Возвращает абсолютное значение дробного числа \code{a}.

\subsection{{\color{lightblue}string} и {\color{lightblue}list}}

	Для строк и списков доступны операций:
\begin{icItems}
	\item
		3-ого ранга:
		\begin{icItems}
		\item
			равно \lstinline`string == string : bool` и \lstinline`list == list : bool`;
		\item
			не равно \lstinline`string != string : bool` и \lstinline`list != list : bool`;
		\item
			содержит \lstinline`list << string : bool` и \lstinline`string << string : bool`;
		\item
			содержит строку подходящая по шаблону \lstinline`list <* string : bool`.
		\end{icItems}
	\item
		4-ого ранга:
		\begin{icItems}
		\item
			конкатенация \lstinline`string + string : string`;
		\item
			вставка \lstinline`string + list : list`, \lstinline`list + string : list` и \lstinline`list + list : list`.
		\end{icItems}
	\item
		5-ого ранга: шаблонное сравнение \lstinline`string * string : bool`, \lstinline`list * string : bool` и \lstinline`list * list : bool`;
	\item
		6$^+$-ого ранга: эквивалентность \lstinline`string ** string : double`.
\end{icItems}

Примеры использование операторов присутствуют на листинге \ref{stringlistopex}.

Чтобы из несколько строк получить список, оператор вставки рекомендуется не использовать, вместо него использовать литерал:
\begin{lstlisting}[numbers=none]
[@str1 @str2 "Const string" (!func) (37.1 : string) (@bool : string) @list.Join]
\end{lstlisting}

\begin{lstlisting}[caption=Примеры использования операторов над данными типа string и list, label=stringlistopex]
"String1" == "String2";					`` false
["a" "b"] == ["a" "b"];					`` true
["a" "b"] == ["b" "a"];					`` true
["a" "b"] << "c";						`` false
"abc" << "c";							`` true
"ab" + "c";								`` "abc"
"ab" + ["c"];							`` ["ac" "c"]
["a" "b"] + "c";						`` ["a" "b" "c"]
["a" "b"] + ["c" "d"];					`` ["a" "b" "c" "d"]
"abc" * "*c";							`` true
["ac" "bc"] * "*c";						`` true
["ac" "bc"] * "a*";						`` false
["ad" "ac" "bd" "cc"] * ["*d" "*c"];	`` true
["ad" "ac" "bc" "cd"] * ["*d" "*c"];	`` false
"Tom is a cat" ** "Tom is not a cat";	`` 0.875
\end{lstlisting}

\subsubsection{\lstinline`<string>s1 == <string>s2 : bool`}

Возвращает \true{} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \false{}.

\subsubsection{\lstinline`<list>l1 == <list>l2 : bool`}

Возвращает \true{} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \false{}.

\subsubsection{\lstinline`<string>s1 != <string>s2 : bool`}

Возвращает \false{} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \true{}.

\subsubsection{\lstinline`<list>l1 != <list>l2 : bool`}

Возвращает \false{} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \true{}.

\subsubsection{\lstinline`<list>l << <string>str : bool`}

Возвращает \true{}, если список \code{l} содержит строку \code{str}, иначе \false{}.

\subsubsection{\lstinline`<string>str << <string>substr : bool`}

Возвращает \true{}, если строка \code{str} содержит подстроку \code{substr}, иначе \false{}.

\subsubsection{\lstinline`<list>l <* <string>template : bool`}

Возвращает \true{}, если список \code{l} содержит хотя бы одна строка, подходящая по шаблону \code{template}, иначе \false{}.

{\bf Шаблон} - это строка содержащая данные и специальный символ \lstinline`*`, где \lstinline`*` означает любая последовательность символов. Рассмотрим шаблонную строку \lstinline`"Have a * day!"`, примеры строк подходящие по шаблону: \lstinline`"Have a nice day!"`, \lstinline`"Have a amazing day!"`. Пример неподходящей строки \lstinline`"Have a good day"` (отсутствует восклицательный знак).

\subsubsection{\lstinline`<string>s1 + <string>s2 : string`}

Возвращает строку содержащую все символы строк \code{s1} и \code{s2}. Полученная строка имеет длину равна суммы длин составляющих.

\subsubsection{\lstinline`<string>str + <list>l : list`}

Возвращает новый список, получен при вставке строке \code{str} в начале списка \code{l}.

\subsubsection{\lstinline`<list>l + <string>str : list`}

Возвращает новый список, получен при вставке строке \code{str} в конце списка \code{l}.

\subsubsection{\lstinline`<list>l1 + <list>l2 : list`}

Возвращает новый список, содержащий все элементы списков \code{l1} и \code{l2}.

\subsubsection{\lstinline`<string>str * <string>template : bool`}

Возвращает \true{}, если строка \code{str} подходит по шаблону \code{template}, иначе \false{}.

\subsubsection{\lstinline`<list>l * <string>template : bool`}

Возвращает \true{} если все строки списка \code{l} подходят по шаблону \code{template}, иначе \false{}.

\subsubsection{\lstinline`<list>l * <list>templates : bool`}

Возвращает \true{} если все строки списка \code{l} подходят по соответственному шаблону из списка \code{templates}, иначе \false{}.

\subsubsection{\lstinline`<string>s1 ** <string>s2 : double`}

Возвращает коэффициент эквивалентности получен при сравнении \code{s1} с \code{s2}.

{\bf Эквивалентность} - уровень схожести строк. \lstinline`"Hi! Robert, how do you do?"` относительно \lstinline`"Robert! Hi! How do you do?"` имеет эквивалентность равна единицы. Так как они состоят из одни и те же слова. Но если сравнивать с  \lstinline`"Rich! Hi! How are you?"` оценка снижается до 0,64.

\subsubsection{\lstinline`<list>l1 ** <list>l2 : double`}

Возвращает коэффициент эквивалентности получен при сравнении строк из списка \code{l1} со строками из списка \code{l2}.
Для корректности вычисления, каждая строка должна содержать одно слово.

\subsection{{\color{lightblue}object} и {\color{lightblue}set}}

Для строк и списков доступны операций:
\begin{icItems}
	\item
		3-ого ранга:
		\begin{icItems}
		\item
			равно \lstinline`object == object : bool` и \lstinline`set == set : bool`;
		\item
			не равно \lstinline`object != object : bool` и \lstinline`set != set : bool`;
		\item
			включение \lstinline`set << object : bool` и \lstinline|set << set : bool|;
		\item
			включение шаблона \lstinline`set <* object` и \lstinline`object <* object : bool`.
		\end{icItems}
	\item
		4-ого ранга:
		\begin{icItems}
		\item
			объединение \lstinline`set + set : set`;
		\item
			симметрическая разность \lstinline`set -   set : set`.
		\end{icItems}
	\item
		5-ого ранга:
		\begin{icItems}
		\item
			разность \lstinline`set \ set : set`;
		\item
			пересечение \lstinline`set * set : set`.
		\end{icItems}
	\item
		6$^+$-ого ранга: пересекаются \lstinline|set ** set : bool|.
\end{icItems}

Примеры использование операторов присутствуют на листинге \ref{setobjopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа object и set, label=setobjopex]
`` init
@set1 = [<int>age <string>name];
@set2 = [<int>age <string>name];
@set3 = [<int>age <string>name];

@obj1 = [<24>age <"User1">name];
@obj2 = [<23>age <"User2">name];
@obj3 = [<26>age <"User3">name];
@obj4 = [<24>age <80>length <40>height <1>arc];

@set1.insert @obj1;
@set1.insert @obj2;
@set2.insert @obj3;
@set2.insert @obj2;
@set3.insert @obj2;
@set3.insert @obj1;

`` operators
@set1 == @set2;				`` false
@set1 == @set3;				`` true
@obj1 == @obj2;				`` false
@set2 != @set3;				`` true
@obj2 != @obj3;				`` true

@set1 << @obj2;				`` false
@set1 << @set2;				`` false
@set1 <* [<23>age];			`` true
@obj4 <* [<24>age <1>arc];	`` true

@set1 + @set2;				`` [@obj1 @obj2 @obj3]
@set1 - @set2;				`` [@obj1 @obj3]
@set1 \ @set2;				`` [@obj1]
@set1 * @set2;				`` [@obj2]

@set1 ** @set2;				`` true
\end{lstlisting}

\subsubsection{\lstinline`<object>obj1 == <object>obj2 : bool`}

Возвращает \true{} если \code{obj1} и \code{obj2} имеют одни и те же поля, значения полях из первого объекта совпадает с значениям одноимённых полях второго объекта, иначе \false{}.

\subsubsection{\lstinline`<set>set1 == <set>set2 : bool`}

Возвращает \true{} если \code{set1} и \code{set2} имеют один и тоже заголовок, всё объекты из первой множестве приличествуют во вторым и наоборот, иначе \false{}.

\subsubsection{\lstinline`<object>obj1 != <object>obj2 : bool`}

Возвращает \true{} если один из объектов имеет поле, отсутствующее в другом или значения поле первого отличается от значении одноимённой поле второго объекта, иначе \false{}.

\subsubsection{\lstinline`<set>set1 != <set>set2 : bool`}

Возвращает \true{} если количество объектов во втором объекте отличается от количества объектов в первом или существует объект присутствующий только в одной множестве, иначе \false{}.

\subsubsection{\lstinline`<set>s << <object>obj : bool`}

Возвращает \true{}, если множество \code{s} содержит объект \code{obj}, иначе \false{}.

\subsubsection{\lstinline|<set>set1 << <set>set2 : bool|}

Возвращает \true, если множество \code{set1} содержит подмножество \code{set2}, иначе \false.

\subsubsection{\lstinline`<set>s <* <object>subobj : bool`}

Возвращает \true{}, если множество \code{s} содержит под объект \code{subobj}, иначе \false{}.

\subsubsection{\lstinline`<object>obj <* <object>subobj : bool`}

Возвращает \true{} если каждое поле объекта \code{subobj} содержится в объекте \code{obj} и значение одноимённых полях совпадает, иначе \false{}.

\subsubsection{\lstinline`<set>set1 + <set>set2 : set`}

Возвращает новое множество содержащая все объекты множеств \code{set1} и \code{set2}.

\subsubsection{\lstinline`<set>set1 - <set>set2 : set`}

Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}, и все объекты множестве \code{set2}, отсутствующих в \code{set1}.

\subsubsection{\lstinline`<set>set1 \\ <set>set2 : set`}

Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}.

\subsubsection{\lstinline`<set>set1 * <set>set2 : set`}

Возвращает новое множество содержащая все объекты , которые приличествуют в \code{set1} и \code{set2}.

\subsubsection{\lstinline`<set>set1 ** <set>set2 : bool`}

Возвращает \true, если множества \code{set1} и \code{set2} пересекаются, иначе \false.

\subsection{\color{lightblue}void}

Все \void{} операторы имеют 2-ой ранг. Данные операторы делят данных на 2 типа \void{} и не \void{}. Второй тип в дальнейшем будет отмечен как \code{any}, он может быть один из следующих типов: \integer{}, \double{}, \str{}, \listtype{}, \object{}, \set{}, \element{}.

Список \void{} операторов:

\begin{icItems}
\item
	альтернативный выбор \lstinline`void | void : void`, \lstinline`void | any : any`, \lstinline`any | void : any` и \lstinline`any | any : any`;
\item
	первичный выбор \lstinline|void & void : void|, \lstinline|any & void : void|, \lstinline|void & any : void| и \lstinline|any & any : any|;
\item
	вторичный выбор \lstinline|void ~ void : void|, \lstinline|void ~ any : void|, \lstinline|any ~ void : void| и \lstinline|any ~ any : any|;
\item
	исключающий выбор \lstinline|void ^ void : void|, \lstinline|void ^ any : any|, \lstinline|any ^ void : any| и \lstinline|any ^ any : void|;
\item
	коллекционный выбор \lstinline|void % void : void|, \lstinline|void % any : any|, \lstinline|any % void : any|, \lstinline|int % int : int|, \lstinline|double % double : double|, \lstinline|string % string : list|, \lstinline|list % string : list|, \lstinline|object % object : set| и \lstinline|set % object : set|. Ещё одна перегрузка оператора будет объявлена в главе \ref{webelments}.
\end{icItems}

\subsubsection{\lstinline`<void or any>arg1 | <void or any>arg2 : void or any`}

Возвращаемый результат оператором альтернативного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{orhacktable}.

\begin{table}[htb]
	\caption{Оператор альтернативный выбор}
	\label{orhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \| arg2} \\ \hline
		\void{}     & \void{}     & \void{}  			\\ \hline
		\void{}     & \code{any}  & \code{arg2}  		\\ \hline
		\code{any}  & \void{}     & \code{arg1}  		\\ \hline
		\code{any}  & \code{any}  & \code{arg1}  		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> \& <void or any> : void or any`}

Возвращаемый результат оператором первичного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{andhacktable}.

\begin{table}[htb]
	\caption{Оператор первичный выбор}
	\label{andhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \& arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg1}   		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> ~ <void or any> : void or any`}

Возвращаемый результат оператором вторичного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{eqhacktable}.

\begin{table}[htb]
	\caption{Оператор вторичный выбор}
	\label{eqhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \~ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg2}   		\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline`<void or any> ^ <void or any> : void or any`}

Возвращаемый результат оператором исключающего выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{xorhacktable}.

\begin{table}[htb]
	\caption{Оператор исключающий выбор}
	\label{xorhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \^ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \code{arg2}   		\\ \hline
		\code{any}  & \void{}     & \code{arg1}   		\\ \hline
		\code{any}  & \code{any}  & \void{}   			\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> \% <void or any> : void or any`}

	Возвращаемый результат оператором исключающего выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{centhacktable}.
%\stablethree{1.5cm}{1.5cm}{5cm}
%{centhacktable}{Оператор коллекционный выбор}
%{\code{arg1}}{\code{arg2}}{\code{a \^ b}}
%{
\begin{table}[htb]
	\caption{Оператор коллекционный выбор}
	\label{centhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \% arg2}			\\ \hline
		\void{}     & \void{}     & \void{}						\\ \hline
		\void{}     & \code{any}  & \code{arg2}					\\ \hline
		\code{any}  & \void{}     & \code{arg1}					\\ \hline
		\integer{}  & \integer{}  & \integer{}					\\ \hline
		\double{}   & \double{}   & \double{}					\\ \hline
		\str{}      & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\listtype{} & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\object{}   & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
		\set{}      & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}
%}

Для аргументов типов \integer{} и \double{}, вызывается функция \code{_numbers.process}, перед использованием установите какую операцию нужно выполнять с числами, использую функцию \code{_numbers.setProcess} с одни из следующих аргументов: \code{_numbers'sum} - сумма, \code{_numbers'product} - произведение, \code{_numbers'max} - максимум, \code{_numbers'min} - минимум. После использования оператора, вызываете \code{_numbers.restoreProcess} чтобы восстановить исходные настройки.

\subsection{Дополнительные операторы}

\subsubsection{\lstinline`[string...]`, \lstinline`[arg...]`, \lstinline`[param...]`, \lstinline`[<>]` и \lstinline`[]`}

{\bf Квадратные скобки} или {\bf оператор объединения данных} позволяет создавать объекты следующих типов данных \listtype{}, \set{} и \object{}.

\code{[] : list} создаёт пустой список.

\code{[string ...] : list} создаёт заполненный список, он может содержать как константные литеры, так и вызовы на функций возвращающие строки. Пример: \code{["a" "b" "c"]}.

\code{[list ...] : list} объединяет несколько списков в один.

\code{[string or list ...] : list} - строки и списки можно смешать.

\code{[<>] : object} создаёт пустой объект.

\code{[arg ...] : object} создаёт объект имеющие поля (каждое поле описывается в виде аргумента), аргумент описывается следующим образом \code{<value>name}, где \code{value} - значение, \code{name} - название аргумента. Пример \code{[<2>number <"str">str]}.

\code{[param ...] : set} создаёт множество с указанным заголовкам, каждый столбец описывается в виде параметра, параметр описывается следующим образом \code{<type>name}, где \code{type} - тип значения, \code{name} - название параметра. Создавать множество с пустым заголовком - запрещено. Пример \code{[<int>number <string>str]}.

\code{[object ...] : set} создаёт множество из несколько объектов.

\code{[set ...] : set} объединяет несколько множеств в одной.

\code{[object or set ...] : set} объекты и множества также можно смешать.

%\newpage
\section{Условные операторы}

Условные структуры имеют условие, которое будет вычислено. А также и блоки команд, чья выполнение зависит от значения условии.

В icL приличествуют следующее условные операторы:
\begin{icItems}
	\item \code{if};
	\item \code{if else};
	\item каскадное \code{if else};
	\item \code{exists};
	\item \code{if exists};
	\item \code{for any}.
\end{icItems}

\subsubsection{\lstinline`if`}

\code{if} позволяет ставить условия выполнения блока команд. Он имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
if (condition) {
	commands
};
\end{lstlisting}
где \code{condition} любое выражение возвращающее значение типа \bool{} и \code{commands} любой набор команд.

Также допускаются пропустить круглые скобки, синтаксис -
\begin{lstlisting}[numbers=none]
if true  { commands };
if @var  { commands };
\end{lstlisting}

\subsubsection{\lstinline`if else`}

\code{if else} позволяет выбирать между двух блоков команд, в случае когда условие истинно - выполняется первый блок, иначе второй блок.

Конструкция \code{if else} имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
if (condition) {
	commands1
}
else {
	commands2
};
\end{lstlisting}

\subsubsection{Каскадное \lstinline`if else`}

Каскадное \code{if else} позволяет выбирать между n блоков команд, но для это нужно предъявить n-1 условии.

Каскадное \code{if else} имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
if (condition1) {
	commands1
} else if (condition2) {
	commands2
} else {
	commands3
};
\end{lstlisting}

\subsubsection{\lstinline`exists`}

\code{exists} позволяет условно возвращать данные, если они подходят под определённому критерия.

Условия по умолчанию:
\begin{icItems}
\item
	для \bool{} - \code{# == true};
\item
	для \integer{} - \code{# != 0};
\item
	для \double{} - \code{# != 0.0};
\item
	для \str{} - \code{!#'empty};
\item
	для \listtype{} - \code{!#'empty};
\item
	для \set{} - \code{!#'empty};
\item
	для \element{} - \code{#'empty}.
\end{icItems}

Если использовать условию по умолчанию, используется следующий синтаксис -
\begin{lstlisting}[numbers=none]
exists(expression);
\end{lstlisting}
При необходимости задать своё условие, синтаксис чуть изменяется -
\begin{lstlisting}[numbers=none]
exists(expression, condition);
\end{lstlisting}

\subsubsection{\lstinline`if exists`}

Конструкция \code{if exists} позволяет выполнять блок команд в зависимости от результата работы конструкции \code{exists}. Также повторно использовать значения выражения. В случае когда условие конструкции \code{exists} истинно, то блок команд выполняется и в нём передаётся данный полученные от \code{exists} под именем \code{@}.
Простой и элементарный пример представлен на листинге \ref{ifexistsex}.

\begin{lstlisting}[caption=Использование if exist, label=ifexistsex]
if exists(23 + 3, # > 20) {
	_log.out "@ = " @; `` @ = 26
};
\end{lstlisting}

\subsubsection{\lstinline`for any`}

\code{for any} позволяет повторно использовать любое значение. Пример использования представлен на листинге \ref{foranyex}.

\begin{lstlisting}[caption=Использование for any, label=foranyex]
for any(23 + 3) {
	_log.out "@ = " @; `` @ = 26
};
\end{lstlisting}

%\newpage
\section{Циклы}

Может возникнуть нужность в том, чтобы выполнить блок кода несколько раз. Для этого совсем не обязательно писать один то тоже код несколько раз, достаточно использовать цикл.

Язык icL предоставляет следующие типы циклов:

\begin{icItems}
\item
	\code{for} - универсальный цикл;
\item
	\code{while} - условное повторение кода;
\item
	\code{do while} - цикл с постусловий;
\item
	\code{for} - прохождение коллекций;
\item
	\code{filter} - выборочное прохождение коллекций;
\item
	\code{range} - частичное прохождение коллекций.
\end{icItems}


\subsubsection{\lstinline`for` - универсальный цикл}

{\bf Универсальный цикл} позволяет полностью управлять ход выполнения кода. Он содержит:

\begin{icItems}
\item
	\code{initialization} - код отвечающий за инициализацию;
\item
	\code{condition} - условие, которая проверяется перед запуском цикла;
\item
	\code{step} - код, отвечающий за перехода на следующую итерацию цикла.
\item
	\code{commands} - тело цикла.
\end{icItems}

Универсальный цикл имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
for (initialization, condition, step) {
	commands
};
\end{lstlisting}

На листинге \ref{uniloopex} показан пример использование цикла \code{for}, цикл будет выводить числа от нуля до четырёх.

\begin{lstlisting}[caption=Универсальный цикл, label=uniloopex]
for (@i = 0, i < 5, @i = @i + 1) {
	_log.out @i;
};
\end{lstlisting}

\subsubsection{\lstinline`while` - условное повторение кода}

{\bf Условное повторение кода} будет выполнить блок команд, пока условие остаётся истиной. Условие проверяется перед запуском цикла и если условие изначально - лож, тела цикла не будет выполниться ни разу.

Главное его преимущества - его простота. В сравнения с универсального цикла, в конструкции \code{while} отсутствуют фрагменты кода для инициализации и перехода на следующую итерацию. Он содержит только условие и тело -
\begin{lstlisting}[numbers=none]
while (condition) {
	commands
};
\end{lstlisting}

На листинге \ref{whileex} переставлен код, использующий цикл \code{while}. Переменная \code{@number} объявлено до цикла и будет доступа и после него. При завершении работы цикла \code{@number} будет равен 6-и.

\begin{lstlisting}[caption=Цикл while, label=whileex]
@number = 1;

while (@number <= 5) {
	@number = @number + 1;
};
\end{lstlisting}

\subsubsection{\lstinline`do while` - цикл с постусловий}

{\bf Цикл с постусловий} мало отличается от \code{while}, но он гарантирует что тело цикла будет выполнена минимум 1 раз. Также условие объявляется после тело цикла, указывая на то что она будет проверено после первой итерации. Синтаксис -
\begin{lstlisting}[numbers=none]
do {
	commands
} while (condition);
\end{lstlisting}

На листинге \ref{dowhileex} представлен код, использующий цикл \code{do while}. Несмотря на то что условие изначально \code{false}, первая итерация цикла будет выполнена, в результате чего \code{@number} станет равен 7-и.

\begin{lstlisting}[caption=Цикл do while, label=dowhileex]
@number = 6;

do {
	@number = @number + 1;
} while (@number < 5);
\end{lstlisting}

\subsubsection{\lstinline`for` - прохождение коллекций}

{Коллекция} - объект, содержащий несколько значений. Самый простой пример коллекций это список, он содержит несколько строк. Например, нужно выполнять операцию для каждой строки списка. Можно использовать универсальный цикл (см. листинг \ref{colluniloop}) или использовать упрощенное {\bf прохождение коллекций} (см. листинг \ref{collsimple}). Под коллекции имеется в виду следующие типы данных \code{list}, \code{set} и \code{element}.
\begin{lstlisting}[caption=Прохождение коллекций с помощью универсального цикла, label=colluniloop]
@list = ["apple" "banana" "fruit"];

for (@i = 0, @i < @list'length, @i = @i + 1) {
	@list.at @i; `` get i-th value
}
\end{lstlisting}

\begin{lstlisting}[caption=Упрощённое прохождение коллекций, label=collsimple]
@list = ["apple" "banana" "fruit"];

for (@list) {
	@; `` get i-th value
}
\end{lstlisting}

\subsubsection{\lstinline`filter` - выборочное прохождение коллекций}

{\bf Конструкция \code{filter}} позволяет ставить условие, для каких элементов коллекций выполнять тело цикла, для каких нет.

В условия есть специальные переменные: \lstinline|@| - значение элемента коллекций и \lstinline|#| - индекс текущей значения.

Фильтр имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
filter (collection, condition) {
	commands
};
\end{lstlisting}

Фильтровать элементы можно по данных (см. листинг \ref{filterdataex}, выбирается те которые содержат букву а) или по индексам (см. листинг \ref{filterindexex}, выбирается чётные элементы списка).

\begin{lstlisting}[caption=Фильтрование по данных, label=filterdataex]
@list = ["apple" "banana" "fruit"];

filter (@list, @ << "a") {
	@; `` apple, banana
}
\end{lstlisting}

\begin{lstlisting}[caption=Фильтрование по индексов, label=filterindexex]
@list = ["apple" "banana" "fruit"];

filter (@list, # \ 2 == 0) {
	@; `` apple, fruit
}
\end{lstlisting}

\subsubsection{\lstinline`range` - частичное прохождение коллекций}

{\bf Частичное прохождение} позволяет выполнить код для интервала коллекций. Интервал определяется одной или двум условий. Первое условие используется для поиска начала интервала. Второе условие - для поиска конца, если оно отсутствует, будет использоваться первое условие. В отсутствия подходящих элементов, тела цикла не будет выполнена. Чтобы выбирать первый или последний элемент (в зависимость от предназначения условии), использует выражение \true{}.

Синтаксис для интервала с одним условием -
\begin{lstlisting}[numbers=none]
range (collection, condition) {
	commands
};
\end{lstlisting}

Синтаксис для интервала с отдельным условием для начало и конца -
\begin{lstlisting}[numbers=none]
range (collection, condition_for_begin, condition_for_end) {
	commands
};
\end{lstlisting}

Выбрать первый и последний элемент можно по значении (см. листинг \ref{bananakiwiex}, интервал от значений \code{banana} до \code{kiwi}) или по индексам (см. листинг \ref{seclastex}, интервал от второго до последнего).

\begin{lstlisting}[caption=Интервал: от banana до kiwi, label=bananakiwiex]
@list = ["apple" "banana" "fruit" "kiwi"];

range (@list, @ == "banana", @ == "kiwi") {
	@; `` banana, fruit, kiwi
}
\end{lstlisting}

\begin{lstlisting}[caption=Интервал: от второго до последнего, label=seclastex]
@list = ["apple" "banana" "fruit" "kiwi"];

range (@list, # == 2, true) {
	@; `` fruit, kiwi
}
\end{lstlisting}

%\newpage
\section{Интеграция с Javascript}

В языке icL {\bf интеграция с Javascript} отличается в разных режимах работы. {\bf Режимы работы} всего 2: тестирование и автоматизация. В дальнейшем параграфы будут отмечены следующим меткам: \code{[icL]} - относиться к автоматизации и расширенных возможностях icL, \code{[w3c]} - относиться к тестированию и стандарту WebDriver предложен World Wide Web Consortium.

\subsection{JS-Значения}

{\bf JS-Значения} - главное нововведение по интеграцию с JavaScript. Оно позволяет использовать переменные JavaScript удобно, как и переменных icL. Они также могут быть доступны только для чтения или для записи и чтения.

Каждое JS-Значение имеет геттер, но только переменные доступны для записи и чтения имеют сеттер. Геттеры и сеттеры являются фрагментами кода на языке JavaScript. В сеттере установленное значение передаётся следующим кодом \code{@{value}} Синтаксис JS-Значений:
\begin{lstlisting}[numbers=none]
$value {getter, setter};
\end{lstlisting}

Упрощённый синтаксис JS-Значений:
\begin{lstlisting}[numbers=none]
$value {getter};
\end{lstlisting}

В качестве JS-Значений может объявить любое переменное, на пример название страницы (см. листинг \ref{jsvalueex}), она остаётся доступной даже после перехода на другой странице.

\begin{lstlisting}[caption=Использование JS-Значений, label=jsvalueex]
@title = $value {document.title, document.title = @{value}};
_log.out @title;
@title = "Yet another title.";
\end{lstlisting}

\subsection{Выполнение кода на языке JavaScript}

Команда \lstinline|$run| позволяет выполнить {\bf код на языке JavaScript}.

\code{[icL]} Команда \lstinline|$run| получает один аргумент - код, в коде могут присутствовать переменные icL. Глобальные переменные предаются следующим образом \lstinline|#{name}|, локальные - \lstinline|@{name}|. Пример передачи значений перемены в JavaScript представлен на листинге \ref{jsrunex1}. Код можно выполнить асинхронно используя \lstinline|$runAsync|.

\begin{lstlisting}[caption=Выполнение кода на языке JavaScript (icL), label=jsrunex1]
@var = 2;
$run { window.a = @{var} }
\end{lstlisting}

\code{[w3c]} Команда \lstinline|$run| получает переменное количество переменных. Они передаются в коде на языке JavaScript в виде аргументов вызова функций. Доступ к ним осуществляется с помощью переменной \code{arguments}. Код использующий данную тактику представлен на листинге \ref{jsrunex2}, его можно сравнивать с листингом \ref{jsrunex1}. Код можно выполнить асинхронно используя \lstinline|$runAsync|.

\begin{lstlisting}[caption=Выполнение кода на языке JavaScript (w3c), label=jsrunex2]
@var = 2;
$run @var { window.a = arguments[0] }
\end{lstlisting}

Возможные исключения: \ferror{JavascriptError}, \ferror{ScriptTimeout}.

\subsection{Выполнения файлов}

Команда \lstinline|$file| {\bf выполняет файлы} JavaScript (.js). Для этого достаточно передать путь к файлу в качестве аргумента.

Синтаксис -
\begin{lstlisting}[numbers=none]
$file "path/to/file.js";
\end{lstlisting}

Возможные исключения: \ferror{FileNotFound}, \ferror{JavascriptError}.

\subsection{Пользовательские скрипты}

\lstinline|[icL]| {\bf Пользовательские скрипты} выполняются до загрузки страницы, при переходе на страницу. Скрипт можно подкрепить как к текущей вкладке (\lstinline|$user|) так и ко всех вкладок из сессии (\lstinline|$always|).

\lstinline|[icL]| Синтаксис -
\begin{lstlisting}[numbers=none]
$user "path/to/file.js";
$always "path/to/file.js";
\end{lstlisting}

Возможные исключения: \ferror{FileNotFound}.

%\newpage
\section{Функции}

{\bf Функции} в icL позволяют повторное использовать код, и структурировать код. Все функций в icL - глобальные.

\subsubsection{Определение функции}

{\bf Определение функции} состоит из заголовка и тела функции.

\noindent Синтаксис -
\begin{lstlisting}[numbers=none]
!name = parameters : return_type {
	commands
}
\end{lstlisting}

Описание всех частей функции:
\begin{icItems}
\item
	\code{name} - {\bf название функции};
\item
	\code{parameters} - {\bf список параметров}. Когда функция вызывается вы передаёте значения параметру. Список параметров определяет тип, количество и порядок параметров. Список параметров необязателен (см. листинги \ref{fullfunc} и \ref{noargsfunc});
\item
	\code{return_type} - {\bf тип данных которых} функция будет возвращать. Если функция ничего не возвращает тип данных можно пропустить или указать явно \void{}. Чтобы возвращать значение используется команда \code{@ = value} (см. листинги \ref{fullfunc}, \ref{notypefunc} и \ref{minfunc});
\item
	\code{commands} - {\bf тело функции} содержит команды, которые определяют что делает функция.
\end{icItems}

\begin{lstlisting}[caption=Полноценная функция, label=fullfunc]
!sum = <int>a <int>b : int {
	@ = @a + @b;
};
\end{lstlisting}

\begin{lstlisting}[caption=Функция без аргументов, label=noargsfunc]
!pi = double {
	@ = 3.14;
};
\end{lstlisting}

\begin{lstlisting}[caption=Функция без типа возвращаемой значений, label=notypefunc]
!out = <int>a <int>b {
	_log.out @a @b;
};
\end{lstlisting}

\begin{lstlisting}[caption=Функция без аргументов и тип возвращаемой значений, label=minfunc]
!do = {
	_log.out "It's work!";
};
\end{lstlisting}

\subsubsection{Вызов функции}

Вы можете вызвать функцию следующим образом -
\begin{lstlisting}[numbers=none]
!name arguments;
\end{lstlisting}
где \code{name} - {\bf название функции}, \code{arguments} - {\bf список аргументов} (он должен быть совместим со списком параметров функции). Как вызвать функций, объявленные на листингов \ref{fullfunc} - \ref{minfunc}, показано на листинге \ref{callfunc}.


\begin{lstlisting}[caption=Вызов функций, label=callfunc]
!sum 2 3; 	`` returns 5
!pi; 		`` returns 3.14
!out 4 5; 	`` returns void
!do; 		`` returns void

!sum (!sum 1 2) 3;	`` returns 6
!out 1 (!sum 4 5);	`` returns void
\end{lstlisting}

%\newpage
\section{Строки}

{\bf Строки} (тип \str{}) позволяет хранить и манипулировать фрагменты текста. 

\subsection{Свойства}

В дальнейшем свойства будут отмечены следующим маркером: \code{[r/w]} - доступно для чтения и записи, \code{[r/o]} - доступно только для чтения, \code{[w/o]} - доступно только для записи,  \code{[r/*]} - доступно для записи только в режиме автоматизации, \code{[*/*]} - доступ будет конкретизирован потом.

Строки имеют следующее дополнительные свойства:
\begin{icItems}
\item
	\code{[r/o] string'empty : bool};
\item
	\code{[r/o] string'length : int};
\item
	\code{[r/o] string'last : string};
\item
	\lstinline|[r/o] string'(<int>n) : string|.
\end{icItems}

\

На листинге \ref{stringprop} представлен код, использующий выше перечисленных свойства.

\begin{lstlisting}[caption=Свойства класса string, label=stringprop]
@empty = "";
@fonts = "Arial, Helvetica, Times, Courier";

@empty'empty; `` true
@fonts'empty; `` false

@empty'length; `` 0
@fonts'length; `` 32

@empty'last; `` error
@fonts'last; `` "r"

@empty'0; `` error
@fonts'0; `` "A"
\end{lstlisting}

\subsubsection{\code{[r/o] string'empty : bool}}

Строка считается пустой если количество содержащих символов равна нулю;

\subsubsection{\code{[r/o] string'length : int}}

Длина строки равна количеству символов в строке;

\subsubsection{\code{[r/o] string'last : char}}

Последний символ строки, то же самое что и \lstinline|string.at (string'length - 1)|.

Возможные исключения: \ferror{EmptyString}.

\subsubsection{\lstinline|[r/o] string'(<int> n) : string|}

n-й символ строки. n должен быть целым литералов, примеры \lstinline|@str'0; @string'2|.

Возможные исключения: \ferror{OutOfBounds}.

\subsection{Методы}

Строки имеют следующий набор дополнительных методов:
\begin{icItems}
\item
	\lstinline|string.append <string>str : string|;
\item
	\lstinline|string.at <int>i : string|;
\item
	\lstinline|string.beginsWith <string>str : bool|;
\item
	\lstinline|string.compare <string>str <bool>caseSensitive = true : bool|;
\item
	\lstinline|string.count <string>str : int|;
\item
	\lstinline|string.endsWith <string>str : bool|;
\item
	\lstinline|string.indexOf <string>str <int>startPos = 0 : int|;
\item
	\lstinline|string.insert <string>str <int>pos : string|;
\item
	\lstinline|string.lastIndexOf <string>str <int>startPos = -1 : int|;
\item
	\lstinline|string.left <int>n : string|;
\item
	\lstinline|string.leftJustified <int>width <string>fillChar <bool>truncate = false : string|;
\item
	\lstinline|string.mid <int>pos <int>n = -1 : string|;
\item
	\lstinline|string.prepend <string>str : string|;
\item
	\lstinline|string.remove <int>pos <int>n : string|;
\item
	\lstinline|string.remove <string>str <bool>caseSensitive = true : string|;
\item
	\lstinline|string.replace <int>pos <int>n <string>after : string|;
\item
	\lstinline|string.replace <string>before <string>after : string|;
\item
	\lstinline|string.right <int>n : string|;
\item
	\lstinline|string.rightJustified <int>width <string>fillChar <bool>truncate = false : string|;
\item
	\lstinline|string.split <string>separator <bool>keepEmptyParts = true <bool>caseSensitive = true : list|;
\item
	\lstinline|string.substring <int>begin <int>end : string|;
\item
	\lstinline|string.trim <bool>justWhitespace = true : string|.
\end{icItems}

Некоторые методы пропущены, они будут представлены в главе \ref{regex}; Код, использующий выше перечисленных методов представлен на листинге \ref{stringmethods}.

\begin{lstlisting}[caption=Методы класса string, label=stringmethods]
@empty = "";
@fonts = "Arial, Helvetica, Times, Courier";
@index = 2;

@empty.append "data";   `` "data"
@empty.append @fonts'0; `` "dataA"
@empty = "";

@empty.at @index; `` error
@fonts.at @index; `` i
@fonts.at 1;	  `` r

@empty.beginsWith "";      `` true
@fonts.beginsWith "Arial"; `` true

@empty.compare "data"; `` false
@empty.compare "";     `` true

@fonts.count ",";      `` 3
@fonts.count @fonts'0; `` 1

@fonts.endsWith "Courier"; `` true
@fonts.endsWith "Arial";   `` false

@fonts.indexOf "Courier"; `` 25
@fonts.indexOf @fonts'11; `` 8

@data = "10"
@data.insert "data" 1;   `` "1data0"
@data.insert @fonts'0 2; `` "1dAata0"

@fonts.lastIndexOf "e";      `` 30
@fonts.lastIndexOf @fonts'8; `` 30

@fonts.left 5; `` "Arial"

@data = "10";
@data.leftJustified 4 "0"; `` "0010"
@data.mid 1 2;             `` "01"

@data.prepend "11";     `` "1100010"
@data.prepend @fonts'0; `` "A1100010"

@data.remove 2 2;  `` "11010"
@data.remove "01"; `` "110"

@data.replace 2 1 "0101"; `` "110101"
@data.replace "01" "01";  `` "111010"

@data.right 4; 				`` "1010"
@data.rightJustified 8 "0"; `` "11101000"

@fonts.split ", ";     `` ["Arial" "Helvica" "Times" "Curier"]
@fonts.split @fonts'5; `` ["Arial" " Helvica" " Times" " Curier"];

@data.substring 1 3; `` "11"

@str = " , 34px \n";
@str.trim;       `` ", 34px"
@str.trim false; `` "34px"
\end{lstlisting}

\subsubsection{\lstinline|string.append <string>str : string|}

Вставит строку \code{str} в конце строки.

\subsubsection{\lstinline|string.at <int>i : string|}

Возвращает ссылка на \code{i}-й символ.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|string.beginsWith <string>str : bool|}

Возвращает \true{}, если начало строки совпадает с \code{str}, иначе \false{}.

\subsubsection{\lstinline|string.compare <string>str <bool>caseSensitive = true : bool|}

Сравнивает строки, возвращает \true{} если они равны, иначе \false{}. Аргумент \code{caseSensitive} может быть пропущен, если установить его в \false{}, то регистр букв будет проигнорирован.

\subsubsection{\lstinline|string.count <string>str : int|}

Считает сколько раз подстрока \code{str} встречается в строке.

\subsubsection{\lstinline|string.endsWith <string>str : bool|}

Возвращает \true{}, если конец строки совпадает с \code{str}, иначе \false{}.

\subsubsection{\lstinline|string.indexOf <string>str <int>startPos = 0 : int|}

Возвращает индекс первой нахождения подстроки \code{str} в строке, ища вперёд с позиции \code{startPos}, если подстрока не найдено возвращает -1.

\subsubsection{\lstinline|string.insert <string>str <int>pos : string|}

Вставит строку \code{str} в позиции \code{pos}.

\subsubsection{\lstinline|string.lastIndexOf <string>str <int>startPos = -1 : int|}

Возвращает индекс первой нахождения подстроки \code{str} в строке, ища назад с позиции \code{startPos}, если подстрока не найдена возвращает -1.

\subsubsection{\lstinline|string.left <int>n : string|}

Возвращает подстроку содержащая первый \code{n} символы.

\subsubsection{\lstinline|string.leftJustified <int>width <string>fillChar <bool>truncate = false : string|}

Возвращает строку длины \code{width}, содержащую эту строку, в конце ставится \code{width - .length} символов \code{fillChar}. Если \code{truncate == true} и \code{width < .length}, то последние \code{.length - width} символы будут удалены.

\subsubsection{\lstinline|string.mid <int>pos <int>n = -1 : string|}

Возвращает строку содержащую \code{n} символы строки, начиная с позиции \code{pos}. Будет возвращена пустая строка если установленный интервал выходит за рамки строки. Если \code{n == -1} то будут возвращены все доступные символы начиная с позицией \code{pos}.

\subsubsection{\lstinline|string.prepend <string>str : string|}

Вставит строку \code{str} в начале строки.

\subsubsection{\lstinline|string.remove <int>pos <int>n : string|}

Удаляет \code{n} символы строки начиная с позицией \code{pos}.

\subsubsection{\lstinline|string.remove <string>str <bool>caseSensitive = true : string|}

Удаляет каждое нахождения подстроки \code{str} в строке. Аргумент \code{caseSensitive} может быть пропущен, если установить его в \false{} то регистр букв будет проигнорирован.

\subsubsection{\lstinline|string.replace <int>pos <int>n <string>after : string|}

Заменяет интервал установленный позицией \code{pos} и количеством символов \code{n} строкой \code{after}.

\subsubsection{\lstinline|string.replace <string>before <string>after : string|}

Заменяет каждое нахождение подстроки \code{before} подстрокой \code{after}.

\subsubsection{\lstinline|string.right <int>n : string|}

Возвращает строку содержащую последние \code{n} символы строки.

\subsubsection{\lstinline|string.rightJustified <int>width <string>fillChar <bool>truncate = false : string|}

Возвращает строку длины \code{width}, содержащую эту строку, в начале ставится \code{width - .length} символов \code{fillChar}. Если \code{truncate == true} и \code{width < .length}, то первые \code{.length - width} символы будут удалены.

\subsubsection{\lstinline|string.split <string>separator <bool>keepEmptyParts = true <bool>caseSensitive = true : list|}

Разрывает строку на подстроки при каждой нахождения подстроки \code{separator} и собирает список из этих строк. Если \code{separator} не встречается ни разу, будет возвращён список из одной строки - этой строки. Если \code{keepEmptyParts == false} то пустые строки пропускаются.

\subsubsection{\lstinline|string.split <string>separator <bool>keepEmptyParts = true <bool>caseSensitive = true : list|}

Разрывает строку на подстроки при каждой нахождения символа \code{separator} и собирает список из этих строк. Это перегруженная функция.

\subsubsection{\lstinline|string.substring <int>begin <int>end : string|}

Возвращает подстроку содержащую символы строки, от позиции \code{begin} до \code{end}.

\subsubsection{\lstinline|string.trim <bool>justWhitespace = true : string|}

Возвращает строку, копия текущей из которого удаляются пробельные символы с начало и конце строки. Если \lstinline|justWhitespace == false|, то будут удалены все знаки которые не является буквой или цифрой.

% \subsubsection{}

%\newpage
\section{Списки}

{\bf Списки} (тип \code{string}) позволяет хранить несколько строк в одной переменной. Доступ к ним обеспечивается через индекс - номер по порядку строке в списке.

\subsection{Свойства}

Списки имеют следующее дополнительные свойства:
\begin{icItems}
\item
	\lstinline|[r/o] list'empty : bool|;
\item
	\lstinline|[r/o] list'length : int|;
\item
	\lstinline|[r/o] list'last : string|;
\item
	\lstinline|[r/o] list'(<int>n) : string|.
\end{icItems}

На листинге \ref{listprop} представлен код, использующий выше перечисленных свойства.

\begin{lstlisting}[caption=Свойства класса list, label=listprop]
@empty = [];
@fonts = ["Arial" "Helvetica" "Times" "Courier"];

@empty'empty; `` true
@fonts'empty; `` false

@empty'length; `` 0
@fonts'length; `` 4

@empty'last; `` error
@fonts'last; `` "Courier"

@empty'0; `` error
@fonts'0; `` "Arial"
\end{lstlisting}

\subsubsection{\lstinline|[r/o] list'empty : bool|}

Список считается пустым если он не содержит ни одну строку.

\subsubsection{\lstinline|[r/o] list'length : int|}

Длина списка равна количеству строк в списке.

\subsubsection{\lstinline|[r/o] list'last : string|}

Последняя строка в списке, то же соме что и \lstinline|list'at (list'length - 1)|.

Возможные исключения: \ferror{EmptyList}.

\subsubsection{\lstinline|[r/o] list'(<int>n) : string|}

n-я строка списка, n должен быть целым литералом.

Возможные исключения: \ferror{OutOfBounds}.

\subsection{Методы}

Списки имеют следующий набор дополнительных методов:
\begin{icItems}
\item \lstinline|list.append <string>str : list|;
\item \lstinline|list.at <int>i : string|;
\item \lstinline|list.contains <string>str <bool>caseSensitive = true : bool|;
\item \lstinline|list.clear : list|;
\item \lstinline|list.count <string>what : int|;
\item \lstinline|list.filter <string>str <bool>caseSensitive = true : bool|;
\item \lstinline|list.indexOf <string>str <int>start = 0 : int|;
\item \lstinline|list.insert <int>index <string>str : list|;
\item \lstinline|list.join <string>separator : string|;
\item \lstinline|list.lastIndexOf <string>str <int>start = -1|;
\item \lstinline|list.mid <int>pos <int>n = -1 : list|;
\item \lstinline|list.prepend <string>str : list|;
\item \lstinline|list.move <int>from <int>to : list|;
\item \lstinline|list.removeAll <string>str : list|;
\item \lstinline|list.removeAt <int>i : list|;
\item \lstinline|list.removeDuplicates : list|;
\item \lstinline|list.removeFirst : list|;
\item \lstinline|list.removeLast : list|;
\item \lstinline|list.removeOne <string>str : bool|;
\item \lstinline|list.replaceInStrings <string>before <string>after : list|;
\item \lstinline|list.sort <bool>caseSensitive = true : list|.
\end{icItems}

Некоторые методы пропущены, они будут представлены в главе \ref{regex}; Код, использующий выше перечисленных методов представлен на листинге \ref{listmethods}. 

\begin{lstlisting}[caption=Методы класса list, label=listmethods]
@empty = [];
@fonts = ["Arial" "Helvetica" "Times" "Courier"];

@empty.append "";              `` [""]
@fonts.at 2;                   `` "Times"
@fonts.contains "arial";       `` false
@fonts.contains "arial" false; `` true
@empty.clear;                  `` []
@fonts.count "Arial";          `` 1

@fonts.filter "e";          `` ["Helvetica" "Times" "Courier"]
@fonts.indexOf "Times";     `` 2
@fonts.insert 1 "DejaVu";   `` ["Arial" "DejaVu" "Helvetica" "Times" "Courier"]
@fonts.join ", ";           `` "Arial, DejaVu, Helvetica, Times, Courier"
@fonts.lastIndexOf "Arial"; `` 0

@fonts.mid 2 2;          `` ["Times" "Courier"]
@fonts.prepend "DejaVu"; `` ["DejaVu" "Arial" "DejaVu" .. "Courier"]
@fonts.move 1 2;         `` ["DejaVu" "DejaVu" "Arial" "Helvetica" ..]

@fonts.removeAll "Helvetica"; `` ["DejaVu" "DejaVu" "Arial" "Times" "Courier"]
@fonts.removeAt 3;            `` ["DejaVu" "DejaVu" "Arial" "Courier"]
@fonts.removeDuplicates;      `` ["DejaVu" "Arial" "Courier"]
@fonts.removeFirst;           `` ["Arial" "Courier"]
@fonts.removeLast;            `` ["Arial"]
@fonts.removeOne "Arial";     `` []

@fonts = ["Arial" "Helvetica" "Times" "Courier"];

@fonts.replaceInStrings "e" "-"; `` ["Arial" "H-lv-tica" "Tim-s" "Couri-r"];
@fonts.sort;                     `` ["Arial" "Couri-r" "H-lv-tica" "Tim-s"];
\end{lstlisting}

Параметр \code{caseSensitive} во всех функциях отвечает за чувствительность к регистру. Его установка гарантирует что регистр букв будет проигнорирован.

\subsubsection{\lstinline|list.append <string>str : list|}

Вставит строку \code{str} в конце списка.

\subsubsection{\lstinline|list.at <int>i : string|}

Возвращает \code{i}-й строка.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|list.contains <string>str <bool>caseSensitive = true : bool|}

Возвращает \true, если список содержит строка, ровна \code{str}, иначе \false.

\subsubsection{\lstinline|list.clear : list|}

Очищает список.

\subsubsection{\lstinline|list.count <string>what : int|}

Возвращает сколько раз строка \code{what} повторяется в списке.

\subsubsection{\lstinline|list.filter <string>str <bool>caseSensitive = true : bool|}

Возвращает новый список строк, содержащий только строки этого списка, содержащие подстроку \code{str}. 

\subsubsection{\lstinline|list.indexOf <string>str <int>start = 0 : int|}

Возвращает индекс первой нахождения строки \code{str} в списке, ища вперёд с позиции \code{start}, если строка не найдено возвращает -1.

\subsubsection{\lstinline|list.insert <int>index <string>str : list|}

Вставит строку \code{str} в позиции \code{index}, если \code{index <= 0} то значение вставится в начале списка, если \code{index >= list'length} то значение вставится в конце списка.

\subsubsection{\lstinline|list.join <string>separator : string|}

Создаёт новую строку, из строк списка, путём последовательной конкатенации, между значениями вставится \code{separator}, он может быть пустой строкой.

\subsubsection{\lstinline|list.lastIndexOf <string>str <int>start = -1|}

Возвращает индекс первой нахождения строки \code{str} в списке, ища назад с позиции \code{start}, если строка не найдена возвращает -1.

\subsubsection{\lstinline|list.mid <int>pos <int>n = -1 : list|}

Возвращает новый список, содержащий \code{n} строки, начиная со строкой с индексом \code{pos}. Если \code{n} имеет значение \code{-1} то будут добавлены все значение до конца списка.

\subsubsection{\lstinline|list.prepend <string>str : list|}

Вставит строку \code{str} в начале списка.

\subsubsection{\lstinline|list.move <int>from <int>to : list|}

Переставит строку с индексом \code{from} в позиции с индексом \code{to}.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|list.removeAll <string>str : list|}

Удаляет все нахождения строке \code{str}.

\subsubsection{\lstinline|list.removeAt <int>i : list|}

Удаляет \code{i}-я строка.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|list.removeDuplicates : list|}

Удаляет повторы строк.

\subsubsection{\lstinline|list.removeFirst : list|}

Удаляет первую строку.

Возможные исключения: \ferror{EmptyList}.

\subsubsection{\lstinline|list.removeLast : list|}

Удаляет последнюю строку.

Возможные исключения: \ferror{EmptyList}.

\subsubsection{\lstinline|list.removeOne <string>str : bool|}

Удаляет первое нахождение строке \code{str}. Возвращает \true, если строка была найдена, иначе \false.

\subsubsection{\lstinline|list.replaceInStrings <string>before <string>after : list|}

Заменяет подстроку \code{before} с подстрокой \code{after} в каждом строке.

\subsubsection{\lstinline|list.sort <bool>caseSensitive = true : list|}

Сортирует строки в алфавитном порядке.

%\newpage
\section{Множества}

{\bf Множества} (тип \set) позволяют хранить несколько объектов (тип \object) без повторений, для множеств доступны операции как пересечение, объединение.

\subsection{{\color{lightblue} object}}

Объект позволяет хранить несколько переменных, каждая хранимая переменная имеет тип и название. Доступ к переменным осуществляется через свойства объекта, где название свойств и есть название переменных.

Поле объектов множества описаны в заголовке множества.

\subsection{Свойства}

Множества имеют следующие свойства:
\begin{icItems}
\item \lstinline|[r/o] set'capacity : int|;
\item \lstinline|[r/o] set'empty : bool|;
\end{icItems}

\subsubsection{\lstinline|[r/o] set'capacity : int|}

Возвращает количество объектов которых можно хранить в память без дополнительных выделений.

\subsubsection{\lstinline|[r/o] set'empty : bool|}

Множество считается пустой если оно не содержит ни один объект.

\subsection{Методы}

Множество имеет следующие методы:
\begin{icItems}
\item \lstinline|set.applicate <list ...>data|;
\item \lstinline|set.clear : set|;
\item \lstinline|set.getField <string>name <list>value : list|;
\item \lstinline|set.insert <any ...>data : set|;
\item \lstinline|set.insert <object>obj : set|;
\item \lstinline|set.insertBoolField <string>name <list>values : set|;
\item \lstinline|set.insertDoubleField <string>name <list>values : set|;
\item \lstinline|set.insertIntField <string>name <list>values : set|;
\item \lstinline|set.insertListField <string>name <list>value : set|;
\item \lstinline|set.insertStringField <string>name <list>values : set|;
\item \lstinline|set.remove <any ...>data : set|;
\item \lstinline|set.remove <object>obj : set|;
\item \lstinline|set.removeField <string>name : set|.
\end{icItems}

Код использующий выше перечисленных методов представлен на листинге \ref{setmethods};

\begin{lstlisting}[caption=Методы класса set, label=setmethods]
@set = [<int>age <string>name <string>sex]

@set.applicate 
	["23"    "45"     "67"]
	["Basil" "Nataly" "Siri"]
	["m"     "f"      "f"];
``` set = [
	[<23>age <"Basil">name  <"m">sex]
	[<45>age <"Nataly">name <"f">sex]
	[<67>age <"Siri">name   <"f">sex]
	] ```

@set.getField "name"; `` ["Basil" "Nataly" "Siri"]

@set.insert 34 "Critiano" "m";
``` set = [
	[<23>age <"Basil">name    <"m">sex]
	[<45>age <"Nataly">name   <"f">sex]
	[<67>age <"Siri">name     <"f">sex]
	[<34>age <"Cristiano"name <"m">sex]
	] ```

@set.insert [<"f">sex <"Sofia">name <19>age];
``` set = [
	[<23>age <"Basil">name    <"m">sex]
	[<45>age <"Nataly">name   <"f">sex]
	[<67>age <"Siri">name     <"f">sex]
	[<34>age <"Cristiano"name <"m">sex]
	[<19>age <"Sofia">name    <"f">sex]
	] ```

@set.insertStringField "parity" ["odd" "even"];
``` set = [
	[<23>age <"Basil">name    <"m">sex <"odd">parity]
	[<45>age <"Nataly">name   <"f">sex <"even">parity]
	[<67>age <"Siri">name     <"f">sex <"odd">parity]
	[<34>age <"Cristiano"name <"m">sex <"even">parity]
	[<19>age <"Sofia">name    <"f">sex <"odd">parity]
	] ```

@set.remove 45 "Nataly" "f" "even";
``` set = [
	[<23>age <"Basil">name    <"m">sex <"odd">parity]
	[<67>age <"Siri">name     <"f">sex <"odd">parity]
	[<34>age <"Cristiano"name <"m">sex <"even">parity]
	[<19>age <"Sofia">name    <"f">sex <"odd">parity]
	] ```

@set.remove [<34>age <"Cristiano"name <"m">sex <"even">parity];
``` set = [
	[<23>age <"Basil">name <"m">sex <"odd">parity]
	[<67>age <"Siri">name  <"f">sex <"odd">parity]
	[<19>age <"Sofia">name <"f">sex <"odd">parity]
	] ```

@set.removeField "parity";
``` set = [
	[<23>age <"Basil">name <"m">sex]
	[<67>age <"Siri">name  <"f">sex]
	[<19>age <"Sofia">name <"f">sex]
	] ```

@set.clear; `` set = []
\end{lstlisting}

\subsubsection{\lstinline|set.applicate <list ...>data|}

Количество полученных списков должна быть равна количеству полей объектов множества. Количество добавленных объектов будет ровна длине самого длинного списка из \code{data}. Из списков в которых не хватает строк, элементы будут добавлены повторно.

\subsubsection{\lstinline|set.clear : set|}

Очищает множество.

\subsubsection{\lstinline|set.getField <string>name : list|}

Возвращает список значений поле \code{name} всех объектов.

Возможные исключения: \ferror{FieldNotFound}.

\subsubsection{\lstinline|set.hasField <string>name : bool|}

Возвращает \true, если заголовок содержит поле \code{name}, иначе \false.

\subsubsection{\lstinline|set.insert <any ...>data : set|}

Вставит новый объект, значения полей (массив \code{data}) должна полностью соблюдать порядок и тип данных, определён заголовком множество.

Возможные исключения: \ferror{IncompatibleData}.

\subsubsection{\lstinline|set.insert <object>obj : set|}

Вставит новый объект, поля объекта \code{obj} должна быть совместимы полностью с заголовком множество.

Возможные исключения: \ferror{IncompatibleObject}.

\subsubsection{\lstinline|set.insertBoolField <string>name <list>values : set|}

Создаёт новое поле типа \bool. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertDoubleField <string>name <list>values : set|}

Создаёт новое поле типа \double. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertIntField <string>name <list>values : set|}

Создаёт новое поле типа \integer. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertListField <string>name <list>value : set|}

Создаёт новое поле типа \bool. Все объекты множеству получат новое поле со значением \code{value}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertStringField <string>name <list>values : set|}

Создаёт новое поле типа \str. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.remove <any ...>data : set|}

Удаляет объект, который подходит по описанию \code{data}.

\subsubsection{\lstinline|set.remove <object>obj : set|}

Удаляет объект \code{obj} из множества.

\subsubsection{\lstinline|set.removeField <string>name : set|}

Удаляет поле \code{name} с заголовка.

Возможные исключения: \ferror{FieldNotFound}.

%\newpage
\section{Веб-элементы}
\label{webelments}

{\bf Веб-элементы} (тип данных \element) представляет собой ссылки на HTML-теги веб-страницы.

Элемент считается единым если он получен с помощью функций \lstinline|_dom.query| или \lstinline|element.query|. Элемент считается коллекцией если он получен с помощью функций \lstinline|_dom.queryAll| или \lstinline|element.queryAll|. При получении элемента по индексу, результат также будет единым.

\subsection{Свойства}

Веб-элементы имеют следующее свойства:
\begin{icItems}
\item \lstinline|[r/*] element'attr-* : string|;
\item \lstinline|[r/*] element'css-* : string|;
\item \lstinline|[r/o] element'empty : bool|;
\item \lstinline|[r/o] element'enabled : bool|;
\item \lstinline|[r/o] element'length : int|;
\item \lstinline|[*/*] element'prop-* : string|;
\item \lstinline|[r/o] element'rect : object|;
\item \lstinline|[r/o] element'selected : bool|;
\item \lstinline|[r/o] element'tag : string|;
\item \lstinline|[r/o] element'text : string|;
\item \lstinline|[r/o] element'(<int> n) : element|;
\end{icItems} 

\subsubsection{\lstinline|[r/*] element'attr-* : string|}

\code{[w3c]} Возвращает значения атрибута \code{*}.

\code{[icL]} Возвращает JS-значение для запрашиваемого атрибута.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|[r/*] element'css-* : string|}

\code{[w3c]} Возвращает значения свойства CSS \code{*}.

\code{[icL]} Возвращает JS-значение для запрашиваемой свойства CSS.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|[r/o] element'empty : bool|}

Возвращает \true, если коллекция не содержит ни одного элемента, иначе \false.

\subsubsection{\lstinline|[r/o] element'enabled : bool|}

Возвращает \false, если элемент является элементом формы и он отключен, иначе \true. 

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|[r/o] element'length : int|}

Возвращает количество элементов в коллекции.

\subsubsection{\lstinline|[*/*] element'prop-* : string|}

\code{[w3c]} Возвращает значения свойства \code{*}.

\code{[icL]}  Возвращает JS-значение для запрашиваемой свойства. Тип JS-значений не определён, это можно сводить к проблемам в динамическом анализаторе кода. При использовании свойств неопределённых в главе \ref{elements:predefined:properties}, используете преобразование для указания какого типа будет результат. Если переменная уже инициализируемая, то никаких проблем не должны быть. Новых перемен инициализируете одним из следующим способом -
\begin{lstlisting}[numbers=none]
@var = element'prop-userdefined : string;
@var:string = element'prop-userdefined;
\end{lstlisting}

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|[r/o] element'rect : obj|}

Возвращает положение размер элемента на экране в CSS пикселей, а точнее объект содержащий следующее поля:
\begin{icItems}
	\item \code{x : double} - координата x относительно левого края;
	\item \code{y : double} - координата y относительно верхнего края;
	\item \code{width : double} - ширина;
	\item \code{height : double} - высота;
\end{icItems}

\code{[icL]} Возвращает \set, в случае коллекции.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|[r/o] element'selected : bool|}

Возвращает true, если элемент является включённым чекбоксом, отмеченной радио кнопкой или выбранной опцией, иначе false.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|[r/o] element'tag : string|}

Возвращает название тега.

\code{[icL]} Возвращает \listtype, в случае коллекции.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|[r/o] element'text : string|}

Возвращает текст элемента видимый на экран. 

\code{[icL]} Возвращает \listtype, в случае коллекции.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement} и \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|[r/o] element'(<int> n) : element|}

Возвращает новую коллекцию содержащую n-й элемент.

Возможные исключения: \ferror{OutOfBounds}, \ferror{StaleElementReference}.

\subsection{Операторы}

В контексте веб-элементов появляются новые операторы:
\begin{icItems}
	\item \lstinline|void % element : element|;
	\item \lstinline|element % void : element|;
	\item \lstinline|element % element : element|;
	\item \lstinline|[element ...] : element|;
\end{icItems}

\subsubsection{\lstinline|void \% element : element|}

Возвращает полученный элемент.

\subsubsection{\lstinline|element \% void : element|}

Возвращает полученный элемент.

\subsubsection{\lstinline|element \% element : element|}

Возвращает новую коллекцию, содержащая обоих элементов.

\subsubsection{\lstinline|[element ...] : element|}

Возвращает новую коллекцию, содержащая всех представленных элементов.

\subsection{Методы}

{\bf Методы} класса \code{element} делится на 2 категории: базовые и расширенные. Базовые методы определены стандартом W3C WebDriver. Расширенные методы определяются стандартом языка icL и могут быть изменены в следующих версиях языка.

\subsection{Базовые методы}

Перечень базовых методов:
\begin{icItems}
	\item \lstinline|element.clear : element|;
	\item \lstinline|element.click : element|;
	\item \lstinline|element.query <string>cssSelector : element|;
	\item \lstinline|element.query <int>by <string>selector : element|;
	\item \lstinline|element.queryAll <string>cssSelector : element|;
	\item \lstinline|element.queryAll <int>by <string>selector : element|;
	\item \lstinline|element.queryAllByXPath <string>xpath : element|;
	\item \lstinline|element.queryByXPath <string>xpath : element|;
	\item \lstinline|element.queryLink <string>name <bool>isFragment = false : element|;
	\item \lstinline|element.queryLinks <string>name <bool>isFragment = false : element|;
	\item \lstinline|element.queryTag <string>name : element|;
	\item \lstinline|element.queryTags <string>name : element|;
	\item \lstinline|element.screenshot : string|;
	\item \lstinline|element.sendKeys <int>modifiers <string>text : element|;
\end{icItems}

\subsubsection{\lstinline|element.clear : element|}

Если элемент является полем ввода данных, то ого значение очищается. Если элемент редактируемый, то его свойство \code{innerHtml} присваивается пустая строка.

\code{[icL]} Очищены будут все элементы контейнера.

Возможные исключения: \ferror{NoSessions}, \ferror{InvalidArrgument}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}, \ferror{InvalidElementState}.

\subsubsection{\lstinline|element.click : element|}

Симулирует клик по центре элемента, и ждёт загрузка страницы.

\code{[icL]} Клик будет симулирован на все элементы контейнера.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow}, \ferror{In\-validElement}, \ferror{ElementNotInteractable}, \ferror{ElementClickIntercepted} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.query <string>cssSelector : element|}

Акроним для \lstinline|element.query _by'cssSelector @cssSelector|; 

\subsubsection{\lstinline|element.query <int>by <string>selector : element|}

Параметр \code{by} получает одно из следующих значений:
\begin{icItems}
	\item \lstinline|[r/o] _by'cssSelector : 1| - селектор CSS;
	\item \lstinline|[r/o] _by'linkText : 2| - текст ссылки;
	\item \lstinline|[r/o] _by'partialLinkText : 3| - фрагмент текста ссылки;
	\item \lstinline|[r/o] _by'tagName : 4| - название тега;
	\item \lstinline|[r/o] _by'xPath : 5| - XPath.
\end{icItems}

Параметр \code{selector} получает селектор CSS, текст ссылки, фрагмент текста ссылки, название тега или XPath, в зависимость от значений первого параметра.

Метод возвращает новый \element{} содержащий первый элемент найден по нужному методу в текущем элементе.

\code{[icL]} Поиск ведётся во всех элементов контейнера.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{ElementNotFound}, \ferror{MultiEle\-ment}, \ferror{NoSuchWindow}, \ferror{NoSuchElement}, \ferror{InvalidSelector}, \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.queryAll <string>cssSelector : element|}

Акроним для \lstinline|element.queryAll _by'cssSelector @cssSelector|;

\subsubsection{\lstinline|element.queryAll <int>by <string>selector : element|}

Параметры получают такие же значения, как и в случае с \code{element.query}, только данный метод возвращает коллекцию найденных элементов или пустую коллекцию если ничего не нашлось.

\code{[icL]} Поиск ведётся во всех элементов контейнера.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement} и \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.queryAllByXPath <string>xpath : element|}

Акроним для \lstinline|element.queryAll _by'xPath @xpath|;

\subsubsection{\lstinline|element.queryByXPath <string>xpath : element|}

Акроним для \lstinline|element.query _by'xPath @xpath|;

\subsubsection{\lstinline|element.queryLink <string>name <bool>isFragment = false : element|}

Акроним для:
\begin{icItems}
	\item \lstinline|element.query _by'linkText @name|;
	\item \lstinline|element.query _by'partialLinkText @name|.
\end{icItems}

\subsubsection{\lstinline|element.queryLinks <string>name <bool>isFragment = false : element|}

Акроним для:
\begin{icItems}
	\item \lstinline|element.queryAll _by'linkText @name|;
	\item \lstinline|element.queryAll _by'partialLinkText @name|.
\end{icItems}

\subsubsection{\lstinline|element.queryTag <string>name : element|}

Акроним для \lstinline|element.query _by'tagName @name|;

\subsubsection{\lstinline|element.queryTags <string>name : element|}

Акроним для \lstinline|element.queryAll _by'tagName @name|;

\subsubsection{\lstinline|element.screenshot : string|}

Возвращает строку, содержащая код base64 скриншота элемента. Его можно сохранить как изображение используя \lstinline|_make.image <string>base64 <string>path : void|.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.sendKeys <int>modifiers <string>text : element|}

Параметр \code{modifiers} получает один из следующих параметров (или сумма нескольких из них):
\begin{icItems}
	\item \lstinline|[r/o] _key'ctrl : 1| - Control;
	\item \lstinline|[r/o] _key'shift : 2| - Shift;
	\item \lstinline|[r/o] _key'alt : 3| - Alt;
\end{icItems}

Параметр \code{text} получает текст, будущим напечатанным на клавиатуре.

Возможные исключения: \ferror{NoSessions}, \ferror{EmptyElement}, \ferror{MultiElement}, \ferror{ElementNot\-Intractable} \ferror{NoSuchWindow} и \ferror{StaleElementReference}.

\subsection{Расширенные методы}

Расширенные методы могут работать медленно в режиме тестирования при использовании внешнего браузера. При содержании нескольких элементов в коллекции, операции принимаются на каждого элемента, и возвращена будет коллекция, а не единый элемент.

Перечень расширенных методов:
\begin{icItems}
	\item \lstinline|element.add <element>other : element|;
	\item \lstinline|element.child <int>index : element|;
	\item \lstinline|element.closest <string>cssSelector : element|;
	\item \lstinline|element.contains <string>text <bool>asFragment = false : element|;
	\item \lstinline|element.copy : element|;
	\item \lstinline|element.get <int>i : element|;
	\item \lstinline|element.filter <string>cssSelector : element|;
	\item \lstinline|element.next : element|;
	\item \lstinline|element.prev : element|;
	\item \lstinline|element.parent : element|;
\end{icItems}

\subsubsection{\lstinline|element.add <element>other : element|}

Добавит все элементы коллекции \code{other}.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.child <int>i : element|}

Возвращает новый элемент, содержащая \code{i}-й дочерний элемент.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}, \ferror{OutOfBounds}.

\subsubsection{\lstinline|element.closest <string>cssSelector : element|}

Возвращает новый элемент, содержащая ближайший родительский элемент, который подходит по селектору \code{cssSelector}.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.contains <string>text <bool>asFragment = false : element|}

Возвращает новая коллекция, содержащая все элементы, которые содержат текст/фрагмент \code{text}.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.copy : element|}

Возвращает новая коллекция, содержащая все элементы текущей коллекций.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.get <int>i : element|}

Возвращает i-й элемент коллекции.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}, \ferror{OutOfBounds}.

\subsubsection{\lstinline|element.filter <string>cssSelector : element|}

Возвращает новая коллекция, содержащая все элементы, которые подходят по селектору \code{cssSelector}.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}.
\subsubsection{\lstinline|element.next : element|}

Возвращает новый элемент, содержащая следующий дочерний элемент.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.prev : element|}

Возвращает новый элемент, содержащая предыдущий дочерний элемент.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}.

\subsubsection{\lstinline|element.parent : element|}

Возвращает новый элемент, содержащая родительский элемент.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{StaleElementReference}.

\subsection{Предопределённый набор свойств}
\label{elements:predefined:properties}

В icL предопределены только те свойства, которые имеют тип данных присутствующий в icL:
\begin{icItems}
	\item Node:	
	\begin{icItems}
		\item \lstinline|[r/o] element'prop-childNodes : element [c]|;
		\item \lstinline|[r/o] element'prop-firstChild : element [i]|;
		\item \lstinline|[r/o] element'prop-innerText : string|;
		\item \lstinline|[r/o] element'prop-isConnected : bool|;
		\item \lstinline|[r/o] element'prop-lastChild : element [i]|;
		\item \lstinline|[r/o] element'prop-nodeName : string|;
		\item \lstinline|[r/o] element'prop-nodeType : int|;
		\item \lstinline|[r/*] element'prop-nodeValue : string|;
		\item \lstinline|[r/o] element'prop-parentElement : element [i]|;
		\item \lstinline|[r/o] element'prop-textContent : string|;
	\end{icItems}
	
	\item Element:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-className : string|;
		\item \lstinline|[r/o] element'prop-clientHeight : double|;
		\item \lstinline|[r/o] element'prop-clientLeft : double|;
		\item \lstinline|[r/o] element'prop-clientTop : double|;
		\item \lstinline|[r/o] element'prop-clientWidth : double|;
		\item \lstinline|[r/o] element'prop-computedName : string|;
		\item \lstinline|[r/o] element'prop-computedRole : string|;
		\item \lstinline|[r/*] element'prop-id : string|;
		\item \lstinline|[r/*] element'prop-innerHTML : string|;
		\item \lstinline|[r/o] element'prop-localName : string|;
		\item \lstinline|[r/o] element'prop-nextElementSibling : element [i]|;
		\item \lstinline|[r/*] element'prop-outerHTML : string|;
		\item \lstinline|[r/o] element'prop-prefix : string|;
		\item \lstinline|[r/o] element'prop-previousElementSibling : element [i]|;
		\item \lstinline|[r/*] element'prop-scrollHeight : double|;
		\item \lstinline|[r/*] element'prop-scrollLeft : double|;
		\item \lstinline|[r/*] element'prop-scrollTop : double|;
		\item \lstinline|[r/*] element'prop-scrollWidth : double|;
		\item \lstinline|[r/o] element'prop-tagName : string|;
		\item \lstinline|[r/o] element'prop-baseURI : string|;
	\end{icItems}
	
	\item HTMLElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-accessKey : string|;
		\item \lstinline|[r/o] element'prop-accessKeyLabel : string|;
		\item \lstinline|[r/*] element'prop-contentEditable : string|;
		\item \lstinline|[r/o] element'prop-isContentEditable : bool|;
		\item \lstinline|[r/o] element'prop-dataset : object|;
		\item \lstinline|[r/*] element'prop-dir : string|;
		\item \lstinline|[r/*] element'prop-draggable : bool|;
		\item \lstinline|[r/*] element'prop-hidden : bool|;
		\item \lstinline|[r/*] element'prop-inert : bool|;
		\item \lstinline|[r/*] element'prop-lang : string|;
		\item \lstinline|[r/o] element'prop-offsetHeight : double|;
		\item \lstinline|[r/o] element'prop-offsetLeft : double|;
		\item \lstinline|[r/o] element'prop-offsetParent : element [i]|;
		\item \lstinline|[r/o] element'prop-offsetTop : double|;
		\item \lstinline|[r/o] element'prop-offsetWidth : double|;
		\item \lstinline|[r/*] element'prop-spellcheck : double|;
		\item \lstinline|[r/*] element'prop-title : string|;
	\end{icItems}
	
	\item HTMLAnchorElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-download : string|;
		\item \lstinline|[r/*] element'prop-hash : string|;
		\item \lstinline|[r/*] element'prop-host : string|;
		\item \lstinline|[r/*] element'prop-hostname : string|;
		\item \lstinline|[r/*] element'prop-href : string|;
		\item \lstinline|[r/*] element'prop-hreflang : string|;
		\item \lstinline|[r/*] element'prop-media : string|;
		\item \lstinline|[r/*] element'prop-password : string|;
		\item \lstinline|[r/o] element'prop-origin : string|;
		\item \lstinline|[r/*] element'prop-pathname : string|;
		\item \lstinline|[r/*] element'prop-port : string|;
		\item \lstinline|[r/*] element'prop-protocol : string|;
		\item \lstinline|[r/*] element'prop-rel : string|;
		\item \lstinline|[r/*] element'prop-search : string|;
		\item \lstinline|[r/*] element'prop-target : string|;
		\item \lstinline|[r/*] element'prop-text : string|;
		\item \lstinline|[r/*] element'prop-type : string|;
		\item \lstinline|[r/*] element'prop-username : string|;
	\end{icItems}
	
	\item HTMLAreaElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-alt : string|;
		\item \lstinline|[r/*] element'prop-coords : string|;
	\end{icItems}
	
	\item HTMLButtonElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-autofocus : bool|;
		\item \lstinline|[r/*] element'prop-disabled : bool|;
		\item \lstinline|[r/o] element'prop-form : element [i]|;
		\item \lstinline|[r/*] element'prop-formAction : string|;
		\item \lstinline|[r/*] element'prop-formEnctype : string|;
		\item \lstinline|[r/*] element'prop-formMethod : string|;
		\item \lstinline|[r/*] element'prop-formNoValidate : bool|;
		\item \lstinline|[r/*] element'prop-formTarget : string|;
		\item \lstinline|[r/o] element'prop-labels : element [c]|;
		\item \lstinline|[r/*] element'prop-name : string|;
		\item \lstinline|[r/*] element'prop-value : string|;
		\item \lstinline|[r/o] element'prop-willValidate  : bool|;
	\end{icItems}
	
	\item HTMLCanvasElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-height : int|;
		\item \lstinline|[r/*] element'prop-width : int|;
	\end{icItems}
	
	\item HTMLDataListElement: \lstinline|[r/o] element'prop-options : element [c]|;
	
	\item HTMLFormElement:
	\begin{icItems}
		\item \lstinline|[r/o] element'prop-elements : element [c]|;
		\item \lstinline|[r/o] element'prop-length : int|;
		\item \lstinline|[r/*] element'prop-action : string|;
		\item \lstinline|[r/*] element'prop-encoding : string|;
		\item \lstinline|[r/*] element'prop-enctype : string|;
		\item \lstinline|[r/*] element'prop-acceptCharset : string|;
		\item \lstinline|[r/*] element'prop-autocomplete : string|;
		\item \lstinline|[r/*] element'prop-noValidate : string|;
	\end{icItems}
	
	\item HTMLIFrameElement: \lstinline|[r/*] element'prop-allowPaymentRequest|;
	
	\item HTMLImageElement:
	\begin{icItems}
		\item \lstinline|[r/o] element'prop-complete : bool|;
		\item \lstinline|[r/o] element'prop-crossOrigin : string|;
		\item \lstinline|[r/o] element'prop-isMap : bool|;
		\item \lstinline|[r/o] element'prop-naturalHeight : int|;
		\item \lstinline|[r/o] element'prop-naturalWidth : int|;
		\item \lstinline|[r/*] element'prop-src : string|;
		\item \lstinline|[r/*] element'prop-useMap : string|;
	\end{icItems}
	
	\item HTMLInputElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-accept : string|;
		\item \lstinline|[r/*] element'prop-checked : bool|;
		\item \lstinline|[r/*] element'prop-defaultChecked : bool|;
		\item \lstinline|[r/*] element'prop-defaultValue : string|;
		\item \lstinline|[r/*] element'prop-dirName : string|;
		\item \lstinline|[r/*] element'prop-indeterminate : bool|;
		\item \lstinline|[r/*] element'prop-list : element [i]|;
		\item \lstinline|[r/*] element'prop-min : string|;
		\item \lstinline|[r/*] element'prop-max : string|;
		\item \lstinline|[r/*] element'prop-maxLength : int|;
		\item \lstinline|[r/*] element'prop-multiple : bool|;
		\item \lstinline|[r/*] element'prop-pattern : string|;
		\item \lstinline|[r/*] element'prop-placeholder : string|;
		\item \lstinline|[r/*] element'prop-readOnly : bool|;
		\item \lstinline|[r/*] element'prop-required : bool|;
		\item \lstinline|[r/*] element'prop-selectionStart : int|;
		\item \lstinline|[r/*] element'prop-selectionEnd : int|;
		\item \lstinline|[r/*] element'prop-selectionDirection : string|;
		\item \lstinline|[r/*] element'prop-size : int|;
		\item \lstinline|[r/*] element'prop-step : string|;
		\item \lstinline|[r/o] element'prop-validity : bool|;
		\item \lstinline|[r/o] element'prop-validationMessage : string|;
		\item \lstinline|[r/*] element'prop-valueAsNumber : double|;
	\end{icItems}
	
	\item HTMLLabelElement:
	\begin{icItems}
		\item \lstinline|[r/o] element'prop-control : element [i]|;
		\item \lstinline|[r/*] element'prop-htmlFor : string|;
	\end{icItems}
	
	\item HTMLLinkElement: \lstinline|[r/*] element'prop-as : string|;
	\item HTMLMapElement: \lstinline|[r/o] element'prop-areas : element [c]|;
	
	\item HTMLMediaElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-autoplay : bool|;
		\item \lstinline|[r/*] element'prop-controls : bool|;
		\item \lstinline|[r/o] element'prop-currentSrc : string|;
		\item \lstinline|[r/*] element'prop-currentTime : double|;
		\item \lstinline|[r/*] element'prop-defaultMuted : bool|;
		\item \lstinline|[r/*] element'prop-defaultPlaybackRate : bool|;
		\item \lstinline|[r/*] element'prop-disableRemotePlayback : bool|;
		\item \lstinline|[r/o] element'prop-duration : double|;
		\item \lstinline|[r/o] element'prop-ended : bool|;
		\item \lstinline|[r/*] element'prop-loop : bool|;
		\item \lstinline|[r/*] element'prop-mediaGroup : string|;
		\item \lstinline|[r/*] element'prop-muted : bool|;
		\item \lstinline|[r/o] element'prop-networkState : int|;
		\item \lstinline|[r/o] element'prop-paused : bool|;
		\item \lstinline|[r/*] element'prop-playbackRate : double|;
		\item \lstinline|[r/*] element'prop-preload : string|;
		\item \lstinline|[r/o] element'prop-readyState : int|;
		\item \lstinline|[r/o] element'prop-seeking : bool|;
		\item \lstinline|[r/*] element'prop-volume : double|;
	\end{icItems}
	
	\item HTMLMetaElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-content : string|;
		\item \lstinline|[r/*] element'prop-httpEquiv : string|;
	\end{icItems}
	
	\item HTMLMeterElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-high : double|;
		\item \lstinline|[r/*] element'prop-low : double|;
	\end{icItems}
	
	\item HTMLModElement: \lstinline|[r/*] element'prop-cite : string|;
	
	\item HTMLOListElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-reversed : bool|;
		\item \lstinline|[r/*] element'prop-start : int|;
	\end{icItems}
	
	\item HTMLOptionElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-defaultSelected : bool|;
		\item \lstinline|[r/o] element'prop-index : int|;
		\item \lstinline|[r/*] element'prop-label : string|;
		\item \lstinline|[r/*] element'prop-selected : bool|;
	\end{icItems}
	
	\item HTMLProgressElement: \lstinline|[r/o] element'prop-position : double|;
	
	\item HTMLScriptElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-charset : string|;
		\item \lstinline|[r/*] element'prop-async : bool|;
		\item \lstinline|[r/*] element'prop-defer : bool|;
		\item \lstinline|[r/*] element'prop-noModule : bool|;
	\end{icItems}
	
	\item HTMLSelectElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-selectedIndex : int|;
		\item \lstinline|[r/o] element'prop-selectedOptions : element [c]|;
	\end{icItems}
	
	\item HTMLTableCellElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-abbr : string|;
		\item \lstinline|[r/o] element'prop-cellIndex : int|;
		\item \lstinline|[r/*] element'prop-colSpan : int|;
		\item \lstinline|[r/*] element'prop-rowSpan : int|;
		\item \lstinline|[r/*] element'prop-scope : string|;
	\end{icItems}
	
	\item HTMLTableColElement: \lstinline|[r/*] element'prop-span : int|;
	
	\item HTMLTableElement:
	\begin{icItems}
		\item \lstinline|[r/o] element'prop-caption : element [i]|;
		\item \lstinline|[r/o] element'prop-tBodies : element [c]|;
		\item \lstinline|[r/o] element'prop-tHead : element [i]|;
		\item \lstinline|[r/o] element'prop-tFoot : element [i]|;
	\end{icItems}
	
	\item HTMLTableRowElement:
	\begin{icItems}
		\item \lstinline|[r/o] element'prop-cells : element [c]|;
		\item \lstinline|[r/o] element'prop-rowIndex : int|;
	\end{icItems}
	
	\item HTMLTextAreaElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-cols : int|;
		\item \lstinline|[r/o] element'prop-textLength : int|;
		\item \lstinline|[r/*] element'prop-wrap : string|;
	\end{icItems}
	
	\item HTMLTimeElement: \lstinline|[r/*] element'prop-dateTime : string|;
	
	\item HTMLTrackElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-kind : string|;
		\item \lstinline|[r/*] element'prop-srclang : string|;
		\item \lstinline|[r/*] element'prop-label : string|;
		\item \lstinline|[r/*] element'prop-default : bool|;
	\end{icItems}
	
	\item HTMLVideoElement:
	\begin{icItems}
		\item \lstinline|[r/*] element'prop-poster : string|;
		\item \lstinline|[r/*] element'prop-videoHeight : int|;
		\item \lstinline|[r/*] element'prop-videoWidth : int|;
	\end{icItems}
	
	% \item \lstinline|[r/w] element'prop-|;
\end{icItems}

\code{element [c]} будет всегда коллекцией, \code{element [i]} - варьирует в зависимости от субъекта, если субъект - элемент, результат также будет элементом, если субъект - коллекция, результат также будет коллекцией. 

Напоминаю что стандарт W3C WebDriver предусматривает чтения свойств только для элементов, и в режиме тестирования все свойства будут доступны только для чтения.

Свойства \code{rows} не указано в данном списке, потому что оно повторяется у разных элементов имея разные типы.

%\newpage
\section{Обмен данных с веб-странице}
\label{dataexchange}

\subsubsection{Название странице}

Название страницы можно получить вызывая \lstinline|[r/*] _tab'title : string|.

\subsubsection{Исходный код}

Исходный код страницы можно получить вызывая \lstinline|[r/o] _tab'source : string|.

\subsubsection{Screenshot}

Screenshot страницы в base64 можно получить вызывая \lstinline|[r/o] _tab'screenshot : string|.

\subsubsection{URL}

Адрес доступен через свойство \lstinline|[r/w] _tab'url : string|.

\subsubsection{Навигация}

\lstinline|_tab.back : void| - позволяет возвращаться на предыдущую страницу.

\lstinline|_tab.forward : void| - позволяет возвращаться на следующую страницу.

\lstinline|_tab.refresh : void| -  позволяет перезагрузить страницу.

\lstinline|[icL] [r/o] _tab'canGoBack : bool| - сообщает можно ли перейти на предыдущую страницу.

\lstinline|[icL] [r/o] _tab'canGoForward : bool| - сообщает можно ли перейти на следующую страницу.


\subsubsection{Предупреждения}

\lstinline|[r/o] _alert'text : string| - текст предупреждений.

\lstinline|_alert.accept : void| - закрыть окно отвечая положительным ответом.

\lstinline|_alert.dismiss : void| - закрыть окно отвечая отрицательным ответом.

\lstinline|_alert.sendKeys <string>str : void| - ответить текстом \code{str}.

% Возможные исключения: \ferror{NoSuchWindow}, \ferror{NoSuchAlert}, \ferror{ElementNotInteractable}.

%\newpage
\section{DSV: CSV и TSV}

{\bf DSV (Delimiter Separated Values, Значения Разделены Разделителем)} представляет собой текстовый файл, содержащий значения в текстовом виде.

{\bf CSV (Comma Separated Values, Значения Разделены Запятыми)} использует запятые в качестве разделителя, формат очень знаменитый и используется часто офисными программами. Больше о нём можете прочитать в интернете.

{\bf TSV (Tab Separated Values, Значения Разделены Символом Табуляции)} более простой, использует символ табуляции в качестве разделителя и используется во веб-приложениях.

icL позволяет делать следующие действия с файлами такого рода:
\begin{icItems}
	\item Загрузить;
	\item Записать;
	\item Вставить;
	\item Синхронизировать.
\end{icItems}

\subsection{Загрузка}

\subsubsection{\lstinline|_dsv.load <string>delimiter <_file>f : set|;}

Возвращает множество содержащая все данные из файла \code{f}. Строка \code{delimiter} должна состоять из одного символа - нужного разделителя. Объект файл можно создать через \lstinline|_files.create <string>path : _file|, если файл не существует, он будет создан, иначе будет открыт.

Возможные исключения: \ferror{ParsingFailed}, \ferror{WrongDelimiter}.

\subsubsection{\lstinline|_dsv.loadCSV <_file>f : _file|;}

Акроним для \lstinline|_dsv.load "," f|.

\subsubsection{\lstinline|_dsv.loadTSV <_file>f : _file|;}

TSV отличается от остальных, файлы обработаются по другому алгоритму, по этому данная функция не имеет эквивалент и не является акронимом.

\subsection{Запись}

\subsubsection{\lstinline|_dsv.write <_file>f <set>s: _file|;}

Вся содержимое файла будет перезаписано.

\subsection{Вставка}

Содержимое файла не трогается, новые записи записываются в конце файла. За совместимость с предыдущих отвечает пользователь, icL не проверяет предыдущие записи.

\subsubsection{\lstinline|_dsv.append <_file>f <set>s : _file|;}

Вставит все объект множество \code{s}.

\subsubsection{\lstinline|_dsv.append <_file>f <object>obj : _file|;}

Вставит отдельный объект \code{obj}.

\subsection{Синхронизация}

\subsubsection{\lstinline|_dsv.sync <_file>f <set>s : set|;}

При установке связи синхронизации файл перезаписывается полностью. При добавлениях записей они будут вставлены в конце. При удалении записей файл перезаписывается полностью.

%\newpage
\section{Преобразование типов}

Для преобразования данных в icL присутствуют 3 операторы первого ранга:
\begin{icItems}
	\item \lstinline|data : type : type|;
	\item \lstinline|data :: type : bool|;
	\item \lstinline|data :* type : bool|;
\end{icItems}

\subsubsection{\lstinline|data : type : type|}

Преобразует данные в нужном типа данных.

Возможные исключения: \ferror{UnrealCast}, \ferror{ParsingFailed}, \ferror{EmptyList}, \ferror{MultiList}, \ferror{IncompatibleObject}, \ferror{IncompatibleRoot} и \ferror{ComplexField}.

\subsubsection{\lstinline|data :: type : bool|}

Возвращает \true, если данные имеют нужный тип, иначе \false.

\subsubsection{\lstinline|data :* type : bool|}

Возвращает \true, если данные могут быть преобразованы в нужном типе, иначе \false.

\subsection{Возможные преобразования}

В таблице \ref{castingtable} представлены совместимость преобразовании данных. Минусом отмечены невозможные преобразования, они всегда генерируют ошибку \ferror{UnrealCast}. Плюсом отмечены преобразования, которые никогда не генерируют ошибки. Звёздочкой отмечены возможные преобразования, но они также могут генерировать ошибки. В названии столбцов указан изначальный тип данных, в названии строки указан желаемый тип данных.

\begin{table}[htb]
	\caption{Таблица преобразований}
	\label{castingtable}
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|}
		\hline
		          & \void & \bool & \integer & \double & \str & \listtype & \object & \set & \element \\ \hline
		\void     & +     & -     & -        & -       & -    & -         & -       & -    & -        \\ \hline
		\bool     & +     & +     & +        & +       & +    & +         & +       & +    & +        \\ \hline
		\integer  & +     & +     & +        & +       & *    & -         & -       & -    & -        \\ \hline
		\double   & +     & +     & +        & +       & *    & -         & -       & -    & -        \\ \hline
		\str      & +     & +     & +        & +       & +    & *         & +       & +    & +        \\ \hline
		\listtype & +     & -     & -        & -       & +    & +         & -       & +    & -        \\ \hline
		\object   & +     & -     & -        & -       & *    & -         & +       & *    & -        \\ \hline
		\set      & +     & -     & -        & -       & *    & *         & -       & +    & -        \\ \hline
		\element  & +     & -     & -        & -       & -    & -         & -       & -    & +        \\ \hline
	\end{tabular}
\end{table}

\subsubsection{\lstinline|void : void|}

Возвращает исходный объект.

\subsubsection{\lstinline|void : bool|}

Возвращает \false.

\subsubsection{\lstinline|void : int|}

Возвращает \lstinline|0|.

\subsubsection{\lstinline|void : double|}

Возвращает \lstinline|0.0|.

\subsubsection{\lstinline|void : string|}

Возвращает \lstinline|""|.

\subsubsection{\lstinline|void : list|}

Возвращает \lstinline|[]|.

\subsubsection{\lstinline|void : object|}

Возвращает \lstinline|[<>]|.

\subsubsection{\lstinline|void : set|}

Возвращает пустое множество.

\subsubsection{\lstinline|void : element|}

Возвращает пустая коллекция.

\subsubsection{\lstinline|bool : bool|}

Возвращает исходный объект.

\subsubsection{\lstinline|bool : int|}

Возвращает \lstinline|1|, если логическое значение - единица, иначе \lstinline|0|.

\subsubsection{\lstinline|bool : double|}

Возвращает \lstinline|1.0|, если логическое значение - единица, иначе \lstinline|0.0|.

\subsubsection{\lstinline|bool : string|}

Возвращает \lstinline|"true"|, если логическое значение - единица, иначе \lstinline|"false"|.

\subsubsection{\lstinline|int : bool|}

Возвращает значение выражений \lstinline|int != 0|.

\subsubsection{\lstinline|int : int|}

Возвращает исходный объект.

\subsubsection{\lstinline|int : double|}

Возвращает вещественное число, имеющее целая часть равна \integer, а дробная равна нулю.

\subsubsection{\lstinline|int : string|}

Возвращает строку, содержащая строковое представление числа \integer.

\subsubsection{\lstinline|double : bool|}

Возвращает значение выражений \lstinline|double != 0.0|.

\subsubsection{\lstinline|double : int|}

Возвращает целое число, равна целой части числа \double. Дробная часть пропадёт.

\subsubsection{\lstinline|double : double|}

Возвращает исходный объект.

\subsubsection{\lstinline|double : string|}

Возвращает строку, содержащая строковое представление числа \double.

\subsubsection{\lstinline|string : bool|}

Возвращает значение выражений \lstinline|!string'empty|.

\subsubsection{\lstinline|string : int|}

Возвращает целое число, являющейся результат парсинга строки \str.

Возможные исключения: \ferror{ParsingFailed}.

\subsubsection{\lstinline|string : double|}

Возвращает вещественное число, являющейся результат парсинга строки \str. Целая часть от дробной делить надо точкой, ан запятой.

Возможные исключения: \ferror{ParsingFailed}.

\subsubsection{\lstinline|string : string|}

Возвращает исходный объект.

\subsubsection{\lstinline|string : list|}

Возвращает \lstinline|[string]|.

\subsubsection{\lstinline|string : object|}

Возвращает объект, являющийся результат парсинга JSON-строки \str. JSON-объект должен иметь поля только следующих типов: \bool, \integer, \double, \str{} и \listtype.

Возможные исключения: \ferror{ParsingFailed}, \ferror{IncompatibleRoot} и \ferror{ComplexField}.

\subsubsection{\lstinline|string : set|}

Возвращает множество, являющийся результат парсинга JSON-строки \str, которая должна содержать массив объект, а каждый объект должен соответствовать критерия оператора \lstinline|string : object|.

Возможные исключения: \ferror{ParsingFailed}, \ferror{IncompatibleObject}, \ferror{IncompatibleRoot} и \ferror{ComplexField}.

\subsubsection{\lstinline|list : bool|}

Возвращает значение выражений \lstinline|!list'empty|.

\subsubsection{\lstinline|list : string|}

Возвращает первую строку списка, если список состоит только из одной строки, иначе генерирует исключение.

Возможные исключения: \ferror{EmptyList} и \ferror{MultiList}.

\subsubsection{\lstinline|list : list|}

Возвращает исходный объект.

\subsubsection{\lstinline|list : set|}

Каждая строка списка будет преобразовано в объекте оператором \lstinline|string : object|, получены объекты будут группированы в множестве, полученная множество будет возвращена оператором.

\subsubsection{\lstinline|object : bool|}

Возвращает \true, если объект хранит хотя бы одну переменную, иначе \false.

\subsubsection{\lstinline|object : string|}

Возвращает JSON-строку, описывающая объект.

\subsubsection{\lstinline|object : object|}

Возвращает исходный объект.

\subsubsection{\lstinline|set : bool|}

Возвращает значение выражений \lstinline|!set'empty|.

\subsubsection{\lstinline|set : string|}

Возвращает JSON-строку, описывающая множеству.

\subsubsection{\lstinline|set : object|}

Возвращает единственный объект, если множество содержит только один объект, иначе генерирует исключение.

Возможные исключения: \ferror{EmptySet} и \ferror{MultiSet}.

\subsubsection{\lstinline|set : list|}

Возвращает список JSON-строк, где каждая строка описывает объект множества.

\subsubsection{\lstinline|set : set|}

Возвращает исходный объект.

\subsubsection{\lstinline|element : bool|}

Возвращает значение выражений \lstinline|!element'empty|.

\subsubsection{\lstinline|element : string|}

Возвращает строка, описывающая последовательность действий, при которых была получена данная коллекция.

\subsubsection{\lstinline|element : element|}

Возвращает исходный объект.

\newpage
\part{Материал для программистов}

Для освоение данного материала нужны знания в программирование. В ней не будет прописано обозначения технических терминов. Несмотря на то что язык icL - простой, на него можно реализовать сложные скрипты, работы с базами данных, регулярных выражении и много другое, ожидается сильное развитие данной части в следующих версиях языка icL.

\section{Дополнительные возможности}

{\bf Дополнительные возможности} присутствуют в icL для полного перекрытия стандарта W3C WebDriver и для решения определённых проблем, которые могут появиться при написании скриптов.

Данные возможности не обязательно использовать, так как при запуске скрипта создаётся сессия и открывается новая вкладка, и при остановке сессия закрывается автоматически.

% \subsection{Возможности W3C WebDriver}

\subsection{{\color{orange} \_sessions}}

Объект \sessions{} имеет следующие свойства:
\begin{icItems}
	\item \lstinline|[r/o] _sessions'length : int|;
	\item \lstinline|[r/o] _sessions'(<int>i) : _session|.
\end{icItems}

И следующие методы:
\begin{icItems}
	\item \lstinline|_sessions.closeAll : void|;
	\item \lstinline|_sessions.get <int>i : _session|;
	\item \lstinline|_sessions.new : _session|.
\end{icItems}

\subsubsection{\lstinline|[r/o] _sessions'length : int|}

Возвращает количество отрытых сессии.

\subsubsection{\lstinline|[r/o] _sessions'(<int>i) : _session|}

Возвращает \code{i}-ю сессию.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_sessions.closeAll : void|}

Закрывает всех сессий.

\subsubsection{\lstinline|_sessions.get <int>i : _session|}

Возвращает \code{i}-ю сессию.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_sessions.new : _session|}

Отрывает новую сессию.

Возможные исключения: \ferror{SessionNotCreated}.

\subsection{{\color{orange} \_session}}

Команда \session{} возвращает указатель на текущей сессии.

Объект \session{} имеет следующие свойства:
\begin{icItems}
	\item \lstinline|[r/w] _session'implicitTimeout : int|;
	\item \lstinline|[r/w] _session'pageLoadTimeout : int|;
	\item \lstinline|[r/w] _session'scriptTimeout : int|;
	\item \lstinline|[r/o] _session'source : string|;
	\item \lstinline|[r/o] _session'title : string|;
	\item \lstinline|[r/w] _session'url : string|.
\end{icItems}

И следующие методы:
\begin{icItems}
	\item \lstinline|_session.back : _sesion|;
	\item \lstinline|_session.close : void|;
	\item \lstinline|_session.forward : _session|;
	\item \lstinline|_session.refresh : _session|;
	\item \lstinline|_session.screenshot : string|;
	\item \lstinline|_session.switchTo : _session|.
\end{icItems}

\subsubsection{\lstinline|[r/w] _session'implicitTimeout : int|}

Время ожидания в миллисекундах нахождения элемента и перехода элемента в состоянии доступности для взаимодействий с ним. По умолчанию равна нулю.

Возможные исключения: \ferror{NoSessions}, \ferror{InvalidArgument} (значение для установки меньше нуля или больше максимальной безопасной целей значений).

\subsubsection{\lstinline|[r/w] _session'pageLoadTimeout : int|}

Время ожидания загрузке страницы. По умолчанию 300 000 миллисекунд.

Возможные исключения: \ferror{NoSessions}, \ferror{InvalidArgument}.

\subsubsection{\lstinline|[r/w] _session'scriptTimeout : int|}

Время ожидания синхронией выполнения кода на языке Javascript. По умолчанию 30 000 миллисекунд.

Возможные исключения: \ferror{NoSessions}, \ferror{InvalidArgument}.

\subsubsection{\lstinline|[r/o] _session'source : string|}

Исходный код страницы.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|[r/o] _session'title : string|}

Название страницы.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|[r/w] _session'url : string|}

Адрес текущей странице.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_session.back : _session|}

Переходит на предыдущую страницу, как при нажатии на кнопке браузера "Назад".

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{Timeout}.

\subsubsection{\lstinline|_session.close : void|}

Прекращает сессию. Все вкладки будут закрыты.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSessions}, \ferror{NoSuchSession}.

\subsubsection{\lstinline|_session.forward : _session|}

Вернётся на следующую страницу, как при нажатии на кнопке браузера "Вперёд".

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{Timeout}.

\subsubsection{\lstinline|_session.refresh : _session|}

Перезагружает страницу.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{Timeout}.

\subsubsection{\lstinline|_session.screenshot : string|}

Возвращает скриншот, изображение кодируется в строке base64.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{UnableToCaptureScreen}.

\subsubsection{\lstinline|_session.switchTo : _session|}

Переключает активную сессию.

Возможные исключения: \ferror{NoSuchSession}.

%\subsubsection{}

\subsection{{\color{orange} \_windows}}

Объект \windows{} имеет следующие свойства:
\begin{icItems}
	\item \lstinline|_windows'length : int|;
	\item \lstinline|_windows'(<int>i) : _window|.
\end{icItems}

И следующий метод \lstinline|_windows.get <int>i : _window|.

\subsubsection{\lstinline|_windows'length : int|}

Возвращает количество окон в текущей сессии.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_windows'(<int>i) : _window|}

Возвращает \code{i}-е окно.

Возможные исключения: \ferror{NoSessions}, \ferror{OutOfBounds}.

\subsubsection{\lstinline|_windows.get <int>i : _window|}

Возвращает \code{i}-е окно.

Возможные исключения: \ferror{NoSessions}, \ferror{OutOfBounds}.

\subsection{{\color{orange} \_window}}

Объект \window{} имеет следующие свойства:
\begin{icItems}
	\item \lstinline|[r/w] _window'height : int|;
	\item \lstinline|[r/w] _window'width : int|;
	\item \lstinline|[r/w] _window'x : int|;
	\item \lstinline|[r/w] _window'y : int|.
\end{icItems}

И следующие методы:
\begin{icItems}
	\item \lstinline|_window.close : void|;
	\item \lstinline|_window.focus : _window|;
	\item \lstinline|_window.fullscreen : _window|;
	\item \lstinline|_window.maximize : _window|;
	\item \lstinline|_window.minimize : _window|;
	\item \lstinline|_window.restore : _window|;
	\item \lstinline|_window.switchToDefault : _window|;
	\item \lstinline|_window.switchToFrame <int>i : _window|;
	\item \lstinline|_window.switchToFrame <element>el : _window|;
	\item \lstinline|_window.switchToParent : _window|.
\end{icItems}

\subsubsection{\lstinline|[r/w] _window'height : int|}

Высота текущей окно в пикселях.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{InvalidArgument}, \ferror{UnsupportedOperation}.

\subsubsection{\lstinline|[r/w] _window'width : int|}

Ширина текущей окно в пикселях.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{InvalidArgument}, \ferror{UnsupportedOperation}.

\subsubsection{\lstinline|[r/w] _window'x : int|}

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{InvalidArgument}, \ferror{UnsupportedOperation}.

Координата $x$ текущей окно в пикселях.

\subsubsection{\lstinline|[r/w] _window'y : int|}

Координата $y$ текущей окно в пикселях.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{InvalidArgument}, \ferror{UnsupportedOperation}.

\subsubsection{\lstinline|_window.close : void|}

Закрывает окну, если она последняя закрывается и сессию.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_window.focus : _window|}

Делает окну активной.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_window.fullscreen : _window|}

Переключает режим отображения окна на полный экран.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_window.maximize : _window|}

Распахнет окно.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_window.minimize : _window|}

Свернёт окно.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_window.restore : _window|}

Восстановит окно в нормальном режиме.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_window.switchToDefault : _window|}

Переключает фокус на главный frame.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_window.switchToFrame <int>i : _window|}

Переключает фокус на frame с индексом \code{i}.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{NoSuchFrame}.

\subsubsection{\lstinline|_window.switchToFrame <element>el : _window|}

Переключает фокус на frame элемента \code{el}. Элемент должен быть обязательно тэгом frame или iframe.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{NoSuchFrame}, \ferror{StaleElementReference}.

\subsubsection{\lstinline|_window.switchToParent : _window|}

Переключает фокус на родительский frame.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsection{{\color{orange} \_cookies}}

Объект \cookies{} имеет следующее свойство: \lstinline|[r/o] _cookies'<string>name : _cookie|.

И следующие методы: 
\begin{icItems}
	\item \lstinline|_cookies.deleteAll : void|;
	\item \lstinline|_cookies.get <string>name : _cookie|.
\end{icItems}

\subsubsection{\lstinline|[r/o] _cookies'<string>name : _cookie|}

Возвращает \cookie{} с нужным названием.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{NoSuchCookie}.

\subsubsection{\lstinline|_cookies.deleteAll : void|}

Удаляет всеx существующих cookie.

\subsubsection{\lstinline|_cookies.get <string>name : _cookie|}

Возвращает \cookie{} с нужным названием.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{NoSuchCookie}.

\subsection{{\color{orange} \_cookie}}

Объект \cookie{} имеет следующие свойства:
\begin{icItems}
	\item \lstinline|[r/w] _cookie'domain : string|;
	\item \lstinline|[r/w] _cookie'expiry : int|;
	\item \lstinline|[r/w] _cookie'httpOnly : bool|;
	\item \lstinline|[r/w] _cookie'name : string|;
	\item \lstinline|[r/w] _cookie'path : string|;
	\item \lstinline|[r/w] _cookie'secure : bool|;
	\item \lstinline|[r/w] _cookie'value : string|.
\end{icItems}

И следующие методы:
\begin{icItems}
	\item \lstinline|_cookie.add <int>years <int>months <int>days <int>hours = 0 <int>minutes = 0 <int>seconds = 0 : _cookie|;
	\item \lstinline|_cookie.load : _cookie|;
	\item \lstinline|_cookie.resetTime : _cookie|;
	\item \lstinline|_cookie.save : _cookie|.
\end{icItems}

\subsubsection{\lstinline|[r/w] _cookie'domain : string|}

Доменное имя, на которым cookie доступен.

\subsubsection{\lstinline|[r/w] _cookie'expiry : int|}

Время указывающая срок годности cookie. По умолчанию -1, указывает на то что cookie будет удален при окончания сессии.

\subsubsection{\lstinline|[r/w] _cookie'httpOnly : bool|}

Значение по умолчанию - \false.

\subsubsection{\lstinline|[r/w] _cookie'name : string|}

Название, обязательное для заполнения.

\subsubsection{\lstinline|[r/w] _cookie'path : string|}

Значение по умолчанию - \lstinline|"/"|.

\subsubsection{\lstinline|[r/w] _cookie'secure : bool|}

Значение по умолчанию - \false.

\subsubsection{\lstinline|[r/w] _cookie'value : string|}

Значение самого cookie, обязательное для заполнения.

\subsubsection{\lstinline|_cookie.add <int>years <int>months <int>days <int>hours = 0 <int>minutes = 0|\\*\noindent\lstinline|<int>seconds = 0 : _cookie|}

Добавляет к сроку годности ножное количество лет, месяцев, дней, часов, минут и секунд.

\subsubsection{\lstinline|_cookie.load : _cookie|}

Загружает данные о cookie с браузера.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{NoSuchCookie}.

\subsubsection{\lstinline|_cookie.resetTime : _cookie|}

Сбросит строк на текущее время. Например установить срок годности год: \lstinline|_cookie.resetTime.add 1 0 0|.

\subsubsection{\lstinline|_cookie.save : _cookie|}

Сохраняет изменения в браузере.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{InvalidArgument}, \ferror{UnableToSetCookie}, \ferror{InvalidCookieDomain}.

\subsubsection{Создать новый cookie}

На листинге \ref{newcookies}, представлен правильный способ создания новых cookie.

\begin{lstlisting}[caption=Создания новых cookie, label=newcookies]
for any _cookie {
	@'name = "age";
	@'domain = "example.org";
	@'value = 23 : string;
	@.resetTime.add 1 0 0;
	@.save;
};
\end{lstlisting}


\subsection{{\color{orange} \_alert}}

Объект \alert{} имеет следующее свойство: \lstinline|[r/o] _alert'text : string|.

И следующие методы:
\begin{icItems}
	\item \lstinline|_alert.accept : void|;
	\item \lstinline|_alert.dismiss : void|;
	\item \lstinline|_alert.sendKeys <string>keys : void|.
\end{icItems}

\subsubsection{\lstinline|[r/o] _alert'text : string|}

Возвращает текст предупреждений.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{NoSuchAlert}.

\subsubsection{\lstinline|_alert.accept : void|}

Принимает предупреждению.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{NoSuchAlert}.

\subsubsection{\lstinline|_alert.dismiss : void|}

Отменяет предупреждению.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{NoSuchAlert}.

\subsubsection{\lstinline|_alert.sendKeys <string>keys : void|}

Заполняет форму текстом \code{keys} и подтверждает ввод.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{NoSuchAlert}, \ferror{ElementNotIn\-teractable}.

% \subsection{Возможности icL}

\subsection{{\color{orange} \_tabs}}

Объект \tabs{} имеет следующие свойства:
\begin{icItems}
	\item \lstinline|[r/o] _tabs'current : _tab|;
	\item \lstinline|[r/o] _tabs'first : _tab|;
	\item \lstinline|[r/o] _tabs'last : _tab|;
	\item \lstinline|[r/o] _tabs'length : int|;
	\item \lstinline|[r/o] _tabs'next : _tab|;
	\item \lstinline|[r/o] _tabs'previous : _tab|;
	\item \lstinline|[r/o] _tabs'(<int>i) : _tab|.
	% \item \lstinline|_tabs'|;
\end{icItems}

И следующие методы:
\begin{icItems}
	\item \lstinline|_tabs.close <string>template : int|;
	\item \lstinline|_tabs.close <regex>url : int|;
	\item \lstinline|_tabs.closeByTitle <string>template : int|;
	\item \lstinline|_tabs.closeByTitle <regex>title : int|;
	\item \lstinline|_tabs.closeOthers : int|;
	\item \lstinline|_tabs.closeToLeft : int|;
	\item \lstinline|_tabs.closeToRight : int|;
	\item \lstinline|_tabs.find <string>template : _tab|;
	\item \lstinline|_tabs.find <regex>url : _tab|;
	\item \lstinline|_tabs.findByTitle <string>template : _tab|;
	\item \lstinline|_tabs.findByTitle <regex>title : _tab|.
	% \item \lstinline|_tabs.|;
\end{icItems}

В режиме тестирования вкладки будут в произвольном порядке. В режиме автоматизации в строгом порядке.

\subsubsection{\lstinline|[r/o] _tabs'current : _tab|}

Текущая вкладка.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|[r/o] _tabs'first : _tab|}

Первая вкладка.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|[r/o] _tabs'last : _tab|}

Последняя вкладка.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|[r/o] _tabs'length : int|}

Количество вкладок.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|[r/o] _tabs'next : _tab|}

Следующая вкладка.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchTab}.

\subsubsection{\lstinline|[r/o] _tabs'previous : _tab|}

Предыдущая вкладка.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchTab}.

\subsubsection{\lstinline|[r/o] _tabs'(<int>i) : _tab|}

\code{i}-я вкладка.

Возможные исключения: \ferror{NoSessions}, \ferror{OutOfBounds}.

\subsubsection{\lstinline|_tabs.close <string>template : int|}

Закрывает все вкладки, у которых URL подходит по шаблону. Возвращает количество закрытых вкладок.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.close <regex>url : int|}

Закрывает все вкладки, имеющее URL подходящий по регулярному выражению \code{url}. Возвращает количество закрытых вкладок.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.closeByTitle <string>template : int|}

Закрывает все вкладки, у которых название подходит по шаблону. Возвращает количество закрытых вкладок.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.closeByTitle <regex>title : int|}

Закрывает все вкладки, имеющее название подходяще по регулярному выражению \code{url}. Возвращает количество закрытых вкладок.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.closeOthers : int|}

Закрывает все вкладки кроме текущей. Возвращает количество закрытых вкладок.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.closeToLeft : int|}

Закрывает все вкладки которые находится с лева от текущей. Возвращает количество закрытых вкладок.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.closeToRight : int|}

Закрывает все вкладки которые находится с права от текущей. Возвращает количество закрытых вкладок.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.find <string>template : _tab|}

Возвращает первая вкладка, у которой URL подходит по шаблону.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.find <regex>url : _tab|}

Возвращает первая вкладка, у которой URL подходит по регулярному выражению.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.findByTitle <string>template : _tab|}

Возвращает первая вкладка, у которой название подходит по шаблону.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tabs.findByTitle <regex>title : _tab|}

Возвращает первая вкладка, у которой название подходит по регулярному выражению.

Возможные исключения: \ferror{NoSessions}.

\subsection{{\color{orange} \_tab}}

Объект \tab{} имеет следующие свойства:
\begin{icItems}
	\item \lstinline|[icL] [r/o] _tab'canGoBack : bool|;
	\item \lstinline|[icL] [r/o] _tab'canGoForward : bool|;
	\item \lstinline|[r/o] _tab'screenshot : string|;
	\item \lstinline|[r/o] _tab'source : string|;
	\item \lstinline|[r/*] _tab'title|;
	\item \lstinline|[r/w] _tab'url|.
\end{icItems}

И следующие методы:
\begin{icItems}
	\item \lstinline|_tab.back : void|;
	\item \lstinline|_tab.close : void|;
	\item \lstinline|_tab.focus : void|;
	\item \lstinline|_tab.forward : void|;
	\item \lstinline|_tab.get <string>url : bool|.
\end{icItems}

\subsubsection{\lstinline|[icL] [r/o] _tab'canGoBack : bool|}

Возвращает \true, если можно вернутся на предыдущую страницу, иначе \false.

\subsubsection{\lstinline|[icL] [r/o] _tab'canGoForward : bool|}

Возвращает \true, если можно вернутся на следующую страницу, иначе \false.

\subsubsection{\lstinline|[r/o] _tab'screenshot : string|}

Возвращает скриншот вкладки, кодирован в base64.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{UnableToCaptureScreen}.

\subsubsection{\lstinline|[r/o] _tab'source : string|}

Исходник страницы, открытой в указанной вкладке.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|[r/*] _tab'title|}

Название страницы, открытой в указанной вкладке.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|[r/w] _tab'url|}

URL страницы, открытой в указанной вкладке.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_tab.back : void|}

Переходит на предыдущую страницу, как при нажатии на кнопке браузера "Назад".

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{Timeout}.

\subsubsection{\lstinline|_tab.close : void|}

Закрывает окну, если она последняя закрывается и сессию.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}.

\subsubsection{\lstinline|_tab.focus : void|}

Переключает фокус на вкладку. Фокус можно менять только внутри активной сессии.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_tab.forward : void|}

Вернётся на следующую страницу, как при нажатии на кнопке браузера "Вперёд".

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{Timeout}.

\subsubsection{\lstinline|_tab.get <string>url : bool|}

Загружает страницу, URL должен быть абсолютным.

Возможные исключения: \ferror{NoSessions}, \ferror{NoSuchWindow}, \ferror{InvalidArgument}, \ferror{Timeout}, \ferror{InsecureCertificate}.

\subsection{{\color{orange} \_dom}}

Объект \dom{} имеет следующие методы:
\begin{icItems}
	\item \lstinline|_dom.query <int>by <string>selector : element|;
	\item \lstinline|_dom.query <string>cssSelector : element|;
	\item \lstinline|_dom.queryAll <int>by <string>selecor : element|;
	\item \lstinline|_dom.queryAll <string>cssSelector : lement|;
	\item \lstinline|_dom.queryAllByXPath <string>xpath : element|;
	\item \lstinline|_dom.queryByXPath <string>xpath : element|;
	\item \lstinline|_dom.queryLink <string>name <bool>isFragment = false : element|;
	\item \lstinline|_dom.queryLinks <string>name <bool>isFragment = false : element|;
	\item \lstinline|_dom.queryTag <string>name : element|;
	\item \lstinline|_dom.queryTags <string>name : element|.
\end{icItems}

\subsubsection{\lstinline|_dom.query <int>by <string>selector : element|}

Принимает то же самые параметры, как и \lstinline|element.query|, только поиск ведётся по всему документу.

Возможные исключения: \ferror{NoSessions}, \ferror{Timeout}.

\subsubsection{\lstinline|_dom.query <string>cssSelector : element|}

Акроним для \lstinline|_dom.query _by'cssSelector @cssSelector|.

\subsubsection{\lstinline|_dom.queryAll <int>by <string>selecor : element|}

Принимает то же самые параметры, как и \lstinline|element.query|, только поиск ведётся по всему документу.

Возможные исключения: \ferror{NoSessions}.

\subsubsection{\lstinline|_dom.queryAll <string>cssSelector : lement|}

Акроним для \lstinline|_dom.queryAll _by'cssSelector @cssSelector|.

\subsubsection{\lstinline|_dom.queryAllByXPath <string>xpath : element|}

Акроним для \lstinline|_dom.queryAll _by'xPath @xpath|.

\subsubsection{\lstinline|_dom.queryByXPath <string>xpath : element|}

Акроним для \lstinline|_dom.query _by'xPath @xpath|.

\subsubsection{\lstinline|_dom.queryLink <string>name <bool>isFragment = false : element|}

Акроним для:
\begin{icItems}
	\item \lstinline|_dom.query _by'linkText @name|;
	\item \lstinline|_dom.query _by'partialLinkText @name|;
\end{icItems}

\subsubsection{\lstinline|_dom.queryLinks <string>name <bool>isFragment = false : element|}

Акроним для:
\begin{icItems}
	\item \lstinline|_dom.queryAll _by'linkText @name|;
	\item \lstinline|_dom.queryAll _by'partialLinkText @name|;
\end{icItems}

\subsubsection{\lstinline|_dom.queryTag <string>name : element|}

Акроним для \lstinline|_dom.query _by'tagName @name|.

\subsubsection{\lstinline|_dom.queryTags <string>name : element|}

Акроним для \lstinline|_dom.queryAll _by'tagName @name|.

\subsection{{\color{orange} \_files}}

Объект \files{} имеет следующие методы:
\begin{icItems}
	\item \lstinline|_files.open <string>path : _file|;
	\item \lstinline|_files.create <string>path : _file|;
	\item \lstinline|_files.createDir <string>path : void|;
	\item \lstinline|_files.createPath <string>path : void|.
\end{icItems}

\subsubsection{\lstinline|_files.open <string>path : _file|}

Открывает файл.

Возможные исключения: \ferror{FileNotFound}.

\subsubsection{\lstinline|_files.create <string>path : _file|}

Открывает файл, если он не существует, он создаётся.

Возможные исключения: \ferror{FolderNotFound}.

\subsubsection{\lstinline|_files.createDir <string>path : void|}

Создаёт папку, папка в которым она создаётся должна уже существовать.

Возможные исключения: \ferror{FolderNotFound}.

\subsubsection{\lstinline|_files.createPath <string>path : void|}

Создаёт все несуществующие папки пути.

\subsection{{\color{orange} \_file}}

Объект \file{} имеет следующие свойства:
\begin{icItems}
	\item \lstinline|[r/o] _file'csv : 1 [static]|;
	\item \lstinline|[r/w] _file'format : int|;
	\item \lstinline|[r/o] _file'none : 0 [static]|;
	\item \lstinline|[r/o] _file'tsv : 2 [static]|;
	\item \lstinline|[r/o] _file'valid : bool|.
\end{icItems}

И следующие методы:
\begin{icItems}
	\item \lstinline|_file.close : void|;
	\item \lstinline|_file.delete : void|.
\end{icItems}

\subsubsection{\lstinline|[r/o] _file'csv : 1|}

Формат CSV.

\subsubsection{\lstinline|[r/w] _file'format : int|}

Возвращает формат файла.

\subsubsection{\lstinline|[r/o] _file'none : 0|}

Не инициализированный файл.

\subsubsection{\lstinline|[r/o] _file'tsv : 2|}

Формат TSV.

\subsubsection{\lstinline|[r/o] _file'valid : bool|}

Возвращает \true, если файл инициализированный, иначе \false.

\subsubsection{\lstinline|_file.close : void|}

Закрывает файл.

\subsubsection{\lstinline|_file.delete : void|}

Удаляет файл.

\subsection{{\color{orange} \_make}}

Объект \make{} имеет следующие методы:
\begin{icItems}
	\item \lstinline|_make.image <string>base64 <string>path : void|;
	\item \lstinline|_make.int <string>str <int>base : int|;
	\item \lstinline|_make.list <set>s : list|;
	\item \lstinline|_make.object <string>json : object|;
	\item \lstinline|_make.regex <string>pattern : regex|;
	\item \lstinline|_make.string <bool>b : string|;
	\item \lstinline|_make.string <double>d : string|;
	\item \lstinline|_make.string <int>number <int>base : string|;
	\item \lstinline|_make.string <object>obj : string|;
	\item \lstinline|_make.string <set>s : string|.
\end{icItems}

\subsubsection{\lstinline|_make.image <string>base64 <string>path : void|}

Сохраняет скриншот на жёстком диске.

\subsubsection{\lstinline|_make.int <string>str <int>base : int|}

Парсит целое число в виде строки в нужном базисе.

Возможные исключения: \ferror{ParsingFailed}.

\subsubsection{\lstinline|_make.list <set>s : list|}

Акроним для \lstinline|set : list|.

\subsubsection{\lstinline|_make.object <string>json : object|}

Акроним для \lstinline|object : string|.

\subsubsection{\lstinline|_make.regex <string>pattern : regex|}

Создаёт регулярное выражение на основе паттерна.

\subsubsection{\lstinline|_make.string <bool>b : string|}

Возвращает \lstinline|"true"|, если \lstinline|b == true|, иначе \lstinline|"true"|.

\subsubsection{\lstinline|_make.string <double>d : string|}

Акроним для \lstinline|double : string|.

\subsubsection{\lstinline|_make.string <int>number <int>base : string|}

Возвращает представления числа в заданном базисе.

\subsubsection{\lstinline|_make.string <object>obj : string|}

Акроним для \lstinline|object : string|.

\subsubsection{\lstinline|_make.string <set>s : string|}

Акроним для \lstinline|set : string|.

\subsection{{\color{orange} \_log}}

Объект \logtype{} имеет следующие методы:
\begin{icItems}
	\item \lstinline|_log.error <string>message : void|;
	\item \lstinline|_log.info <string>message : void|;
	\item \lstinline|_log.out <any ...>args : void|;
	\item \lstinline|_log.stack <any>var : void|;
	\item \lstinline|_log.state <any>var : void|.
\end{icItems}

\subsubsection{\lstinline|_log.error <string>message : void|}

Выводит сообщение об ошибке.

\subsubsection{\lstinline|_log.info <string>message : void|}

Выводит информационное сообщение.

\subsubsection{\lstinline|_log.out <any ...>args : void|}

Выводит отладочное сообщение, принимает несколько параметров любого типа. При получении переменных выводит исходник, название перемены, тип данных и значение. При получении константных только значение. При получении результата выполнения функции - тип и значение. 

\subsubsection{\lstinline|_log.stack <any>var : void|}

Выводит список всех стеков, указывая в каких из них встречается переменная с указанным именем, и какие значения имеются.

\subsubsection{\lstinline|_log.state <any>var : void|}

Выводит список всех состояний, указывая в каких из них встречается переменная с указанным именем, и какие значения имеются.

\subsection{{\color{orange} \_numbers}}

Объект \numbers{} имеет следующие свойства:
\begin{icItems}
	\item \lstinline|[r/o] _numbers'max : 4|;
	\item \lstinline|[r/o] _numbers'min : 3|;
	\item \lstinline|[r/o] _numbers'product : 2|;
	\item \lstinline|[r/o] _numbers'process : int|;
	\item \lstinline|[r/o] _numbers'sum : 1|.
\end{icItems}

И следующие методы:
\begin{icItems}
	\item \lstinline|_numbers.process <int>a <int>b : int|;
	\item \lstinline|_numbers.process <double>a <double>b : double|;
	\item \lstinline|_numbers.restoreProcess : void|;
	\item \lstinline|_numbers.setProcess <int>proc : void|.
\end{icItems}

\subsubsection{\lstinline|[r/o] _numbers'max : 4|}

Выбирать максимум.

\subsubsection{\lstinline|[r/o] _numbers'min : 3|}

Выбирать минимум.

\subsubsection{\lstinline|[r/o] _numbers'product : 2|}

Умножить числа.

\subsubsection{\lstinline|[r/o] _numbers'process : int|}

Текущий способ обработки чисел.

\subsubsection{\lstinline|[r/o] _numbers'sum : 1|}

Складывать числа.

\subsubsection{\lstinline|_numbers.process <int>a <int>b : int|}

Обработать целых чисел текущим методом.

\subsubsection{\lstinline|_numbers.process <double>a <double>b : double|}

Обработать дробных чисел текучим методом.

\subsubsection{\lstinline|_numbers.restoreProcess : void|}

Удаляет последняя запись стека способов обработки.

\subsubsection{\lstinline|_numbers.setProcess <int>proc : void|}

Добавляет новая запись в стеке способов обработки.

\subsection{{\color{orange} \_math}}

Объект \lstinline|_math| имеет следующие свойства:
\begin{icItems}
	\item \lstinline|[r/o] _math'1divPi : double|;
	\item \lstinline|[r/o] _math'1divSqrt2 : double|;
	\item \lstinline|[r/o] _math'2divPi : double|;
	\item \lstinline|[r/o] _math'2divSqrtPi : double|;
	\item \lstinline|[r/o] _math'e : double|;
	\item \lstinline|[r/o] _math'ln2 : double|;
	\item \lstinline|[r/o] _math'ln10 : double|;
	\item \lstinline|[r/o] _math'log2e : double|;
	\item \lstinline|[r/o] _math'log10e : double|;
	\item \lstinline|[r/o] _math'pi : double|;
	\item \lstinline|[r/o] _math'piDiv2 : double|;
	\item \lstinline|[r/o] _math'piDiv4 : double|;
	\item \lstinline|[r/o] _math'sqrt2 : double|.
\end{icItems}

И следующие методы:
\begin{icItems}
	\item \lstinline|_math.acos <double>v : double|;
	\item \lstinline|_math.asin <double>v : double|;
	\item \lstinline|_math.atan <double>v : double|;
	\item \lstinline|_math.ceil <double>v : int|;
	\item \lstinline|_math.cos <double>v : double|;
	\item \lstinline|_math.degreesToRadians <double>v : double|;
	\item \lstinline|_math.exp <double>v : double|;
	\item \lstinline|_math.floor <double>v : int|;
	\item \lstinline|_math.ln <double>v : double|;
	\item \lstinline|_math.min <int ...>arr : int|;
	\item \lstinline|_math.min <double ...>arr : double|;
	\item \lstinline|_math.max <int ...>arr : int|;
	\item \lstinline|_math.max <double ...>arr : double|;
	\item \lstinline|_math.radiansToDegrees <double>v : double|;
	\item \lstinline|_math.round <double> : int|;
	\item \lstinline|_math.sin <double>v : double|;
	\item \lstinline|_math.tan <double>v : double|.
\end{icItems}

\subsubsection{\lstinline|[r/o] _math'1divPi : double|}

1 делить на пи ($\frac{1}{\pi}$).

\subsubsection{\lstinline|[r/o] _math'1divSqrt2 : double|}

1 делить на корень из числа 2 ($\frac{1}{\sqrt{2}}$).

\subsubsection{\lstinline|[r/o] _math'2divPi : double|}

2 делить на пи ($\frac{2}{\pi}$).

\subsubsection{\lstinline|[r/o] _math'2divSqrtPi : double|}

2 делить на корень из числа пи ($\frac{2}{\sqrt{\pi}}$).

\subsubsection{\lstinline|[r/o] _math'e : double|}

Число ($e$).

\subsubsection{\lstinline|[r/o] _math'ln2 : double|}

Натуральный логарифм числа 2 ($\ln{2}$).

\subsubsection{\lstinline|[r/o] _math'ln10 : double|}

Натуральный логарифм числа 10 ($\ln_{10}$).

\subsubsection{\lstinline|[r/o] _math'log2e : double|}

Логарифм числа е по основанию 2 ($\log_{2}{e}$).

\subsubsection{\lstinline|[r/o] _math'log10e : double|}

Логарифм числа е по основанию 10 ($\log_{10}{e}$).

\subsubsection{\lstinline|[r/o] _math'pi : double|}

Число пи ($\pi$).

\subsubsection{\lstinline|[r/o] _math'piDiv2 : double|}

Пи по полам ($\frac{\pi}{2}$).

\subsubsection{\lstinline|[r/o] _math'piDiv4 : double|}

Пи на 4 ($\frac{\pi}{4}$).

\subsubsection{\lstinline|[r/o] _math'sqrt2 : double|}

Корень из числа 2 ($\sqrt{2}$).

\subsubsection{\lstinline|_math.acos <double>v : double|}

Арккосинус ($\arccos{v}$).

\subsubsection{\lstinline|_math.asin <double>v : double|}

Арксинус ($\arcsin{v}$).

\subsubsection{\lstinline|_math.atan <double>v : double|}

Арктангенс ($\arctan{v}$).

\subsubsection{\lstinline|_math.ceil <double>v : int|}

Наименьшее целое число больше или равна \code{v}.

\subsubsection{\lstinline|_math.cos <double>v : double|}

Косинус ($\cos{v}$).

\subsubsection{\lstinline|_math.degreesToRadians <double>v : double|}

Преобразует градусы в радианы.

\subsubsection{\lstinline|_math.exp <double>v : double|}

Функция экспонент ($\exp{v}$).

\subsubsection{\lstinline|_math.floor <double>v : int|}

Наибольшее целое число меньше или равна \code{v}.

\subsubsection{\lstinline|_math.ln <double>v : double|}

Натуральный логарифм ($\ln{v}$).

\subsubsection{\lstinline|_math.min <int ...>arr : int|}

Возвращает наименьшее целое число.

\subsubsection{\lstinline|_math.min <double ...>arr : double|}

Возвращает наименьшее дробное число.

\subsubsection{\lstinline|_math.max <int ...>arr : int|}

Возвращает наибольшее целое число.

\subsubsection{\lstinline|_math.max <double ...>arr : double|}

Возвращает наибольшее дробное число.

\subsubsection{\lstinline|_math.radiansToDegrees <double>v : double|}

Преобразует радианы в градусы.

\subsubsection{\lstinline|_math.round <double> : int|}

Возвращает ближайшее целое число.

\subsubsection{\lstinline|_math.sin <double>v : double|}

Синус ($\sin{v}$).

\subsubsection{\lstinline|_math.tan <double>v : double|}

Тангенс ($\tan{v}$).

\subsection{{\color{orange} \_import}}

Объект \lstinline|_import| имеет следующие методы:
\begin{icItems}
	\item \lstinline|_import.none <object>data <string>path : void|;
	\item \lstinline|_import.none <string>path : void|;
	\item \lstinline|_import.functions <object>data <string>path : void|;
	\item \lstinline|_import.functions <string>path : void|;
	\item \lstinline|_import.all <object>data <string>path : void|;
	\item \lstinline|_import.all <string>path : void|;
	\item \lstinline|_import.run <string>path : void|.
\end{icItems}

Объект \code{data} позволяет передать данные в изолированном контексте, они там будут доступны как глобальные переменные. Это позволяет в одном файле хранить несколько версий библиотеки например, и при использовании указать какую версию загрузить.

\subsubsection{\lstinline|_import.none <object>data <string>path : void|}

Создаёт изолируемый контекст, в нём выполняет файл.

\subsubsection{\lstinline|_import.none <string>path : void|}

Акроним для \lstinline|_import.none [<>] @path|.

\subsubsection{\lstinline|_import.functions <object>data <string>path : void|}

Создаёт изолируемый контекст, в нём выполняет файл, потом импортирует все функции в текущем контексте.

\subsubsection{\lstinline|_import.functions <string>path : void|}

Акроним для \lstinline|_import.functions [<>] @path|.

\subsubsection{\lstinline|_import.all <object>data <string>path : void|}

Создаёт изолируемый контекст, в нём выполняет файл, потом импортирует все функции и глобальные переменный в текущем контексте.

\subsubsection{\lstinline|_import.all <string>path : void|}

Акроним для \lstinline|_import.all [<>] @path|.

\subsubsection{\lstinline|_import.run <string>path : void|}

Выполняет файл в текущем контексте.

\subsection{Модификатор {\color{blue2} reverse}}

Ключевое слово \code{reverse} позволяет изменить ход выполнения некоторых конструкций языка.

\subsubsection{\lstinline|reverse if|}

\lstinline|reverse if (@var == true)| эквивалентно \lstinline|if (!(@var == true))|, в этом случае уменьшения количестве скобок упрощает чтения кода. 

Внимание: \lstinline|reverse if| не принимает \lstinline|else|.

\subsubsection{\lstinline|reverse if exists|}

\lstinline|if exists| хорош тем что позволяет выполнить код только когда есть нужные данные. А что если нам нужно генерировать исключение когда нужные данные отсутствуют? Эту проблему решает \lstinline|reverse if exists|. В сравнении с \lstinline|if exists|, никакие данные не будут переданы в блоке команд.

\subsubsection{\lstinline|reverse for| - универсальный цикл}

В универсальном цикле меняется порядок выполнения действий. \lstinline|reverse for| гарантирует выполнение блока команд в минимум один раз.

Порядок действий конструкций \lstinline|for|:
\begin{icEnum}
	\item инициализация;
	\item проверка условий;
	\item выполнения блока команд;
	\item выполнения команды перехода на следующую итерацию.
\end{icEnum}

Порядок действий конструкций \lstinline|reverse for|:
\begin{icEnum}
	\item инициализация;
	\item выполнения блока команд;
	\item выполнения команды перехода на следующую итерацию;
	\item проверка условий.
\end{icEnum}

\subsubsection{\lstinline|reverse while| - условное повторение кода}

\lstinline|reverse while| будет выполнить блок команд, пока условие остаётся ложной.

\subsubsection{\lstinline|do reverse while| - цикл с постусловий}

\lstinline|reverse while| будет выполнить блок команд, пока условие остаётся ложной. Так же как и \lstinline|do while| гарантирует что тело цикла будет выполнена минимум 1 раз.

\subsubsection{\lstinline|reverse for| - прохождение коллекций}

\lstinline|reverse for| будет пройти коллекцию в обратном порядке.

\subsubsection{\lstinline|reverse filter| - выборочное прохождение коллекций}

\lstinline|reverse filter| будет пройти коллекцию в обратном порядке.

\subsubsection{\lstinline|reverse range| - частичное прохождение коллекций}

\lstinline|reverse filter| будет пройти интервал в обратном порядке.

%\newpage
\section{Дополнительное взаимодействие}

Данные возможности доступны только в режиме автоматизации.

\subsection{Ожидание}

Для ожиданий предусмотрены следующие функций:
\begin{icItems}
	\item \lstinline|_wait.title <object>data : bool|;
	\item \lstinline|_wait.url <object>data : bool|;
	\item \lstinline|_wait.for <element>el <object>data : bool|;
	\item \lstinline|_wait.ajax <object>data : bool|.
\end{icItems}

\subsubsection{\lstinline|_wait.title <object>data : bool|}

Объект \code{data} может иметь следующие поля:
\begin{icItems}
	\item \lstinline|[r/w] @data'template : string| - шаблон нужней имени;
	\item \lstinline|[r/w] @data'expression : regex| - регулярное выражение описывающая ножное имя (имеет приоритет над шаблоном);
	\item \lstinline|[r/w] @data'timeout : int| - сколько миллисекунд ждать, по умолчанию 300 000.
\end{icItems}

\subsubsection{\lstinline|_wait.url <object>data : bool|}

Объект \code{data} может иметь следующие поля:
\begin{icItems}
	\item \lstinline|[r/w] @data'template : string| - шаблон нужного URL;
	\item \lstinline|[r/w] @data'expression : regex| - регулярное выражение описывающая нужный URL;
	\item \lstinline|[r/w] @data'timeout : int| - сколько миллисекунд ждать, по умолчанию 300 000.
\end{icItems}

\subsubsection{\lstinline|_wait.for <element>el <object>data : bool|}

Объект \code{data} может иметь следующие поля:
\begin{icItems}
	\item \lstinline|[r/w] @data'count : int| - количество нужных элементов в коллекции. По умолчанию 1;
	\item \lstinline|[r/w] @data'toBe : int| - нужное состояние для достижений. Предлагается одно из следующих значения:
	\begin{icItems}
		\item \lstinline|[r/o] _wait'present : 1|;
		\item \lstinline|[r/o] _wait'visible : 2|;
		\item \lstinline|[r/o] _wait'hidden : 3|;
		\item \lstinline|[r/o] _wait'interactable : 4|;
		\item \lstinline|[r/o] _wait'selected : 5|.
	\end{icItems}
	По умолчанию \lstinline|_wait'present|;
	\item \lstinline|[r/w] @data'timeout : int| - сколько миллисекунд ждать, по умолчанию 300 000.
\end{icItems}

\subsubsection{\lstinline|_wait.ajax <object>data : bool|}

Объект \code{data} может иметь следующие поля:
\begin{icItems}
	\item \lstinline|[r/w] @data'count : int| - количество максимальных допустимых активных запросов, по умолчанию 0;
	\item \lstinline|[r/w] @data'template : string| - шаблон нужного URL;
	\item \lstinline|[r/w] @data'expression : regex| - регулярное выражение описывающая нужный URL;
	\item \lstinline|[r/w] @data'timeout : int| - сколько миллисекунд ждать, по умолчанию 300 000.
\end{icItems}

\subsection{Клавиатура}

Для работы с клавиатуры предусмотрены следующие функций:
\begin{icItems}
	\item \lstinline|element.keyDown <int>modifiers <text>keys : element|;
	\item \lstinline|element.keyUp <int>modifiers <text> : element|;
	\item \lstinline|element.keyPress <int>modifiers <int>delay <string>keys : element|;
	\item \lstinline|element.fastType <string>text : element|;
	\item \lstinline|element.paste <string>text : element|.
\end{icItems}

\subsubsection{\lstinline|element.keyDown <int>modifiers <text>keys : element|}

Симулирует нажатия кнопки.

\subsubsection{\lstinline|element.keyUp <int>modifiers <text> : element|}

Симулирует отпускания кнопки.

\subsubsection{\lstinline|element.keyPress <int>modifiers <int>delay <string>keys : element|}

Симулирует процесс печати на клавиатуре с установленной задержкой.

\subsubsection{\lstinline|element.fastType <string>text : element|}

Симулирует процесс нажатия на клавиатуре с максимальной скоростью.

\subsubsection{\lstinline|element.paste <string>text : element|}

Копирует текст в буфер обмена, фокусирует элемент и вставит текст.

\subsection{Мышка}
\label{mouse}

Для работы с мышкой предусмотрены следующие функций:
\begin{icItems}
	\item \lstinline|element.click <object>data : element|;
	\item \lstinline|element.mouseDown <object>data : element|;
	\item \lstinline|element.mouseUp <object>data : element|;
	\item \lstinline|element.hover <object>data : element|.
\end{icItems}

В следующих функциях объект \code{data} может иметь следующие поля:
\begin{icItems}
	\item \lstinline|[r/w] @data'button : int| - кнопка мышки, принимает одно из следующих значений:
	\begin{icItems}
		\item \lstinline|[r/o] _mouse'left : 1| - левая кнопка;
		\item \lstinline|[r/o] _mouse'middle : 2| - средняя кнопка;
		\item \lstinline|[r/o] _mouse'right : 3| - правая кнопка.
	\end{icItems}
	По умолчанию \lstinline|_mouse'left|;
	\item \lstinline|[r/w] @data'rx : double| - \lstinline|ax = rx * width|;
	\item \lstinline|[r/w] @data'ry : double| - \lstinline|ay = rx * height|;
	\item \lstinline|[r/w] @data'ax : int| - относительная координата от левого края элемента;
	\item \lstinline|[r/w] @data'ay : int| - относительная координата от верхнего края элемента.
\end{icItems}

\subsubsection{\lstinline|element.click <object>data : element|}

Симулирует клик. Объект \code{data} имеет следующие дополнительные свойства:
\begin{icItems}
	\item \lstinline|[r/w] @data'delay : int| - задержка между нажатием и отпускании кнопке;
	\item \lstinline|[r/w] @data'count : int| - количество симулированных кликов.
\end{icItems}

\subsubsection{\lstinline|element.mouseDown <object>data : element|}

Симулирует нажатие кнопки мышки.

\subsubsection{\lstinline|element.mouseUp <object>data : element|}

Симулирует отпускание кнопки мышки.

\subsubsection{\lstinline|element.hover <object>data : element|}

Перемещает мышку над элементом. \code{data} имеет следующие дополнительные свойства:
\begin{icItems}
	\item \lstinline|[r/w] @data'time : int| - среднее время за которой курсор перемещается на 100 пикселей;
	\item \lstinline|[r/w] @data'func : int| - функция описывающая движение курсора. Принимает одно из следующих значений:
	\begin{icItems}
		\item \lstinline|[r/o] _move'teleport : 1| - перемещает курсор немедленно;
		\item \lstinline|[r/o] _move'linear : 2| - линейная интерполяция;
		\item \lstinline|[r/o] _move'quadratic : 3| - квадратичная интерполяция;
		\item \lstinline|[r/o] _move'cubic : 4| - кубическая интерполяция;
		\item \lstinline|[r/o] _move'bezier : 5| - использовает кубическую кривую Безье. Использует дополнительные параметры \code{p1x}, \code{p1y}, \code{p2x} и \code{p2y}. Если они не установлены то получат случайное значение от 0,0 до 1,0.
	\end{icItems}
	По умолчанию \lstinline|_move'teleport|.
	\item \lstinline|[r/w] @data'p1x : double| - Координата $x$ первой точке.
	\item \lstinline|[r/w] @data'p1y : double| - Координата $y$ первой точке.
	\item \lstinline|[r/w] @data'p2x : double| - Координата $x$ второй точке.
	\item \lstinline|[r/w] @data'p2y : double| - Координата $y$ второй точке.
\end{icItems}

\subsection{Тонкая настройка}

Настроить можно следующее параметры:
\begin{icItems}
	\item \lstinline|[r/w] _icL'clickTime : int|;
	\item \lstinline|[r/w] _icL'pressTime : int|;
	\item \lstinline|[r/w] _icL'moveTime : int|;
	\item \lstinline|[r/w] _icL'flashMode : bool|;
	\item \lstinline|[r/w] _icL'humanMode : bool|.
\end{icItems}

\subsubsection{\lstinline|_icL'clickTime : int|}

Время задержки клика, по умолчанию 300.

\subsubsection{\lstinline|_icL'pressTime : int|}

Время задержки нажатий кнопки, по умолчанию 60.

\subsubsection{\lstinline|_icL'moveTime : int|}

Среднее время в миллисекундах за которой курсор перемещается на 100 пикселей, по умолчанию 32.

\subsubsection{\lstinline|_icL'flashMode : bool|}

Режим "Вспышки", все операции будут выполнены максимально быстро. Отменяет \lstinline|_icL'humanMode|. По умолчанию выключен. \lstinline|element.sendKeys| и \lstinline|element.fastType| будут работать также быстро как и \lstinline|element.paste|, изменение содержимого буфера обмены может влиять отрицательно на опыт использования компьютера.

\subsubsection{\lstinline|_icL'humanMode : bool|}

Режим "Человека", все операции будут сделаны медленно и максимально человеко подобно. Отменяет \lstinline|_icL'flashMode|. Также будет нарисован дополнительный курсор, указывающий положение симулировано курсора. По умолчанию данный режим выключен.

%\newpage
\section{Регулярные выражения}
\label{regex}

Для объявления {\bf регулярных выражения} используется литерал \lstinline|//pattern//mods|, где \code{pattern} - шаблон регулярней выражений, \code{mods} - модификаторы. В шаблоне группы можно наименовать, анонимная группа имеет следующий синтаксис \lstinline|(content)|, именованная группа - \lstinline|(?<name>content)|.

Внутренний символ может быть не только \code{/}, но и любой другой на свой вкус, кроме апострофа (\lstinline|'|) он конфликтует с оператором {\it корень} (\lstinline|/'|), \lstinline|@|, \lstinline|#|, \lstinline|-|, \lstinline|+| и \lstinline|!|. Например  \lstinline|/"pattern"/mods|, \lstinline|/:pattern:/mods|, \lstinline|/$pattern$/mods|.

Для того чтобы захватить начало строки можно использовать \lstinline|^| и \lstinline|\A|, а для конца строки - \lstinline|$| и \lstinline|\z|. Первый вариант несмотря на его популярность может срабатывать неправильно, так как им захватывается начало и конец строки в контексте многострочного текста.

\subsection{Модификаторы}

В языке icL присутствуют следующее модификаторы: \code{/i}, \code{/s}, \code{/m}, \code{/x}, \code{/u} и \code{/f}. Модификаторы можно скомбинировать, например \code{/xi}.

\subsubsection{Модификатор \code{/i}}

Регистр букв будет проигнорирован. 

\subsubsection{Модификатор \code{/s}}

Точка будет означать любой символ, включая символа {\it новая строка}.

\subsubsection{Модификатор \code{/m}}

Метасимволы \lstinline|^| и \lstinline|$| будут означать начало и конец строки не только в общем смысле, но и в контексте многострочного текста.

\subsubsection{Модификатор \code{/x}}

Все пробельные символы будут проигнорированы, и символ \lstinline|#| будет означать начало комментария, который заканчивается символом {\it новая строка}.

\subsubsection{Модификатор \code{/u}}

Классы символов \lstinline|\w|, \lstinline|\d| и т.д. и их отрицаний \lstinline|\W|, \lstinline|\D| и т.д. будут соответствовать не только английских символов, но и национальных.

\subsubsection{Модификатор \code{/f}}

Инвертирует жадность квантификаторов \lstinline|*|, \lstinline|+|, \lstinline|?| и т.д. и они становятся ленивыми. А их ленивые версии \lstinline|*?|, \lstinline|+?|, \lstinline|??| и т.д. становятся жадными.

{\bf Жадный квантификатор} захватывает максимальное количество символов. {\bf Ленивый квантификатор} - минимальное.

\subsection{Операторы}

Для регулярных выражений доступны следующие операторы:
\begin{icItems}
\item
	3-ого ранга:
	\begin{icItems}
	\item
		\lstinline|string << regex : bool|;
	\item
		\lstinline|string <* regex : list|.
	\end{icItems}

\item 
	6$^+$-ого ранга: \lstinline|string ** regex : object|.
\end{icItems}

Примеры использования операторов приведены на листинге \ref{regexpopsex}.

\begin{lstlisting}[caption=Операторы регулярных выражений, label=regexpopsex]
"string" << //s.r//;            `` true
"string" <* //s(.)r//;          `` ["str" "t"]
"string" ** //s(?<letter>.)r//; `` [<"t">letter]
\end{lstlisting}

\subsubsection{\lstinline|string << regex : bool|}

Возвращает \true{}, если строка содержит подстроку подходящая по шаблону регулярней выражений, иначе \false{}.

\subsubsection{\lstinline|string <* regex : list|}

Возвращает список захваченных подстрок если строка содержит подстроку подходящая по шаблону регулярней выражений, иначе пустой список.

\subsubsection{\lstinline|string ** regex : object|}

Возвращает объект, содержащий значения всех именованных групп, если строка содержит подстроку подходящая по шаблону регулярней выражений и объявлены именованные группы, иначе пустой объект.

% \subsubsection{}

\subsection{Методы}

Методы классы \str{} и \listtype, имеющие параметры типа \regex{}:
\begin{icItems}
\item
	\lstinline|string.count <regex>re : int|;
\item
	\lstinline|string.indexOf <regex>re <int>startPos = -1 : int|;
\item
	\lstinline|string.lastIndexOf <regex>re <int>startPos = -1 : int|;
\item
	\lstinline|string.remove <regex>re : string|;
\item 
	\lstinline|string.replace <regex>re <string>after : string|;
\item
	\lstinline|string.split <regex>re <bool>keepEmptyParts = true : list|.
\item
	\lstinline|list.filter <regex>re : list|;
\item
	\lstinline|list.indexOf <regex>re <int>start : int|;
\item
	\lstinline|list.lastIndexOf <regex>re <int>start : int|;
\end{icItems}

Примеры использования выше перечисленных методов, представлены на листинге \ref{regexplikearg}.

\begin{lstlisting}[caption=Регулярные выражения в качестве аргумента, label=regexplikearg]
@str = "Hello world, collaborators!";

@str.count //\wo//;       `` 5
@str.indexOf //\w{6}//;   `` 13
@str.lastIndexOf //l+o//; `` 2
@str.remove //\w{2}o//;   `` "He world, collrrs!"
@str.split //,?\s//;      `` ["He" "world" "collrrs!"]

@fonts = ["Arial" "Helvetica" "Times" "Courier"];

@fonts.filter //^[ac]//i;    `` ["Arial" "Courier"]
@fonts.indexOf //e.//;       `` 1
@fonts.indexOf //e.// 2;     `` 2
@fonts.lastIndexOf //e.//;   `` 3
@fonts.lastIndexOf //e.// 2; `` 2
\end{lstlisting}

\subsubsection{\lstinline|string.count <regex>re : int|}

Считает количество подстрок подходящие по шаблону \code{re}.

\subsubsection{\lstinline|string.indexOf <regex>re <int>startPos = -1 : int|}

Возвращает индекс первой подстроки подходящей по шаблону \code{re}, ища вперёд с позицией \code{startPos}; если такая подстрока не нашлось, возвращает -1.

\subsubsection{\lstinline|string.lastIndexOf <regex>re <int>startPos = -1 : int|}

Возвращает индекс первой подстроки подходящей по шаблону \code{re}, ища назад с позицией \code{startPos}; если такая подстрока не нашлось, возвращает -1.

\subsubsection{\lstinline|string.remove <regex>re : string|}

Удаляет из строки все фрагменты подходящие по шаблону \code{re}.

\subsubsection{\lstinline|string.replace <regex>re <string>after : string|}

Заменяет каждый фрагмент, подходящий по шаблону \code{re}, строкой \code{after}.

\subsubsection{\lstinline|string.split <regex>re <bool>keepEmptyParts = true : list|}

Разрывает строку на подстроки при каждой встречи подстроки, подходящей по шаблону \code{re} и собирает список этих строк; если \code{keepEmptyParts == false} то пустые строки пропускаются.

\subsubsection{\lstinline|list.filter <regex>re : list|}

Возвращает новый список строк, содержащий только строки этого списка, подходящих по регулярней выражении \code{re}.

\subsubsection{\lstinline|list.indexOf <regex>re <int>start = 0 : int|}

Возвращает индекс первой строки, подходящей по регулярней выражении \code{re}, ища вперёд с позицией \code{start}, если такой строке не найдено возвращает -1.

\subsubsection{\lstinline|list.lastIndexOf <regex>re <int>start = -1 : int|}

Возвращает индекс первой строки, подходящей по регулярней выражении \code{re}, ища назад с позицией \code{start}, если такой строке не найдено возвращает -1.

% \subsubsection{}

%\newpage
\section{Механизм состояний}

Все переменные icL хранятся в контейнерах 2 типов: стек и состояние.

Стек представляет собой стек контейнеров, каждый контейнер строго привязан к фрагменту кода icL, при вводе курсора в область контейнер создаётся, при выходе разрушается.

Состояние представляет собой двусвязный список контейнеров, они не привязываются к коду и доступны глобально. По умолчанию создаётся лишь один контейнер, но новые могут быть созданы пользователем.

\subsection{Управление стеками}

Для управления стеками, используется следующий набор функций и свойств:
\begin{icItems}
	\item \lstinline|[r/o] _stacks'(<int>i) : _stack|;
	\item \lstinline|[r/w] _stacks'(<string>name) : _stack|;
	\item \lstinline|_stacks.if <int>i = 0 : _stack|;
	\item \lstinline|_stacks.ifexists <int>i = 0 : _stack|;
	\item \lstinline|_stacks.loop <int>i = 0 : _stack|;
	\item \lstinline|_stacks.while <int>i = 0 : _stack|;
	\item \lstinline|_stacks.dowhile <int>i = 0 : _stack|;
	\item \lstinline|_stacks.for <int>i = 0 : _stack|;
	\item \lstinline|_stacks.forany <int>i = 0 : |;
	\item \lstinline|_stacks.range <int>i = 0 : _stack|;
	\item \lstinline|_stacks.filter <int>i = 0 : _stack|;
	\item \lstinline|_stack.clear : void|;
	\item \lstinline|_stack.continue : void|;
	\item \lstinline|_stack.break : void|.
\end{icItems}

\subsubsection{\lstinline|_stacks'(<int>i) : _stack|}

Возвращает \code{i}-й контейнер. Контейнеры расположены по принципу FILO, то есть нулевой контейнер (\lstinline|_stacks'0|) - текущий. Текущий контейнер можно получить и более простым путём вызывая \lstinline|_stack|.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stacks'(<string>name) : _stack|}

Возвращает контейнер имеющий имя \code{name}. Наименование контейнера имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
{:name
	`` content
}
\end{lstlisting}
Могут быть именованными только блоки команд (код ограничен круглыми скобками). Код ограничен круглыми скобками не может иметь название. Вызов функций создаёт контейнер имеющий название функций.

\subsubsection{\lstinline|_stacks.if <int>i = 0 : _stack|}

Возвращает \code{i}-й \code{if} контейнер.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stacks.ifexists <int>i = 0 : _stack|}

Возвращает \code{i}-й \code{if exists} контейнер.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stacks.loop <int>i = 0 : _stack|}

Возвращает \code{i}-й \code{while}, \code{dowhile}, \code{for}, \code{range} или \code{filter} контейнер.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stacks.while <int>i = 0 : _stack|}

Возвращает \code{i}-й \code{while} контейнер.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stacks.dowhile <int>i = 0 : _stack|}

Возвращает \code{i}-й \code{do while} контейнер.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stacks.for <int>i = 0 : _stack|}

Возвращает \code{i}-й \code{for} контейнер.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stacks.forany <int>i = 0 : |}

Возвращает \code{i}-й \code{for any} контейнер.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stacks.range <int>i = 0 : _stack|}

Возвращает \code{i}-й \code{range} контейнер.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stacks.filter <int>i = 0 : _stack|}

Возвращает \code{i}-й \code{filter} контейнер.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|_stack'(<string>name) : any|}

Возвращает переменную, находящаяся именно в этом контейнере. Например: уже существует переменная \code{i} в родительском контейнере, нужно определить переменная с таким же именем в текущем контексте. Проблема решается следующим образом: \lstinline|_stack'i = 0| вместо \lstinline|@i = 0|.

\subsubsection{\lstinline|_stack.clear : void|}

Удаляет все переменные, которые хранится в контейнере.

\subsubsection{\lstinline|_stack.continue : void|}

Переход на следующую итерацию, доступно только для циклов.

Возможные исключения: \ferror{InvalidArgument}.

\subsubsection{\lstinline|_stack.break : void|}

Прекращает немедленно работу цикла или остановит выполнение функций. Доступно только для циклов и функций.

Возможные исключения: \ferror{InvalidArgument}.

\subsection{Управление состояниями}

Для управления стеками, используется следующий набор функций и свойств:
\begin{icItems}
	\item \lstinline|_states.new : void|;
	\item \lstinline|_states.newAtEnd : void|;
	\item \lstinline|_states.toNext : void|;
	\item \lstinline|_states.toPrev : void|;
	\item \lstinline|_states.clear : void|;
	\item \lstinline|_states.delete : void|;
	\item \lstinline|_states.toFirst : void|;
	\item \lstinline|_states.toLast : void|.
\end{icItems}

Объект \lstinline|_session| является коллекцией, а значит её можно посматривать через \lstinline|for (_states) {}|. Поддержка других циклов не предусматриваться.

\subsubsection{\lstinline|_states.new <object>data = [<>] : void|}

Создаёт новое состояние после текущей и переключает фокус на ней. Все данные объекта \code{data} добавляются в новом контейнере.

\subsubsection{\lstinline|_states.newAtEnd <object>data = [<>] : void|}

Создаёт новое состояние в конце, не переключает фокус на ней. Все данные объекта \code{data} добавляются в новом контейнере.

\subsubsection{\lstinline|_states.toNext : bool|}

Возвращает \true, если существует следующее состояние и фокус был перемещён на неё, иначе \false.

\subsubsection{\lstinline|_states.toPrev : bool|}

Возвращает \true, если существует предыдущее состояние и фокус был перемещён на неё, иначе \false.

\subsubsection{\lstinline|_states.clear : void|}

Удаляет все переменные, которые хранится в контейнере.

\subsubsection{\lstinline|_states.delete : void|}

Удаляет состояние, если существует следующее то фокус переходит на ней, иначе если существует предыдущее то фокус переходит на ней, в противном случае текущее состояние - последняя и она не удаляется, а только очищается.

\subsubsection{\lstinline|_states.toFirst : void|}

Переходит на первое состояние.

\subsubsection{\lstinline|_states.toLast : void|}

Переходит на последнее состояние.

\subsubsection{\lstinline|for (_states) \{\}|}

Выполняет тело цикла для каждой состояний.

%\newpage
\section{Базы данных}

Модуль баз данных определяет следующее глобальные объекты: \lstinline|_dbManager| - менеджер баз данных, \lstinline|_db| - последняя открытая база данных, \lstinline|_query| - последний запрос.

Модуль баз данных обеспечивает следующий набор возможности:
\begin{icItems}
	\item \lstinline|_dbManager.openSQLite <string>path : _db|;
	\item \lstinline|_db.query <_code>q : _query|;
	\item \lstinline|_db.close : void|;
	\item \lstinline|[w/o] _query'(<string>name) : any|;
	\item \lstinline|_query.set <string>field <any>value : void|;
	\item \lstinline|_query.exec : bool|;
	\item Доступны после выполнение:
	\begin{icItems}
		\item \lstinline|[r/o] _query'(<string>name) : any|;
		\item \lstinline|_query.getRowsAffected : int|;
		\item \lstinline|_query.getError : bool|;
		\item \lstinline|_query.getLength : int|;
		\item \lstinline|_query.get <string>field : any|;
		\item \lstinline|_query.next : bool|;
		\item \lstinline|_query.previous : bool|;
		\item \lstinline|_query.first : bool|;
		\item \lstinline|_query.last : bool|;
		\item \lstinline|_query.seek <int>i <bool>relative = false : bool|;
	\end{icItems}
\end{icItems}

\subsubsection{\lstinline|_dbManager.openSQLite <string>path : _db|}

Открывает новое подключение. \code{path} - путь к файлу базы данных.

\subsubsection{\lstinline|_db.query <_code>q : _query|}

Создаёт запрос, на основе кода SQL, изолированный в фигурных скобках.

\subsubsection{\lstinline|_db.close : void|}

Закрывает подключение к базу данных.

\subsubsection{\lstinline|[w/o] _query'(<string>name) : any|}

Возвращает объект, позволяющий заменить заменитель на значение через присваивание. Заменители в коде имеют следующий синтаксис \lstinline|:name|.

\subsubsection{\lstinline|_query.set <string>field <any>value : void|}

Установит значения заменителя с именем \code{field}.

\subsubsection{\lstinline|_query.exec : bool|}

Возвращает \true, если выполнения запроса была успешной, иначе \false.

\subsubsection{\lstinline|_query.getError : string|}

Возвращает текст ошибки, если при выполнении кода произошла ошибка.

\subsubsection{\lstinline|[r/o] _query'(<string>name) : any|}

После вызова функции \lstinline|_query.exec| свойства будут возвращать значения запрошенных полей. Если такое поле отсутствует, будет возвращать \void.

\subsubsection{\lstinline|_query.getRowsAffected : int|}

Количество обновлённых/добавленных строк в базе данных.

\subsubsection{\lstinline|_query.getLength : int|}

Количество результатов полученных при выполнении команды \code{SELECT}.

\subsubsection{\lstinline|_query.get <string>field : any|}

Возвращает значение поле или \void{} если столбец \code{field} отсутствует.

\subsubsection{\lstinline|_query.next : bool|}

Возвращает \true, если получилось перейти на следующую запись, иначе \false.

\subsubsection{\lstinline|_query.previous : bool|}

Возвращает \true, если получилось перейти на предыдущую запись, иначе \false.

\subsubsection{\lstinline|_query.first : bool|}

Возвращает \true, если получилось перейти на первую запись, иначе \false.

\subsubsection{\lstinline|_query.last : bool|}

Возвращает \true, если получилось перейти на последнюю запись, иначе \false.

\subsubsection{\lstinline|_query.seek <int>i <bool>relative = false : bool|}

Возвращает \true, если получилось перейти на \code{i}-ю запись или сдвинуть курсор на \code{i}-e количество шагов (при условии \code{@relative == true}), иначе \false.

\subsubsection{Пример}

Пример кода, использующий базы данных представлен на листинге \ref{dbexample}. Так же как и при использовании кода на языке Javascript, в коде можно встроить переменные icL, локальные переменный имеет синтаксис \code{@:name}, а глобальные - \code{\#:name}.

\begin{lstlisting}[caption=Пример кода использующий базу данных, label=dbexample]
_dbManager.openSQLite "db.sqlite";

`` simple query
_db.query {
	SELECT country
	FROM artists
};
_query.exec;

while (_query.next) {
	!doSomething _query'country;
};

`` query with parameters
_db.query {
	SELECT name
	FROM programmers
	WHERE country = :country
	LIMIT 1
};
_query'country = "Moldova";
`` is equivalent to
@md = "Moldova";
_db.query {
	SELECT name
	FROM programmers
	WHERE country = @:md
	LIMIT 1
};

`` insert query
_db.query {
	INSERT INTO person (id, forname, name)
	VALUE (:id, :forname, :name)
};
_query'id = 1001;
_query'forname = "Bart";
_query'name = "Simpson";
_query.exec;
\end{lstlisting}

%\newpage
\section{Обработка исключений}

Все ошибки в icL имеют название и описание. Что бы выводить в консоль название и описание текущей ошибке, достаточно вызвать \lstinline|_log.error ""|. Возможные исключения при вызове разных функций и методов в данном стандарте указаны в конце описания. Что зарегистрировать пользовательскую исключение используете \lstinline|_signal.add <string>name|.

\subsection{Генератор сигналов}

Код, который может генерировать сигнал об исключений называется эмиттер. И имеет следующий синтаксис \lstinline|emiter {```code```}|. Генерированный сигнал улавливает коллектор. Также коллекторов может быть несколько. Они имеют следующий синтаксис \lstinline|slot:exception {```code```}|,
где \code{exception} - имя исключений, чтобы поймать все исключения можно использовать \lstinline|slot:Any|. Пример кода использующий эмиттер и коллектор представлен на листинге \ref{sighandling}.

Для генерации собственных сигналов используется команда \lstinline|emit:exception <string>description|, где \code{exception} - имя исключений, а \code{description} - её описание.

Чтобы глушить все сигналы об ошибках используется подавитель сигналов, он имеет синтаксис \lstinline|jammer {```code```}|. Сигналы об схематических и синтаксических ошибках, а также сигнал \lstinline|emit:Exit|, не могут быть остановлены подавителем.

\begin{lstlisting}[caption=Обработка инключении, label=sighandling]
_signal.add "NumberTooBig";
_signal.add "NumberTooSmall";

@i = 3;

emiter {
	if (@i < 2) {
		emit:NumberTooSmall (@i:string) + " is smaller then 2.";
	}
	
	if (@i > 5) {
		emit:NumberTooBig (@i:string) + " is bigger then 5."
	}

	`` @i >= 2 \& @i <= 5
}
slot:NumberTooBig {
	_log.error "Oooops...";
}
slot:NumberTooSmall {
	_log.error "Nope! O_O";
};
\end{lstlisting}

\subsection{Предопределённые исключения}

Набор {\bf предопределённых исключения} представлен в таблице \ref{errors}. В данном документе, при описаниях возможностях, представлены списки исключениях которые возможно будут сгенерированы при использовании конкретной возможности. Исключения могут появиться в результате неправильных входных данных, а также при невозможности использовании возможности в текущем состоянии программы. Сигнал \ferror{Exit} генерируется только пользователем, при необходимости открыть программу немедленно.

\tabletwo{5cm}{12.1cm}{errors}{Стандартные исключения}%
{Класс}{Описание}%
{
	\ferror{Exit}                    & Немедленная остановка программы.                 \\ \hline
	
	\ferror{NoSessions}              & Ни одна сессия не существует.                    \\ \hline
	\ferror{NoSuchWindow}            & Нужное одно закрыта.                             \\ \hline
	\ferror{NoSuchElement}           & Нужный элемент не найден.                        \\ \hline
	\ferror{NoSuchFrame}             & Нет такого frame.                                \\ \hline
	\ferror{NoSuchCookie}            & Нет такого cookie.                               \\ \hline
	\ferror{NoSuchAlert}             & Предупреждение отсутствует.                      \\ \hline
	\ferror{NoSuchTab}               & Вкладка уже закрыта.                             \\ \hline
	\ferror{StaleElementReference}   & Ссылка на элемент недействительна.               \\ \hline
	\ferror{FolderNotFound}          & Папка не найдено.                                \\ \hline
	\ferror{FileNotFound}            & Файл не найден.                                  \\ \hline
	\ferror{FieldNotFound}           & Поле не найдено.                                 \\ \hline
	\ferror{FieldAlreadyExists}      & Поле уже существует.                             \\ \hline
	\ferror{OutOfBounds}             & Выход за пределы коллекции.                      \\ \hline
	\ferror{UnsupportedOperation}    & Операция не поддерживается веб-драйвером.        \\ \hline
	
	\ferror{EmptyString}             & Пустая строка.                                   \\ \hline
	\ferror{EmptyList}               & Пустой список.                                   \\ \hline
	\ferror{MultiList}               & Список содержит несколько строк.                 \\ \hline
	\ferror{EmptyElement}            & Пустой/пустая элемент/коллекция.                 \\ \hline
	\ferror{MultiElement}            & Коллекция содержит несколько элементов.          \\ \hline
	\ferror{EmptySet}                & Пустое множество.                                \\ \hline
	\ferror{MultiSet}                & Множество содержит несколько объектов.           \\ \hline
	
	\ferror{InvalidArgument}         & Неправильный аргумент.                           \\ \hline
	\ferror{InvalidSelector}         & Неправильный селектор.                           \\ \hline
	\ferror{InvalidElementState}     & Состояние элемента неудовлетворительна.          \\ \hline
	\ferror{InvalidElement}          & Элемент не подходит данной операции.             \\ \hline
	\ferror{IncompatibleRoot}        & Неподходящий корень строки JSON.                 \\ \hline
	\ferror{IncompatibleData}        & Неподходящие данные.                             \\ \hline
	\ferror{IncompatibleObject}      & Неподходящий объект.                             \\ \hline
	\ferror{InvalidSessionId}        & Сессия уже закрыта.                              \\ \hline
	\ferror{InvalidCookieDomain}     & Неподходящий домен для cookie.                   \\ \hline
	\ferror{InsecureCertificate}     & Небезопасный сертификат.                         \\ \hline
	\ferror{UnexpectedAlertOpen}     & Неожиданное предупреждение.                      \\ \hline
	
	\ferror{UnrealCast}              & Невозможное преобразование.                      \\ \hline
	\ferror{ParsingFailed}           & Парсинг не удался.                               \\ \hline
	\ferror{WrongDelimiter}          & Неправильный разделитель.                        \\ \hline
	\ferror{ComplexField}            & Невозможное преобразование данных из JSON в icL. \\ \hline
	\ferror{ElementNotInteractable}  & Элемент не интерактивный.                        \\ \hline
	\ferror{ElementClickIntercepted} & Другой элемент мешает сделать клик.              \\ \hline
	\ferror{MoveTargetOutOfBounds}   & Координаты мышки вне экрана.                     \\ \hline
	\ferror{UnableToSetCookie}       & Нельзя установить cookie.                        \\ \hline
	\ferror{UnableToCaptureScreen}   & Нельзя захватить экран.                          \\ \hline
	\ferror{JavascriptError}         & Ошибка выполнения кода на языке Javascript.      \\ \hline
	\ferror{ScriptTimeout}           & Время выполнения скрипта истекло.                \\ \hline
	\ferror{Timeout}                 & Время истекло.                                   \\ \hline
	\ferror{SessionNotCreated}       & Нельзя создать сессию.                           \\ \hline
	
	\ferror{UnknownCommand}          & \code{[w3c]} Неизвестная команда.                \\ \hline
	\ferror{UnknownError}            & \code{[w3c]} Неизвестная ошибка.                 \\ \hline
	\ferror{UnknownMethod}           & \code{[w3c]} Неизвестный метод HTTP.             \\
}

\newpage
\section{Прогресс}

{\color{red}Материал для продвинутых пользователей.}

\begin{icEnum}
	\item + Введение
	\item + Базовый синтаксис
	\item + Переменные
	\item + Типы данных
	\item + Литералы
	\item + Операторы
	\item + Условные операторы
	\item + Циклы
	\item + Интеграция с Javascript
	\item + Функции
	\item + Строки
	\item + Списки
	\item + Множества
	\item + Веб-элементы (симуляция мышки и клавиатуры) webelments
	\item + Обмен данных в веб-странице (конкретные примеры) dataexchange
	\item + DSV / CSV / TSV
	\item + Преобразование типов
\end{icEnum}

{\color{red}далее материал для программистов, дополнительные возможности, просьба не читать далее материал если нету желание или необходимость.}

\begin{icEnumResume}
	\item + Дополнительные возможности
	\item + Регулярные выражения regex
	\item + Механизм состояний
	\item + Базы данных (только SQLite в первой версии)
	\item + Обработка ошибок emiter, emit, slot
	\item - Crossfire.js
\end{icEnumResume}

\end{document}
