% !TeX spellcheck = ro_RO
\section{Tipuri de date}

În limbajul de script-are icL, tipurile de date joacă un rol tare important, ele hotărăsc cum datele au să fie păstrate și prelucrate în decursul rulării programei. Clasificarea tipurilor de date este demonstrată în tabela \ref{datatypeclasses}.

\stabletwo{3.5cm}{13.6cm}
{datatypeclasses}{Gruparea tipurilor de date}
{Categorie}{Descriere}
{
	De bază     & Tipurile de date descrise în capitolul precedent: \bool{} - boolean, \integer{} - numere întregi, \double{} - numere decimale. \\ \hline
	Complexe    & Tipuri de date care conțin cîteva valori în container, exemple: șiruri de caractere, liste, mulțimi. \\ \hline
	De sistem   & Tipuri de date pe care nu pot fi create direct de programator, accesul la ele este asigurat de obiecte de sistem. Exemple: browser, tab, istoria browserului, fereastră \\ \hline
	Tip \void{} & Tip de date care înseamnă lipsa informației.
}

\subsection{Tipuri de bază}

{\bf Tipuri de bază} se folosesc în realizarea operațiilor logice și aritmetice. Operațiile logice sunt conjuncția, disjuncția, disjuncție exclusivă, echivalență și negație logică. Operațiile aritmetice sunt adunarea, scăderea, înmulțirea, împărțirea, extragerea rădăcinii și ridicarea la putere.

\subsection{Tipuri complexe}

{\bf Tipurile complexe} sunt concentrate pe păstrarea masivelor de informație. Șirul de caractere poate conține mai mult de 2 miliarde de caractere, lista - mai mult de 2 miliarde de șiruri de caractere. Mulțimile pot conține o mare cantitate de date, limitată doar de memoria operativă. Obiectele permit a salva mai multe variabile sub un nume. Elementele pot conține linkuri la mai multe tag-uri HTML.

\subsection{Tipuri de sistem}

{\bf Tipurile de siste} permit a interacționa cu pagina web și cu browserul. Mai multă informație puteți găsi în capitolele \ref{webelments} и \ref{dataexchange}.

\subsection{Tip {\color{lightblue} void}}

{\bf Tipul \void{}} indică la lipsa informației, el poate fi folosit în cele mai diferite scopuri:

\begin{icItems}
\item
	a indica la ceea că funcția nimic nu întoarce;
\item
	a indica la ceea că in timpul execuției funcția a apărut o excepție;
\item
	a alege sursa de date;
\item
	a filtra datele;
\item
	a șterge variabile globale;
\item
	și multe altele.
\end{icItems}


\subsection{Proprietăți}

Unele tipuri de date au proprietăți. Proprietățile permit a citi caracteristicile datelor. Indiferent de tipul de date, orice obiect are următoarele proprietăți (disponibile doar pentru citire):

\begin{icItems}
\item
	\code{any'typeName : string} e numele tipului de date conținut de obiect;
\item
	\code{any'typeId : int} e identificatorul tipului de date conținut de obiect;
\item
	\code{any'rValue : bool} e egal cu \true{} dacă obiectul este o valoare de dreapta, în caz contrar \false{};
\item
	\code{any'readOnly : bool} e egal cu \true{} dacă obiectul este disponibil doar pentru citire, în caz contrar \false{};
\item
	\code{any'lValue : bool} e egal cu \true{} dacă obiectul este disponibil pentru citire și scriere, în caz contrar \false{};
\item
	\code{any'link : bool} e egal cu \true{} dacă valoare sa află într-un container extern și schimbarea valorii va schimba valoarea în mediu extern, în caz contrar \false{}.
\end{icItems}

Exemple de folosire a proprietăților sunt prezente pe foaia \ref{propertiesmain}.

\subsection{Metode}

Metodele permit a schimba starea obiectului. Toate tipurile de date au doar o singură metodă comună \code{any.ensureRValue}, care garantează că schimbarea valorii obiectului nu va schimba date în mediul extern.

Exemplu de folosire a metodei \code{any.ensureRValue} este demonstrat pe foaia \ref{anyensureRValue}.

\begin{lstlisting}[caption=Proprietăți, label=propertiesmain]
@int = 2;
@double = 3;
@string = "int";

@int'typeName == @string;		 `` true
@int'typeId == @double'typeId ;	 `` false
@string'typeId == Types'string; `` true

@int'rValue; `` false
1234'rValue; `` true

@int'readOnly; `` false
1234'readOnly; `` true

@int'lValue; `` true
1234'lValue; `` false

@int'link; `` true
1234'link; `` false
\end{lstlisting}


\begin{lstlisting}[caption=Metoda any.ensureRValue, label=anyensureRValue]
@int = 123;

@int'rValue;   `` false
@int'readOnly; `` false
@int.ensureRValue;
@int'rValue;   `` true
@int'readOnly; `` false
\end{lstlisting}

\subsection{Conversia datelor}

În mod implicit, icL nu conversează datele. De exemplu a aduna \integer{} cu \double{} nu se poate, astfel de operator nu este definit. În acest caz se poate de conversat \integer{} în \double{} sau \double{} în \integer{}, în funcție de rezultatul necesar.

Sintaxa conversie este foarte simplă \code{data : type}, unde \code{data} e orice date, dar \code{type} numele tipului de date necesar. Exemple de conversie sunt prezente pe foaia \ref{conversionexample}.

\

\

\

\begin{lstlisting}[caption=Exemple de conversie, label=conversionexample]
@a = 2 + 2.3; `` error
@a = (2 : double) + 2.3; `` 4.3
@a = 2 + (2.3 : int); `` 4

@b = 12 + " utils"; `` error
@b = (12 : string) + " utils"; `` "12 utils"

@c = "55" - 12; `` error
@c = ("55" : int) - 12; `` 43

@d = 23 + 12 : double; `` @d = 35.0
@e = 234.0 / 5.0 : int; `` @e = 46
\end{lstlisting}
