% !TeX spellcheck = ro_RO
\section{Șiruri de caractere}

{\bf Șirurile de caractere} (tipul \str{}) permite a reține și a manipula fragmente de text. 

\subsection{Proprietăți}

Mai departe proprietățile for fi însemnate cu următoarele semne: \code{[r/w]} - disponibil pentru citire și scriere, \code{[r/o]} - disponibil numai pentru citire, \code{[w/o]} - disponibil numai pentru scriere,  \code{[r/*]} - disponibil pentru scriere numai în regim de automatizare, \code{[*/*]} - accesul va fi concretizat mai apoi.

Șirurile de caractere dețin următoarele proprietăți adiționale
\begin{icItems}
\item
	\code{[r/o] string'empty : bool};
\item
	\code{[r/o] string'length : int};
\item
	\code{[r/o] string'last : string};
\item
	\lstinline|[r/o] string'(n : int) : string|.
\end{icItems}

\

Pe foaia \ref{stringprop} este prezentat cod, care folosește proprietățile enumerate.

\subsubsection{\code{[r/o] string'empty : bool}}

Șirul se socoate deșert dacă lungimea lui este egală cu zero;

\begin{lstlisting}[caption=Proprietățile clasei string, label=stringprop]
@empty = "";
@fonts = "Arial, Helvetica, Times, Courier";

@empty'empty; `` true
@fonts'empty; `` false

@empty'length; `` 0
@fonts'length; `` 32

@empty'last; `` error
@fonts'last; `` "r"

@empty'0; `` error
@fonts'0; `` "A"
\end{lstlisting}

\subsubsection{\code{[r/o] string'length : int}}

Lungimea șirului este egală cu numărul de caractere;

\subsubsection{\code{[r/o] string'last : char}}

Ultimul caracter al șirului \lstinline|string.at (string'length - 1)|.

Excepții posibile: \ferror{EmptyString} (pr. tab. \ref{errors}).

\subsubsection{\lstinline|[r/o] string'(<int> n) : string|}

Al n-lea caracter. n trebuie sa fie literal întreg, exemple: \lstinline|@str'0; @string'2|.

Excepții posibile: \ferror{OutOfBounds} (pr. tab. \ref{errors}).

\subsection{Metode}

Șirurile dețin următoarele metode adiționale:
\begin{icItems}
	\item
	\lstinline|string.append (str : string) : string|;
	\item
	\lstinline|string.at (i : int) : string|;
	\item
	\lstinline|string.beginsWith (str : string) : bool|;
	\item
	\lstinline|string.compare (str : string, caseSensitive = true) : bool|;
	\item
	\lstinline|string.count (str : string) : int|;
	\item
	\lstinline|string.endsWith (str : string) : bool|;
	\item
	\lstinline|string.indexOf (str : string, startPos = 0) : int|;
	\item
	\lstinline|string.insert (str : string, pos : int) : string|;
	\item
	\lstinline|string.lastIndexOf (str : string, startPos = -1) : int|;
	\item
	\lstinline|string.left (n : int) : string|;
	\item
	\lstinline|string.leftJustified (width : int, fillChar) : string, truncate = false :string|;
	\item
	\lstinline|string.mid (pos : int, n = -1) : string|;
	\item
	\lstinline|string.prepend (str : string) : string|;
	\item
	\lstinline|string.remove (pos : int, n : int) : string|;
	\item
	\lstinline|string.remove (str : string, caseSensitive = true) : string|;
	\item
	\lstinline|string.replace (pos : int, n : int, after : string) : string|;
	\item
	\lstinline|string.replace (before : string, after : string) : string|;
	\item
	\lstinline|string.right (n : int) : string|;
	\item
	\lstinline|string.rightJustified (width : int, fillChar : string, truncate) : bool, = false:string|;
	\item
	\lstinline|string.split (separator : string, keepEmptyParts = true, caseSensitive = true) : list|;
	\item
	\lstinline|string.substring (begin : int, end : int) : string|;
	\item
	\lstinline|string.trim (justWhitespace = true) : string|.
\end{icItems}

Unele metode sunt ignorate, ele vor fi enumerate în capitolul \ref{regex}; Exemplu de cod, care folosește metodele enumerate este prezent pe foaia \ref{stringmethods}.

\

\begin{lstlisting}[caption=Metodele clasei string, label=stringmethods]
@empty = "";
@fonts = "Arial, Helvetica, Times, Courier";
@index = 2;

@empty.append "data";   `` "data"
@empty.append @fonts'0; `` "dataA"
@empty = "";

@empty.at @index; `` error
@fonts.at @index; `` i
@fonts.at 1;	  `` r

@empty.beginsWith "";      `` true
@fonts.beginsWith "Arial"; `` true

@empty.compare "data"; `` false
@empty.compare "";     `` true

@fonts.count ",";      `` 3
@fonts.count @fonts'0; `` 1

@fonts.endsWith "Courier"; `` true
@fonts.endsWith "Arial";   `` false

@fonts.indexOf "Courier"; `` 25
@fonts.indexOf @fonts'11; `` 8

@data = "10"
@data.insert ("data", 1);   `` "1data0"
@data.insert (@fonts'0, 2); `` "1dAata0"

@fonts.lastIndexOf "e";      `` 30
@fonts.lastIndexOf @fonts'8; `` 30

@fonts.left 5; `` "Arial"

@data = "10";
@data.leftJustified (4, "0"); `` "0010"
@data.mid (1, 2);             `` "01"

@data.prepend "11";     `` "1100010"
@data.prepend @fonts'0; `` "A1100010"

@data.remove (2, 2);  `` "11010"
@data.remove "01";    `` "110"

@data.replace (2, 1, "0101"); `` "110101"
@data.replace ("01", "01");   `` "111010"

@data.right 4; 				   `` "1010"
@data.rightJustified (8, "0"); `` "11101000"

@fonts.split ", ";     `` ["Arial", "Helvica", "Times", "Curier"]
@fonts.split @fonts'5; `` ["Arial", " Helvica", " Times", " Curier"];

@data.substring (1, 3); `` "11"

@str = " , 34px \n";
@str.trim;       `` ", 34px"
@str.trim false; `` "34px"
\end{lstlisting}

\subsubsection{\lstinline|string.append (str : string) : string|}

Inserează șirul \code{str} la sfîrșitul listei.

\subsubsection{\lstinline|string.at (i : int) : string|}

Returnează al \code{i}-lea simbol.

Excepții posibile: \ferror{OutOfBounds} (pr. tab. \ref{errors}).

\subsubsection{\lstinline|string.beginsWith (str : string) : bool|}

Returnează \true{}, dacă începutul șirului coincide cu \code{str}, în caz contrar \false{}.

\subsubsection{\lstinline|string.compare (str : string, caseSensitive = true) : bool|}

Compară șirurile, returnează \true{} dacă ele sunt egale, în caz contrar \false{}. Argument \code{caseSensitive} poate fi omis, dacă el primește valoarea \false{}, diferența dintre majuscule și minuscule va fi ignorată.

\subsubsection{\lstinline|string.count (str : string) : int|}

Calculează de cîte ori subșirul \code{str} se întîlnește în șir.

\subsubsection{\lstinline|string.endsWith (str : string) : bool|}

Returnează \true{}, dacă sfîrșitul șirului coincide cu \code{str}, în caz contrar \false{}.

\subsubsection{\lstinline|string.indexOf (str : string, startPos = 0) : int|}

Returnează indexul primii includeri a șubșirului \code{str} în șir, căutînd înainte de pe poziția \code{startPos}, dacă șirul nu include subșirul se returnează -1.

\subsubsection{\lstinline|string.insert (str : string, pos : int) : string|}

Inserează șirul \code{str} pe poziția \code{pos}.

\subsubsection{\lstinline|string.lastIndexOf (str : string, startPos = -1) : int|}

Returnează indexul primii includeri a șubșirului \code{str} în șir, căutînd înapoi de pe poziția \code{startPos}, dacă șirul nu include subșirul se returnează -1.

\subsubsection{\lstinline|string.left (n : int) : string|}

Returnează subșir, care conține primele \code{n} caractere.

\subsubsection{\lstinline|string.leftJustified (width : int, fillChar) : string, truncate = false :|\\* \lstinline|string|}

Returnează șir cu lungimea \code{width}, care conține șirul acesta la început, dar la sfîrșit se inserează \code{width - .length} caractere \code{fillChar}. Dacă \code{truncate == true} și \code{width < .length}, ultimele \code{.length - width} simboluri se șterg.

\subsubsection{\lstinline|string.mid (pos : int, n = -1) : string|}

Returnează șir, care conține \code{n} caractere din șirul acesta, începînd cu poziția \code{pos.} Va fi întors un șir deșert în cazul în care intervalul iese din granițele șirului. Dacă \code{n == -1} vor fi returnate toate caractere disponibile începînd cu caracterul de pe poziția \code{pos}.

\subsubsection{\lstinline|string.prepend (str : string) : string|}

Inserează șirul \code{str} la început.

\subsubsection{\lstinline|string.remove (pos : int, n : int) : string|}

Șterge \code{n} caractere din șir începînd cu poziția \code{pos}.

\subsubsection{\lstinline|string.remove (str : string, caseSensitive = true) : string|}

Șterge fiecare includere al subșirului \code{str} în șir. Argumentul \code{caseSensitive} poate fi omis, dacă el primește valoarea \false{} diferența între majuscule și minuscule va fi ignorată.

\subsubsection{\lstinline|string.replace (pos : int, n : int, after : string) : string|}

Înlocuiește intervalul [\code{pos}; \code{pos + n}] cu șirul \code{after}.

\subsubsection{\lstinline|string.replace (before : string, after : string) : string|}

Înlocuiește fiecare includere a șirului \code{before} cu șirul \code{after}.

\subsubsection{\lstinline|string.right (n : int) : string|}

Returnează șir, care conține ultimele \code{n} caractere din șir.

\subsubsection{\lstinline|string.rightJustified (width : int, fillChar) : string, truncate = false :|\\* \lstinline|string|;}

Returnează șir cu lungimea \code{width}, care conține acest șir, la început se înserează \code{width - .length} caractere \code{fillChar}. Dacă \code{truncate == true} și \code{width < .length}, primele \code{.length - width} caractere vor fi șterse.

\subsubsection{\lstinline|string.split (separator : string, keepEmptyParts = true, caseSensiti : bool,|\\* \lstinline|ve = true) : list|}

Împarte șirul în subșiruri, la fiecare găsire a subșirului \code{separator} și strînge subșirurile în lista. Dacă \code{separator} nu se întîlneste nici o dată, va fi returnată o listă dintr-un șir - acest șir. Dacă \code{keepEmptyParts == false} șirurile deșarte se ignoră.

\subsubsection{\lstinline|string.substring (begin : int, end : int) : string|}

Returnează șir, care conține caracterele din intervalul [\code{begin}; \code{end}].

\subsubsection{\lstinline|string.trim (justWhitespace = true) : string|}

Returnează șir, copia acestui șir din care se șterg toate spațiile de la început și sfîrșit. Dacă \lstinline|justWhitespace == false| vor fi șterse toate caracterele care nu sunt litere sau cifre (de la începutul și sfîrșitul șirului).

% \subsubsection{}

%\newpage
