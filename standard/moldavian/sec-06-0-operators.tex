% !TeX spellcheck = ro_RO
\section{Operatori}

{\bf Operatorul} este un semn, care desemnează o anumită manipulare de date. Operatori predefiniți în icL sunt foarte mulți, din cauza aceasta ei vor fi repartizați pe tipuri de date în ordinea următoare:

\begin{icEnum}
	\item \bool{};
	\item \integer{};
	\item \double{};
	\item \str{};
	\item \listtype{};
	\item \object{};
	\item \set{};
	\item \void{}.
\end{icEnum}

Fiecare operator are rang, operatorii care au cel mai mare rang se execut primii, dar cei cu cel mai mic - ultimii. Operatori care au asociativitate dreaptă se execută înainte de operatorii cu asociativitate stîngă. Ei sunt însemnați cu un plus în partea dreaptă, de exemplu 7$^+$.

{\bf Operatorul de atribuire} are rang 0 și asociativitate dreaptă.

\subsection{\color{lightblue}bool}

Dacă nu aveți cunoștințe în algebră booleană, vă rugăm să citați o carte pe această temă.

Pentru tipul de date \bool{}, sunt disponibile:

\begin{icItems}
	\item
		operatori de algebră booleană (care dețin rangul 2):
	\begin{icItems}
		\item
			conjuncție - \lstinline|bool & bool : bool|;
		\item
			disjuncție - \lstinline`bool | bool : bool`;
		\item
			echivalență logică - \lstinline|bool ~ bool : bool|;
		\item
			disjuncție exclusivă - \lstinline|bool ^ bool : bool|;
		\item
			negație booleană (care deține rangul 7$^+$) - \lstinline|! bool : bool|;
	\end{icItems}

	\item
		operatori de comparare (care dețin rangul 3):
	\begin{icItems}
		\item
			egal - \lstinline|bool == bool : bool|;
		\item
			inegal - \lstinline|bool != bool : bool|;
	\end{icItems}
\end{icItems}

Exemple de folosire a operatorilor enumerați mai sus, sunt demonstrate pe foaia \ref{boolopex}.

\

\begin{lstlisting}[caption=Exemple de folosite a operatorilor asupra tipului bool, label=boolopex]
Log.out "true & false = " (true & false);		`` true \& false = false
Log.out "false | true =  " (false | true);		`` false | true = true
Log.out "true ~ false = " (true ~ false);		`` true \textasciitilde\ false = false
Log.out "false ^ true = " (false ^ true);		`` false \textasciicircum\ true = true`

Log.out "!true = " !true;						`` !true = false
Log.out "!false = " !false;					`` !false = true

Log.out "true == false = " (true == false);	`` true == false = false
Log.out "false != true = " (false != true);	`` false != true = true
\end{lstlisting}

\subsubsection{\lstinline|<bool>a & <bool>b : bool|}

Operatorul aplică operația "conjuncție logică" asupra a și b. Dependența rezultatului de datele de intrare este demonstrată în tabela \ref{conjtable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al conjuncției}
	\label{conjtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \& b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a | <bool>b : bool`}

Operatorul aplică operația "disjuncție logică" asupra variabilelor a și b. Dependența rezultatului de datele de intrare este demonstrată în tabela  \ref{distable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al disjuncției}
	\label{distable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \| b} 	\\ \hline
		\false{} & \false{} & \false{} 		\\ \hline
		\false{} & \true{}  & \true{}  		\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \true{}  		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|<bool>a ~ <bool>b : bool|}

Operatorul aplică operația "echivalență logică" asupra variabilelor a și b. Dependența rezultatului de datele de intrare este demonstrată în tabela \ref{logeqtable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al echivalenței}
	\label{logeqtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \~ b} \\ \hline
		\false{} & \false{} & \true{}   	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline|<bool>a ^ <bool>b : bool|}

Operatorul aplică operația "disjuncție exclusivă" asupra variabilelor a și b. Dependența rezultatului de datele de intrare este demonstrată în tabela \ref{logdifftable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al disjuncției exclusive}
	\label{logdifftable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \^ b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \true{}   	\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \false{}  	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|! <bool>a : bool|}

Operatorul aplică operația "negație logică" asupra variabilei a. Dependența rezultatului de datele de intrare este demonstrată în tabela  \ref{invtable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al negației logice}
	\label{invtable}
	\begin{tabular}{|c|c|}
		\hline
		\code{a} & \code{!a} \\ \hline
		\false{} & \true{} 	 \\ \hline
		\true{}  & \false{}  \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|<bool>a == <bool>b : bool|}

Returnează \true{} dacă a este egal cu b, în caz contrar \false{}.

\subsubsection{\lstinline|<bool>a != <bool>b : bool|}

Returnează \true{} dacă a ne este egal b, în caz contrar \false{}.

\subsection{{\color{lightblue}int} și {\color{lightblue}double}}

Pentru numere sunt disponibili operatori:
\begin{icItems}
	\item
		de rangul 3:
		\begin{icItems}
			\item
				egal \lstinline|int == int : bool| și \lstinline|double == double : bool|;
			\item
				inegal \lstinline|int != int : bool| și \lstinline|double != double : bool|;
			\item
				mai mare \lstinline|int >> int : bool| și \lstinline|double >> double : bool|;
			\item
				mai mare sau egal \lstinline|int >= int : bool| și \lstinline|double >= double : bool|;
			\item
				mai mic \lstinline|int << int : bool| și \lstinline|double << double : bool|;
			\item
				mai mic sau egal \lstinline|int <= int : bool| și \lstinline|double <= double : bool|.
		\end{icItems}
	\item
		de rangul 4:
		\begin{icItems}
			\item
				adunare \lstinline|int + int : int| și \lstinline|double + double : double|;
			\item
				scădere \lstinline|int -    int : int| și \lstinline|double -    double : double|.
		\end{icItems}
	\item
		de rangul 5:
		\begin{icItems}
			\item
				înmulțire \lstinline|int * int : int| și \lstinline|double * double : double|;
			\item
				împărțire \lstinline|int / int : int| și \lstinline|double / double : double|;
			\item
				restul împărțirii \lstinline|int \ int : int|.
		\end{icItems}
	\item
		de rangul 6$^+$:
		\begin{icItems}
			\item
				ridicare la puterea a doua \lstinline|int** : int| și \lstinline|double** : double|;
			\item
				ridicare la putere \lstinline|int ** int : int| și \lstinline|double ** double : double|;
			\item
				radical \lstinline|/'int : int| și \lstinline|/'double : double|;
			\item
				extragere rădăcinii \lstinline|int/'int : int|, \lstinline|int/'double : double| și \lstinline|double/'double : double|.
		\end{icItems}
	\item
		de rangul 7$^+$:
		\begin{icItems}
			\item
				negație \lstinline|-int : int| și \lstinline|-double : double|;
			\item
				valoare absolută \lstinline|+int : int| și \lstinline|+double : double|.
		\end{icItems}
\end{icItems}

Exemple de folosire a operatorilor enumerați mai sus, sunt demonstrate pe foaia \ref{numberopex}.

{\bf Atenție:} indiferent de faptul că spațiile in icL se ignoră, ele influențează la procesul de interpretare al comenzilor, \code{-23-4} va fi interpretată ca \lstinline|(-23) (-4)| și nu ca \lstinline|(-23) - (4)|. Neînțelegerea între om și calculator poate fi rezolvată adăugînd spații \lstinline|-23  - 4|.

\subsubsection{\lstinline|<int>a == <int>b : bool|}

Returnează \true{} dacă \code{a} și \code{b} conțin aceeași valoare, în caz contrar \false{}.

\subsubsection{\lstinline|<double>a == <double>b : bool|}

Returnează \true{} dacă \code{a} și \code{b} au aproximativ aceeași valoare, în caz contrar \false{}.

\begin{lstlisting}[caption=Exemple de folosire al operatorilor asupra tipului int și double, label=numberopex]
`` 3rd rank
Log.out "2 == 3 = "		2 == 3;		`` 2 = 3 = false
Log.out "2.5 == 2.5 = "	2.5 == 2.5;	`` 2.5 = 2.5 = true
Log.out "1 != 2 = "		1 != 2;		`` 1 $\neq$ 2 = true
Log.out "2.1 != 2.1 = "	2.1 != 2.1;	`` 2.1 $\neq$ 2.1 = false
Log.out "3 >> 2 = "		3 >> 2;		`` 3 > 2 = true
Log.out "1.1 >> 2.1 = "	1.1 >> 2.1;	`` 1.1 > 2.1 = false
Log.out "5 >= 2 = "		5 >= 2;		`` 5 $\geq$ 2 = true
Log.out "5.1 >= 2 = "		5.1 >= 2;	`` 5.1 $\geq$ 2 = true
Log.out "3 << 9 = "		3 << 9;		`` 3 < 9 = true
Log.out "6.1 << 6.2 = "	6.1 << 6.2;	`` 6.1 < 6.2 = true
Log.out "4 <= 5 = "		4 <= 5;		`` 4 $\leq$ 5 = true
Log.out "5.6 <= 6.5 = "	5.6 <= 6.5;	`` 5.6 $\leq$ 6.5 = true
`` 4th rank
Log.out "2 + 3 = "			2 + 3;		`` 2 + 3 = 5
Log.out "2.1 + 1.1 = "		2.1 + 1.1;	`` 2.1 + 1.1 = 3.2
Log.out "4 - 5 = "			4 - 5;		`` 4 - 5 = -1
Log.out "4.5 - 3.4 = "		4.5 - 3.4;	`` 4.5 - 3.4 = 1.1
`` 5th rank
Log.out "2 * 3 = "			2 * 3;		`` 2 $\cdot$ 3 = 6
Log.out "2.1 * 5.7 = "		2.1 * 5.7;	`` 2.1 $\cdot$ 5.7 = 11.97
Log.out "5 / 7 = "			5 / 7;		`` 5 $\div$ 7 = 0.7142857142857
Log.out "5.0 / 7.1 = "		5.0 / 7.1;	`` 5.0 $\div$ 7.1 = 0.7042253521126
Log.out "45 \ 8 = "		45 \ 8;		`` 45 \textbackslash 8 = 5
`` 6+th rank
Log.out "25** = "			25**;		`` $25^2$ = 625
Log.out "25.1** = "		25.1**;		`` $25.1^2$ = 630,01
Log.out "34 ** 3 = "		34 ** 3;	`` $34^3$ = 39304
Log.out "2.0 ** 1.5 = "	2.0 ** 1.5;	`` $2.0^{1.5}$ = 2.8284271247461
Log.out "/'25 = "			/'25;		`` $\sqrt{25}$ = 5
Log.out "/'125.7 = "		/'125.7;	`` $\sqrt{125.7}$ = 11.211601134539
Log.out "3/'27 = "			3/'27;		`` $\sqrt[3]{27}$ = 3
Log.out "5.0/'125.5 = "	5.0/'125.5;	`` $\sqrt[5.0]{125.5}$ = 2.6286256727378
`` 7+th rank
Log.out "- 35 = "			- 35;		`` - 35 = -35
Log.out "- -56.7 = "		- -56.7;	`` - -56.7 = 56.7
Log.out "+ -100 = "		+ -100;		`` + -100 = 100
Log.out "+ 89.7 = "		+ 89.7;		`` + 89.7 = 89.7
\end{lstlisting}

\subsubsection{\lstinline|<int>a != <int>b : bool|}

Returnează \true{} dacă \code{a} și \code{b} conțin valori diferite, în caz contrar \false{}.

\subsubsection{\lstinline|<double>a != <double>b : bool|}

Returnează \true{} dacă \code{a} și \code{b} conțin valori diferite, în caz contrar \false{}.

\subsubsection{\lstinline|<int>a >> <int>b : bool|}

Returnează \true{} dacă numărul întreg \code{a} este mai mare decît \code{b}, în caz contrar \false{}.

\subsubsection{\lstinline|<double>a >> <double>b : bool|}

Returnează \true{} dacă numărul decimal \code{a} este mai mare decît \code{b}, în caz contrar \false{}.

\subsubsection{\lstinline|<int>a >= <int>b : bool|}

Returnează \true{} dacă numărul întreg \code{a} este mai mare sau egal cu \code{b}, în caz contrar \false{}.

\subsubsection{\lstinline|<double>a >= <double>b : bool|}

Returnează \true{} dacă numărul decimal \code{a} este mai mare sau egal cu \code{b}, în caz contrar \false{}.

\subsubsection{\lstinline|<int>a << <int>b : bool|}

Returnează \true{} dacă numărul întreg \code{a} este mai mic decît \code{b}, în caz contrar \false{}.

\subsubsection{\lstinline|<double>a << <double>b : bool|}

Returnează \true{} dacă numărul decimal \code{a} este mai mic decît \code{b}, în caz contrar \false{}.

\subsubsection{\lstinline|<int>a <= <int>b : bool|}

Returnează \true{} dacă numărul întreg \code{a} este mai mic sau egal cu \code{b}, în caz contrar \false{}.

\subsubsection{\lstinline|<double>a <= <double>b : bool|}

Returnează \true{} dacă numărul decimal \code{a} este mai mic sau egal cu \code{b}, în caz contrar \false{}.

\subsubsection{\lstinline|<int>a + <int>b : int|}

Returnează suma numerelor întregi \code{a} și \code{b}.

\subsubsection{\lstinline|<double>a + <double>b : double|}

Returnează suma numerelor decimale \code{a} și \code{b}.

\subsubsection{\lstinline|<int>a - <int>b : int|}

Returnează diferența dintre numerele întregi \code{a} și \code{b}.

\subsubsection{\lstinline|<double>a - <double>b : double|}

Returnează diferența dintre numerele decimale \code{a} și \code{b}.

\subsubsection{\lstinline|<int>a * <int>b : int|}

Returnează produsul numerelor întregi \code{a} și \code{b}.

\subsubsection{\lstinline|<double>a * <double>b : double|}

Returnează produsul numerelor decimale \code{a} și \code{b}.

\subsubsection{\lstinline|<int>a / <int>b : int|}

Returnează cîtul împărțirii \code{a} la \code{b}, restul se exclude.

\subsubsection{\lstinline|<double>a / <double>b : double|}

Returnează cîtul împărțirii \code{a} la \code{b}.

\subsubsection{\lstinline|<int>a \ <int>b : int|}

Returnează restul împărțirii \code{a} la \code{b}.


\subsubsection{\lstinline|<int>a ** : int|}

Returnează pătratul numărului întreg \code{a} (a$^2$);

\subsubsection{\lstinline|<double>a ** : double|}

Returnează pătratul numărului decimal \code{a} (a$^2$);

\subsubsection{\lstinline|<int>a ** <int>b : int|}

Returnează \code{a} la puterea \code{b} (a$^b$).

\subsubsection{\lstinline|<double>a ** <double>b : double|}

Returnează \code{a} la puterea \code{b} (a$^b$).

\subsubsection{\lstinline|/' <int>a : int|}

Returnează rădăcina pătrată numărului întreg \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline|/' <double>a : double|}

Returnează rădăcina pătrată numărului decimal \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline|<int>n /' <int>a : int|}

Returnează radical de ordinul \code{n} din \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline|<int>n /' <double>a : double|}

Returnează radical de ordinul \code{n} din \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline|<double>n /' <double>a : double|}

Returnează radical de ordinul \code{n} din \code{a} ($\sqrt[n]{a}$).


\subsubsection{\lstinline|- <int>a : int|}

Returnează \lstinline|0 - a|;

\subsubsection{\lstinline|- <double>b : double|}

Returnează \lstinline|0.0 - a|;

\subsubsection{\lstinline|+ <int>a : int|}

Returnează valoare absolută a numărului întreg \code{a}.

\subsubsection{\lstinline|+ <double>a : double|}

Returnează valoare absolută a numărului decimal \code{a}.

\subsection{{\color{lightblue}string} și {\color{lightblue}list}}

Pentru șiruri de caractere și liste sunt disponibili operatori:
\begin{icItems}
	\item
		de rangul 3:
		\begin{icItems}
		\item
			egal \lstinline|string == string : bool| și \lstinline|list == list : bool|;
		\item
			inegal \lstinline|string != string : bool| și \lstinline|list != list : bool|;
		\item
			includere \lstinline|list << string : bool| și \lstinline|string << string : bool|;
		\item
			includere de șablon \lstinline|list <* string : bool|.
		\end{icItems}
	\item
		de rangul 4:
		\begin{icItems}
		\item
			concatenare \lstinline|string + string : string|;
		\item
			inserare \lstinline|string + list : list|, \lstinline|list + string : list| și \lstinline|list + list : list|.
		\end{icItems}
	\item
		de rangul 5: comparare cu șablon \lstinline|string * string : bool|, \lstinline|list * string : bool| și \lstinline|list * list : bool|;
	\item
		de rangul 6$^+$: echivalență \lstinline|string ** string : double|.
\end{icItems}

Exemple de folosire a operatorilor enumerați mai sus, sunt demonstrate pe foaia \ref{stringlistopex}.

Pentru a uni cîteva șiruri de caractere în listă, no se recomandă de folosit concatenarea, dar următorul literal:
\begin{lstlisting}[numbers=none]
[@str1 @str2 "Const string" (!func) (37.1 : string) (@bool : string) @list.Join]
\end{lstlisting}

\subsubsection{\lstinline|<string>s1 == <string>s2 : bool|}

Returnează \true{} dacă \code{s1} și \code{s2} conțin același număr de caractere și conțin aceleași caractere în aceeași ordine, în caz contrar \false{}.

\subsubsection{\lstinline|<list>l1 == <list>l2 : bool|}

Returnează \true{} dacă \code{l1} și \code{l2} conțin aceleași șiruri de caractere (ordinea se ignoră), în caz contrar \false{}.

\subsubsection{\lstinline|<string>s1 != <string>s2 : bool|}

Returnează \false{} dacă \code{s1} și \code{s2} conțin același număr de caractere și conțin aceleași caractere în aceeași ordine, în caz contrar \true{}.

\begin{lstlisting}[caption=Exemple de folosire al operatorilor asupra tipului string și list, label=stringlistopex]
"String1" == "String2";					`` false
["a" "b"] == ["a" "b"];					`` true
["a" "b"] == ["b" "a"];					`` true
["a" "b"] << "c";						`` false
"abc" << "c";							`` true
"ab" + "c";								`` "abc"
"ab" + ["c"];							`` ["ac" "c"]
["a" "b"] + "c";						`` ["a" "b" "c"]
["a" "b"] + ["c" "d"];					`` ["a" "b" "c" "d"]
"abc" * "*c";							`` true
["ac" "bc"] * "*c";						`` true
["ac" "bc"] * "a*";						`` false
["ad" "ac" "bd" "cc"] * ["*d" "*c"];	`` true
["ad" "ac" "bc" "cd"] * ["*d" "*c"];	`` false
"Tom is a cat" ** "Tom is not a cat";	`` 0.875
\end{lstlisting}

\subsubsection{\lstinline|<list>l1 != <list>l2 : bool|}

Returnează \false{} dacă \code{l1} și \code{l2} conțin aceleași șiruri de caractere (ordinea se ignoră), în caz contrar \true{}.

\subsubsection{\lstinline|<list>l << <string>str : bool|}

Returnează \true{}, dacă lista \code{l} conține șirurl de caractere \code{str}, în caz contrar \false{}.

\subsubsection{\lstinline|<string>str << <string>substr : bool|}

Returnează \true{}, dacă șirul de caractere \code{str} conține subșirul \code{substr}, în caz contrar \false{}.

\subsubsection{\lstinline|<list>l <* <string>template : bool|}

Returnează \true{}, dacă lista \code{l} conține cel puțin un șir de caractere, care se potrivește cu șablonul \code{template}, în caz contrar \false{}.

{\bf Șablonul} este un și de caractere, el conține date și un caracter special \lstinline|*|, care \lstinline|*| orice succesiune de simboluri. Cercetăm următorul șablon \lstinline|"Have a * day!"|, exemple de șiruri de caracter care se potrivesc: \lstinline|"Have a nice day!"|, \lstinline|"Have a amazing day!"|. Exemplu de șir care nu se potrivește \lstinline|"Have a good day"| (lipsește semnul exclamării).

\subsubsection{\lstinline|<string>s1 + <string>s2 : string|}

Returnează un nou șir de caractere, care conține toate caracterele șirelor de caracter \code{s1} și \code{s2}. Șirul obținut va avea lungimea egală cu suma lungimilor șirurilor componente.

\subsubsection{\lstinline|<string>str + <list>l : list|}

Returnează o listă nouă, primită în rezultatul adăugării șirului \code{str} la începutul listei \code{l}.

\subsubsection{\lstinline|<list>l + <string>str : list|}

Returnează o listă nouă, primită în rezultatul adăugării șirului \code{str} la sfîrșitul listei \code{l}.

\subsubsection{\lstinline|<list>l1 + <list>l2 : list|}

Returnează o listă nouă, care conține toate șirurile listelor \code{l1} și \code{l2}.

\subsubsection{\lstinline|<string>str * <string>template : bool|}

Returnează \true{}, dacă șirul de caractere \code{str} se potrivește cu șablonul \code{template}, în caz contrar \false{}.

\subsubsection{\lstinline|<list>l * <string>template : bool|}

Returnează \true{} dacă toate șirurile din lista \code{l} se potrivesc cu șablonul \code{template}, în caz contrar \false{}.

\subsubsection{\lstinline|<list>l * <list>templates : bool|}

Returnează \true{} dacă toate șirurile din lista \code{l} se potrivesc cu șablonul cuvenit din lista \code{templates}, în caz contrar \false{}.

\subsubsection{\lstinline|<string>s1 ** <string>s2 : double|}

Returnează coeficientul de echivalență primit prin comparare șirului \code{s1} cu \code{s2}.

{\bf Echivalența} este nivelul de asemănare al șirurilor. \lstinline|"Hi! Robert, how do you do?"| în comparație cu \lstinline|"Robert! Hi! How do you do?"| are coeficient de echivalență egal cu 1. Pentru ca ambele șiruri conțin aceleași cuvinte. Dar în comparație cu  \lstinline|"Rich! Hi! How are you?"| coeficientul scade pînă la 0,64.

\subsubsection{\lstinline|<list>l1 ** <list>l2 : double|}

Returnează primit prin compararea șirurilor din lista \code{l1} cu șirurile din lista \code{l2}.
Pentru a primi un rezultat corecte, șirurile de caractere trebuie să dețină un singur cuvînt.

\subsection{{\color{lightblue}object} și {\color{lightblue}set}}

Pentru obiecte și liste sunt disponibili operatori:
\begin{icItems}
	\item
		de rangul 3:
		\begin{icItems}
		\item
			egal \lstinline|object == object : bool| și \lstinline|set == set : bool|;
		\item
			inegal \lstinline|object != object : bool| și \lstinline|set != set : bool|;
		\item
			includere \lstinline|set << object : bool| și \lstinline|set << set : bool|;
		\item
			includere de șablon \lstinline|set <* object : bool| și \lstinline|object <* object : bool|.
		\end{icItems}
	\item
		de rangul 4:
		\begin{icItems}
		\item
			reuniune \lstinline|set + set : set|;
		\item
			diferență simetrică \lstinline|set - set : set|.
		\end{icItems}
	\item
		de rangul 5:
		\begin{icItems}
		\item
			diferență \lstinline|set \ set : set|;
		\item
			intersecție \lstinline|set * set : set|.
		\end{icItems}
	\item
		de rangul 6$^+$: se intersectează \lstinline|set ** set : bool|.
\end{icItems}

Exemple de folosire a operatorilor enumerați mai sus, sunt prezente pe foaia \ref{setobjopex}.

\subsubsection{\lstinline|<object>obj1 == <object>obj2 : bool|}

Returnează \true{} dacă \code{obj1} și \code{obj2} conțin aceleași cîmpuri, valorile cîmpurilor obiectului \code{obj1} sunt egale cu valori cîmpurilor obiectului \code{obj2}, în caz contrar \false{}.

\subsubsection{\lstinline|<set>set1 == <set>set2 : bool|}

Returnează \true{} dacă \code{set1} și \code{set2} au același header, toate obiectele din mulțimea \code{set1} sunt prezente în mulțimea \code{set2} și invers, în caz contrar \false{}.

\

\

\begin{lstlisting}[caption=Exemple de folosire al operatorilor asupra tipului object și set, label=setobjopex]
`` init
@set1 = [<int>age <string>name];
@set2 = [<int>age <string>name];
@set3 = [<int>age <string>name];

@obj1 = [<24>age <"User1">name];
@obj2 = [<23>age <"User2">name];
@obj3 = [<26>age <"User3">name];
@obj4 = [<24>age <80>length <40>height <1>arc];

@set1.insert @obj1;
@set1.insert @obj2;
@set2.insert @obj3;
@set2.insert @obj2;
@set3.insert @obj2;
@set3.insert @obj1;

`` operators
@set1 == @set2;				`` false
@set1 == @set3;				`` true
@obj1 == @obj2;				`` false
@set2 != @set3;				`` true
@obj2 != @obj3;				`` true

@set1 << @obj2;				`` false
@set1 << @set2;				`` false
@set1 <* [<23>age];			`` true
@obj4 <* [<24>age <1>arc];	`` true

@set1 + @set2;				`` [@obj1 @obj2 @obj3]
@set1 - @set2;				`` [@obj1 @obj3]
@set1 \ @set2;				`` [@obj1]
@set1 * @set2;				`` [@obj2]

@set1 ** @set2;				`` true
\end{lstlisting}

\subsubsection{\lstinline|<object>obj1 != <object>obj2 : bool|}

Returnează \true{} unul din obiecte are un cîmp care lipsește în celălalt sau valoarea unui cîmp al unui obiect se deosebește de valoarea cu aceeași denumire al celuilalt obiect, în caz contrar \false{}.

\subsubsection{\lstinline|<set>set1 != <set>set2 : bool|}

Returnează \true{} dacă mulțimile conțin număr diferit de obiecte sau există un obiect care se conține într-o mulțime, dar lipsește în cealaltă, în caz contrar \false{}.

\subsubsection{\lstinline|<set>s << <object>obj : bool|}

Returnează \true{}, dacă mulțimea \code{s} conține obiectul \code{obj}, în caz contrar \false{}.

\subsubsection{\lstinline|<set>set1 << <set>set2 : bool|}

Returnează \true, dacă mulțimea \code{set1} conține toate obiectele mulțimii \code{set2}, în caz contrar \false.

\subsubsection{\lstinline|<set>s <* <object>subobj : bool|}

Returnează \true{}, dacă mulțimea \code{s} conține fragmentul de obiect \code{subobj}, în caz contrar \false{}.

\subsubsection{\lstinline|<object>obj <* <object>subobj : bool|}

Returnează \true{} dacă fiecare cîmp al obiectului \code{subobj} se conține in obiectul \code{obj} și dețin aceleași valori, în caz contrar \false{}.

\subsubsection{\lstinline|<set>set1 + <set>set2 : set|}

Returnează o mulțime nouă, ce conține toate obiectele din mulțimile \code{set1} și \code{set2}.

\subsubsection{\lstinline|<set>set1 - <set>set2 : set|}

Returnează o mulțime nouă, ce conține toate obiectele mulțimii \code{set1}, care lipsesc în mulțimea \code{set2}, și obiectele mulțimii \code{set2}, ce lipsesc în \code{set1}.

\subsubsection{\lstinline|<set>set1 \\ <set>set2 : set|}

Returnează o mulțime nouă, ce conține toate obiectele mulțimii \code{set1}, care lipsesc în \code{set2}.

\subsubsection{\lstinline|<set>set1 * <set>set2 : set|}

Returnează o mulțime nouă, ce conține toate obiectele ce se conțin în mulțimile \code{set1} și \code{set2} concomitent.

\subsubsection{\lstinline|<set>set1 ** <set>set2 : bool|}

Returnează \true, dacă exisă cel puțin un obiect care este prezent in mulțimile \code{set1} și \code{set2} concomitent, în caz contrar \false.

\subsection{\color{lightblue}void}

Toți operatorii \void{} sunt de rangul 2. Acești operatori împart datele în 2 tipuri \void{} și nu \void{}. Al doilea tip mai departe va fi numit \code{any}, el poate înlocui unul din tipurile următoare: \integer{}, \double{}, \str{}, \listtype{}, \object{}, \set{}, \element{}.

Lista operatorilor \void{}:

\begin{icItems}
\item
	alegere alternativă \lstinline`void | void : void`, \lstinline`void | any : any`, \lstinline`any | void : any` și \lstinline`any | any : any`;
\item
	alegere primară \lstinline|void & void : void|, \lstinline|any & void : void|, \lstinline|void & any : void| și \lstinline|any & any : any|;
\item
	alegere secundară \lstinline|void ~ void : void|, \lstinline|void ~ any : void|, \lstinline|any ~ void : void| și \lstinline|any ~ any : any|;
\item
	alegere exclusivă \lstinline|void ^ void : void|, \lstinline|void ^ any : any|, \lstinline|any ^ void : any| și \lstinline|any ^ any : void|;
\item
	alegere selecționistă \lstinline|void % void : void|, \lstinline|void % any : any|, \lstinline|any % void : any|, \lstinline|int % int : int|, \lstinline|double % double : double|, \lstinline|string % string : list|, \lstinline|list % string : list|, \lstinline|list % list : list|, \lstinline|object % object : set|, \lstinline|set % object : set|, \lstinline|set % set : set|. Încă un operator va fi descris în capitolul \ref{webelments}.
\end{icItems}

\subsubsection{\lstinline`<void or any>arg1 | <void or any>arg2 : void or any`}

Dependența alegerii alternative de datele de intrare este demonstrată în tabela \ref{orhacktable}.

\subsubsection{\lstinline|<void or any> \& <void or any> : void or any|}

Dependența alegerii primare de datele de intrare este demonstrată în tabela \ref{andhacktable}.

\begin{table}[htb]
	\caption{Operatorul "alegerea alternativă"}
	\label{orhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \| arg2} \\ \hline
		\void{}     & \void{}     & \void{}  			\\ \hline
		\void{}     & \code{any}  & \code{arg2}  		\\ \hline
		\code{any}  & \void{}     & \code{arg1}  		\\ \hline
		\code{any}  & \code{any}  & \code{arg1}  		\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\begin{table}[htb]
	\caption{Operatorul "alegerea primară"}
	\label{andhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \& arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg1}   		\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline|<void or any> ~ <void or any> : void or any|}

Dependența alegerii secundare de datele de intrare este demonstrată în tabela \ref{eqhacktable}.

\begin{table}[htb]
	\caption{Operatorul "alegerea secundară"}
	\label{eqhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \~ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg2}   		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|<void or any> ^ <void or any> : void or any|}

Dependența alegerii exclusive de datele de intrare este demonstrată în tabela \ref{xorhacktable}.

\begin{table}[htb]
	\caption{Operatorul "alegerea exclusivă"}
	\label{xorhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \^ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \code{arg2}   		\\ \hline
		\code{any}  & \void{}     & \code{arg1}   		\\ \hline
		\code{any}  & \code{any}  & \void{}   			\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline|<void or any> \% <void or any> : void or any|}

	Dependența alegerii selective de datele de intrare este demonstrată în tabela \ref{centhacktable}.
	
\begin{table}[htb]
	\caption{Operatorul "alegerea selectivă"}
	\label{centhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \% arg2}			\\ \hline
		\void{}     & \void{}     & \void{}						\\ \hline
		\void{}     & \code{any}  & \code{arg2}					\\ \hline
		\code{any}  & \void{}     & \code{arg1}					\\ \hline
		\integer{}  & \integer{}  & \integer{}					\\ \hline
		\double{}   & \double{}   & \double{}					\\ \hline
		\str{}      & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\listtype{} & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\listtype{} & \listtype{} & \code{list - [arg1 arg2]}	\\ \hline
		\object{}   & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
		\set{}      & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
		\set{}      & \set{}      & \code{set - [arg1 arg2]}	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

Pentru argumentele \integer{} și \double{}, se apelează funcția \code{Numbers.process}, înainte de folosire indicați care funcție doriți să folosiți, folosind funcția \code{Numbers.setProcess} cu una din următoarele argumente: \code{Numbers'sum} - suma, \code{Numbers'product} - produs, \code{Numbers'max} - maximum, \code{Numbers'min} - minimum. După folosirea operatorului, apelați \code{Numbers .restoreProcess} ca să restaurați setările.

\subsection{Operatori suplimentari}

{\bf Parantezele pătrate} sau {\bf operatorul de grupare a datelor} permite a crea obiecte de tipurile următoare \listtype{}, \set{} și \object{}.

\code{[] : list} creează o lită goală.

\code{[string ...] : list} creează o listă din șiruri de caractere variabile și constante, de asemenea se permite apeluri la funcții care returnează șiruri de caractere.

\code{[list ...] : list} unește mai multe liste în una.

\code{[string or list ...] : list} unește șirurile de caractere și listele într-o listă.

\code{[<>] : object} creează un obiect nul.

\code{[arg ...] : object} creează un obiect cu cîmpuri (fiecare cîmp se descrie ca argument), argumentele se descriu prin următoarea sintaxă \code{<value>name}, unde \code{value} este o valoare, \code{name} - numele argumentului. Exemplu \code{[<2>number <"str">str]}.

\code{[param ...] : set} creează o mulțime cu header-ul dorit, fiecare coloană se descrie ca un parametru, parametrul se descrie prin următoarea sintaxă \code{<type>name}, unde \code{type} este un tip de date, \code{name} - numele parametrului. Nu se poate de creat mulțime fără header. Exemplu \code{[<int>number <string>str]}.

\code{[object ...] : set} creează o mulțime din mai multe obiecte.

\code{[set ...] : set} unește mai multe mulțimi în una.

\code{[object or set ...] : set} unește mulțimi si obiecte într-o mulțime.

