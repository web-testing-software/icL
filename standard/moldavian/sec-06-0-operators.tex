% !TeX spellcheck = ro_RO
\section{Operatori}

{\bf Operatorul} este un semn, care desemnează o anumită manipulare de date. Operatori predefiniți în icL sunt foarte mulți, din cauza aceasta ei vor fi repartizați pe tipuri de date în ordinea următoare:

\begin{icEnum}
	\item \bool{};
	\item \integer{};
	\item \double{};
	\item \str{};
	\item \listtype{};
	\item \object{};
	\item \set{};
	\item \void{}.
\end{icEnum}

Fiecare operator are rang, operatorii care au cel mai mare rang se execut primii, dar cei cu cel mai mic - ultimii. Operatori care au asociativitate dreaptă se execută înainte de operatorii cu asociativitate stîngă. Ei sunt însemnați cu un plus în partea dreaptă, de exemplu 7$^+$.

{\bf Operatorul de atribuire} are rang 0 și asociativitate dreaptă.

\subsection{\color{lightblue}bool}

Dacă nu aveți cunoștințe în algebră booleană, vă rugăm să citați o carte pe această temă.

Pentru tipul de date \bool{}, sunt disponibile:

\begin{icItems}
	\item
		operatori de algebră booleană (care dețin rangul 2):
	\begin{icItems}
		\item
			conjuncție - \lstinline|bool & bool : bool|;
		\item
			disjuncție - \lstinline`bool | bool : bool`;
		\item
			echivalență logică - \lstinline|bool ~ bool : bool|;
		\item
			disjuncție exclusivă - \lstinline|bool ^ bool : bool|;
		\item
			negație booleană (care deține rangul 7$^+$) - \lstinline|! bool : bool|;
	\end{icItems}

	\item
		operatori de comparare (care dețin rangul 3):
	\begin{icItems}
		\item
			egal - \lstinline|bool == bool : bool|;
		\item
			inegal - \lstinline|bool != bool : bool|;
	\end{icItems}
\end{icItems}

Exemple de folosire a operatorilor enumerați mai sus, sunt demonstrate pe foaia \ref{boolopex}.

\begin{lstlisting}[caption=Exemple de folosite a operatorilor asupra tipului bool, label=boolopex]
_log.out "true & false = " (true & false);		`` true \& false = false
_log.out "false | true =  " (false | true);		`` false | true = true
_log.out "true ~ false = " (true ~ false);		`` true \textasciitilde\ false = false
_log.out "false ^ true = " (false ^ true);		`` false \textasciicircum\ true = true`

_log.out "!true = " !true;						`` !true = false
_log.out "!false = " !false;					`` !false = true

_log.out "true == false = " (true == false);	`` true == false = false
_log.out "false != true = " (false != true);	`` false != true = true
\end{lstlisting}

\subsubsection{\lstinline|<bool>a & <bool>b : bool|}

Operatorul aplică operația "conjuncție logică" asupra a și b. Dependența rezultatului de datele de intrare este demonstrată în tabela \ref{conjtable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al conjuncției}
	\label{conjtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \& b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a | <bool>b : bool`}

Operatorul aplică operația "disjuncție logică" asupra variabilelor a și b. Dependența rezultatului de datele de intrare este demonstrată în tabela  \ref{distable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al disjuncției}
	\label{distable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \| b} 	\\ \hline
		\false{} & \false{} & \false{} 		\\ \hline
		\false{} & \true{}  & \true{}  		\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \true{}  		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|<bool>a ~ <bool>b : bool|}

Operatorul aplică operația "echivalență logică" asupra variabilelor a și b. Dependența rezultatului de datele de intrare este demonstrată în tabela \ref{logeqtable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al echivalenței}
	\label{logeqtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \~ b} \\ \hline
		\false{} & \false{} & \true{}   	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline|<bool>a ^ <bool>b : bool|}

Operatorul aplică operația "disjuncție exclusivă" asupra variabilelor a și b. Dependența rezultatului de datele de intrare este demonstrată în tabela \ref{logdifftable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al disjuncției exclusive}
	\label{logdifftable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \^ b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \true{}   	\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \false{}  	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|! <bool>a : bool|}

Operatorul aplică operația "negație logică" asupra variabilei a. Dependența rezultatului de datele de intrare este demonstrată în tabela  \ref{invtable}.

\begin{table}[htb]
	\caption{Tabelul de adevăr al negației logice}
	\label{invtable}
	\begin{tabular}{|c|c|}
		\hline
		\code{a} & \code{!a} \\ \hline
		\false{} & \true{} 	 \\ \hline
		\true{}  & \false{}  \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<bool>a == <bool>b : bool`}

Возвращает \true{} если a равно b, иначе \false{}.

\subsubsection{\lstinline`<bool>a != <bool>b : bool`}

Возвращает \true{} если a равно b, иначе \false{}.

\subsection{{\color{lightblue}int} и {\color{lightblue}double}}

Для чисел доступны операций:
\begin{icItems}
	\item
		3-ого ранга:
		\begin{icItems}
			\item
				равно \lstinline`int == int : bool` и \lstinline`double == double : bool`
			\item
				не равно \lstinline`int != int : bool` и \lstinline`double != double : bool`
			\item
				больше \lstinline`int >> int : bool` и \lstinline`double >> double : bool`
			\item
				больше или равно \lstinline`int >= int : bool` и \lstinline`double >= double : bool`
			\item
				меньше \lstinline`int << int : bool` и \lstinline`double << double : bool`
			\item
				меньше или равно \lstinline`int <= int : bool` и \lstinline`double <= double : bool`
		\end{icItems}
	\item
		4-ого ранга:
		\begin{icItems}
			\item
				сложение \lstinline`int + int : int` и \lstinline`double + double : double`;
			\item
				вычитание \lstinline`int -    int : int` и \lstinline`double -    double : double`.
		\end{icItems}
	\item
		5-ого ранга:
		\begin{icItems}
			\item
				умножение \lstinline`int * int : int` и \lstinline`double * double : double`;
			\item
				деление \lstinline`int / int : int` и \lstinline`double / double : double`;
			\item
				остаток от деления целых чисел \lstinline`int \ int : int`.
		\end{icItems}
	\item
		6$^+$-ого ранга:
		\begin{icItems}
			\item
				возведения в квадрат \lstinline`int** : int` и \lstinline`double** : double`;
			\item
				возведения в степень \lstinline`int ** int : int` и \lstinline`double ** double : double`;
			\item
				извлечения квадратного корня \lstinline`/'int : int` и \lstinline`/'double : double`;
			\item
				извлечения корня \lstinline`int/'int : int`, \lstinline|int/'double : double| и \lstinline`double/'double : double`.
		\end{icItems}
	\item
		7$^+$-ого ранга:
		\begin{icItems}
			\item
				инверсия знака \lstinline`-int : int` и \lstinline`-double : double`;
			\item
				абсолютное значение \lstinline`+int : int` и \lstinline`+double : double`.
		\end{icItems}
\end{icItems}

Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{numberopex}.

{\bf Внимание:} несмотря на то что пробелы в icL игнорируются, они влияют на восприятии кода, \code{-23-4} будет восприниматься как \lstinline`(-23) (-4)` а не как \lstinline`(-23) - (4)`. Недоразумение между человеком и машиной решается добавлением пробелов \lstinline`-23  - 4`.

\subsubsection{\lstinline`<int>a == <int>b : bool`}

Возвращает \true{} если \code{a} и \code{b} имеют одинаковое значение, иначе \false{}.

\subsubsection{\lstinline`<double>a == <double>b : bool`}

Возвращает \true{} если \code{a} и \code{b} отличаются довольно мало (например на 10$^{-15}$), иначе \false{}.

\begin{lstlisting}[caption=Exemple de folosire al operatorilor asupra tipului int и double, label=numberopex]
`` 3rd rank
_log.out "2 == 3 = "		2 == 3;		`` 2 = 3 = false
_log.out "2.5 == 2.5 = "	2.5 == 2.5;	`` 2.5 = 2.5 = true
_log.out "1 != 2 = "		1 != 2;		`` 1 $\neq$ 2 = true
_log.out "2.1 != 2.1 = "	2.1 != 2.1;	`` 2.1 $\neq$ 2.1 = false
_log.out "3 >> 2 = "		3 >> 2;		`` 3 > 2 = true
_log.out "1.1 >> 2.1 = "	1.1 >> 2.1;	`` 1.1 > 2.1 = false
_log.out "5 >= 2 = "		5 >= 2;		`` 5 $\geq$ 2 = true
_log.out "5.1 >= 2 = "		5.1 >= 2;	`` 5.1 $\geq$ 2 = true
_log.out "3 << 9 = "		3 << 9;		`` 3 < 9 = true
_log.out "6.1 << 6.2 = "	6.1 << 6.2;	`` 6.1 < 6.2 = true
_log.out "4 <= 5 = "		4 <= 5;		`` 4 $\leq$ 5 = true
_log.out "5.6 <= 6.5 = "	5.6 <= 6.5;	`` 5.6 $\leq$ 6.5 = true
`` 4th rank
_log.out "2 + 3 = "			2 + 3;		`` 2 + 3 = 5
_log.out "2.1 + 1.1 = "		2.1 + 1.1;	`` 2.1 + 1.1 = 3.2
_log.out "4 - 5 = "			4 - 5;		`` 4 - 5 = -1
_log.out "4.5 - 3.4 = "		4.5 - 3.4;	`` 4.5 - 3.4 = 1.1
`` 5th rank
_log.out "2 * 3 = "			2 * 3;		`` 2 $\cdot$ 3 = 6
_log.out "2.1 * 5.7 = "		2.1 * 5.7;	`` 2.1 $\cdot$ 5.7 = 11.97
_log.out "5 / 7 = "			5 / 7;		`` 5 $\div$ 7 = 0.7142857142857
_log.out "5.0 / 7.1 = "		5.0 / 7.1;	`` 5.0 $\div$ 7.1 = 0.7042253521126
_log.out "45 \ 8 = "		45 \ 8;		`` 45 \textbackslash 8 = 5
`` 6+th rank
_log.out "25** = "			25**;		`` $25^2$ = 625
_log.out "25.1** = "		25.1**;		`` $25.1^2$ = 630,01
_log.out "34 ** 3 = "		34 ** 3;	`` $34^3$ = 39304
_log.out "2.0 ** 1.5 = "	2.0 ** 1.5;	`` $2.0^{1.5}$ = 2.8284271247461
_log.out "/'25 = "			/'25;		`` $\sqrt{25}$ = 5
_log.out "/'125.7 = "		/'125.7;	`` $\sqrt{125.7}$ = 11.211601134539
_log.out "3/'27 = "			3/'27;		`` $\sqrt[3]{27}$ = 3
_log.out "5.0/'125.5 = "	5.0/'125.5;	`` $\sqrt[5.0]{125.5}$ = 2.6286256727378
`` 7+th rank
_log.out "- 35 = "			- 35;		`` - 35 = -35
_log.out "- -56.7 = "		- -56.7;	`` - -56.7 = 56.7
_log.out "+ -100 = "		+ -100;		`` + -100 = 100
_log.out "+ 89.7 = "		+ 89.7;		`` + 89.7 = 89.7
\end{lstlisting}

\subsubsection{\lstinline`<int>a != <int>b : bool`}

Возвращает \true{} если \code{a} и \code{b} не имеют одинаковое значение, иначе \false{}.

\subsubsection{\lstinline`<double>a != <double>b : bool`}

Возвращает \true{} если \code{a} и \code{b} отличаются больше чем на уровень погрешности машины, иначе \false{}.

\subsubsection{\lstinline`<int>a >> <int>b : bool`}

Возвращает \true{} если целое число \code{a} больше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a >> <double>b : bool`}

Возвращает \true{} если дробное число \code{a} больше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<int>a >= <int>b : bool`}

Возвращает \true{} если целое число \code{a} больше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a >= <double>b : bool`}

Возвращает \true{} если дробное число \code{a} больше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline`<int>a << <int>b : bool`}

Возвращает \true{} если целое число \code{a} меньше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a << <double>b : bool`}

Возвращает \true{} если дробное число \code{a} меньше \code{b}, иначе \false{}.

\subsubsection{\lstinline`<int>a <= <int>b : bool`}

Возвращает \true{} если целое число \code{a} меньше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline`<double>a <= <double>b : bool`}

Возвращает \true{} если дробное число \code{a} меньше или равно \code{b}, иначе \false{}.


\subsubsection{\lstinline`<int>a + <int>b : int`}

Возвращает сумму целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a + <double>b : double`}

Возвращает сумму дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a - <int>b : int`}

Возвращает разницу между целыми числами \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a - <double>b : double`}

Возвращает разницу между дробными числами \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a * <int>b : int`}

Возвращает результат умножения целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<double>a * <double>b : double`}

Возвращает результат умножения дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a / <int>b : int`}

Возвращает результат деления целых чисел \code{a} и \code{b}, остаток отбрасывается.

\subsubsection{\lstinline`<double>a / <double>b : double`}

Возвращает результат деления дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline`<int>a \ <int>b : int`}

Возвращает результат от деления целых чисел \code{a} и \code{b}.


\subsubsection{\lstinline`<int>a ** : int`}

Возвращает квадрат целого числа \code{a} (a$^2$);

\subsubsection{\lstinline`<double>a ** : double`}

Возвращает квадрат дробного числа \code{a} (a$^2$);

\subsubsection{\lstinline`<int>a ** <int>b : int`}

Возвращает результат возведения целого числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`<double>a ** <double>b : double`}

Возвращает результат возведения дробного числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline`/' <int>a : int`}

Возвращает корень целого числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`/' <double>a : double`}

Возвращает корень дробного числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline`<int>n /' <int>a : int`}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<int>n /' <double>a : double`}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline`<double>n /' <double>a : double`}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).


\subsubsection{\lstinline`- <int>a : int`}

Возвращает \lstinline|0 - a|;

\subsubsection{\lstinline`- <double>b : double`}

Возвращает \lstinline|0.0 - a|;

\subsubsection{\lstinline`+ <int>a : int`}

Возвращает абсолютное значение целого числа \code{a}.

\subsubsection{\lstinline`+ <double>a : double`}

Возвращает абсолютное значение дробного числа \code{a}.

\subsection{{\color{lightblue}string} и {\color{lightblue}list}}

	Для строк и списков доступны операций:
\begin{icItems}
	\item
		3-ого ранга:
		\begin{icItems}
		\item
			равно \lstinline`string == string : bool` и \lstinline`list == list : bool`;
		\item
			не равно \lstinline`string != string : bool` и \lstinline`list != list : bool`;
		\item
			содержит \lstinline`list << string : bool` и \lstinline`string << string : bool`;
		\item
			содержит строку подходящая по шаблону \lstinline`list <* string : bool`.
		\end{icItems}
	\item
		4-ого ранга:
		\begin{icItems}
		\item
			конкатенация \lstinline`string + string : string`;
		\item
			вставка \lstinline`string + list : list`, \lstinline`list + string : list` и \lstinline`list + list : list`.
		\end{icItems}
	\item
		5-ого ранга: шаблонное сравнение \lstinline`string * string : bool`, \lstinline`list * string : bool` и \lstinline`list * list : bool`;
	\item
		6$^+$-ого ранга: эквивалентность \lstinline`string ** string : double`.
\end{icItems}

Примеры использование операторов присутствуют на листинге \ref{stringlistopex}.

Чтобы из несколько строк получить список, оператор вставки рекомендуется не использовать, вместо него использовать литерал:
\begin{lstlisting}[numbers=none]
[@str1 @str2 "Const string" (!func) (37.1 : string) (@bool : string) @list.Join]
\end{lstlisting}

\subsubsection{\lstinline`<string>s1 == <string>s2 : bool`}

Возвращает \true{} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \false{}.

\subsubsection{\lstinline`<list>l1 == <list>l2 : bool`}

Возвращает \true{} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \false{}.

\subsubsection{\lstinline`<string>s1 != <string>s2 : bool`}

Возвращает \false{} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \true{}.

\begin{lstlisting}[caption=Exemple de folosire al operatorilor asupra tipului string и list, label=stringlistopex]
"String1" == "String2";					`` false
["a" "b"] == ["a" "b"];					`` true
["a" "b"] == ["b" "a"];					`` true
["a" "b"] << "c";						`` false
"abc" << "c";							`` true
"ab" + "c";								`` "abc"
"ab" + ["c"];							`` ["ac" "c"]
["a" "b"] + "c";						`` ["a" "b" "c"]
["a" "b"] + ["c" "d"];					`` ["a" "b" "c" "d"]
"abc" * "*c";							`` true
["ac" "bc"] * "*c";						`` true
["ac" "bc"] * "a*";						`` false
["ad" "ac" "bd" "cc"] * ["*d" "*c"];	`` true
["ad" "ac" "bc" "cd"] * ["*d" "*c"];	`` false
"Tom is a cat" ** "Tom is not a cat";	`` 0.875
\end{lstlisting}

\subsubsection{\lstinline`<list>l1 != <list>l2 : bool`}

Возвращает \false{} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \true{}.

\subsubsection{\lstinline`<list>l << <string>str : bool`}

Возвращает \true{}, если список \code{l} содержит строку \code{str}, иначе \false{}.

\subsubsection{\lstinline`<string>str << <string>substr : bool`}

Возвращает \true{}, если строка \code{str} содержит подстроку \code{substr}, иначе \false{}.

\subsubsection{\lstinline`<list>l <* <string>template : bool`}

Возвращает \true{}, если список \code{l} содержит хотя бы одна строка, подходящая по шаблону \code{template}, иначе \false{}.

{\bf Шаблон} - это строка содержащая данные и специальный символ \lstinline`*`, где \lstinline`*` означает любая последовательность символов. Рассмотрим шаблонную строку \lstinline`"Have a * day!"`, примеры строк подходящие по шаблону: \lstinline`"Have a nice day!"`, \lstinline`"Have a amazing day!"`. Пример неподходящей строки \lstinline`"Have a good day"` (отсутствует восклицательный знак).

\subsubsection{\lstinline`<string>s1 + <string>s2 : string`}

Возвращает строку содержащую все символы строк \code{s1} и \code{s2}. Полученная строка имеет длину равна суммы длин составляющих.

\subsubsection{\lstinline`<string>str + <list>l : list`}

Возвращает новый список, получен при вставке строке \code{str} в начале списка \code{l}.

\subsubsection{\lstinline`<list>l + <string>str : list`}

Возвращает новый список, получен при вставке строке \code{str} в конце списка \code{l}.

\subsubsection{\lstinline`<list>l1 + <list>l2 : list`}

Возвращает новый список, содержащий все элементы списков \code{l1} и \code{l2}.

\subsubsection{\lstinline`<string>str * <string>template : bool`}

Возвращает \true{}, если строка \code{str} подходит по шаблону \code{template}, иначе \false{}.

\subsubsection{\lstinline`<list>l * <string>template : bool`}

Возвращает \true{} если все строки списка \code{l} подходят по шаблону \code{template}, иначе \false{}.

\subsubsection{\lstinline`<list>l * <list>templates : bool`}

Возвращает \true{} если все строки списка \code{l} подходят по соответственному шаблону из списка \code{templates}, иначе \false{}.

\subsubsection{\lstinline`<string>s1 ** <string>s2 : double`}

Возвращает коэффициент эквивалентности получен при сравнении \code{s1} с \code{s2}.

{\bf Эквивалентность} - уровень схожести строк. \lstinline`"Hi! Robert, how do you do?"` относительно \lstinline`"Robert! Hi! How do you do?"` имеет эквивалентность равна единицы. Так как они состоят из одни и те же слова. Но если сравнивать с  \lstinline`"Rich! Hi! How are you?"` оценка снижается до 0,64.

\subsubsection{\lstinline`<list>l1 ** <list>l2 : double`}

Возвращает коэффициент эквивалентности получен при сравнении строк из списка \code{l1} со строками из списка \code{l2}.
Для корректности вычисления, каждая строка должна содержать одно слово.

\subsection{{\color{lightblue}object} и {\color{lightblue}set}}

Для строк и списков доступны операций:
\begin{icItems}
	\item
		3-ого ранга:
		\begin{icItems}
		\item
			равно \lstinline`object == object : bool` и \lstinline`set == set : bool`;
		\item
			не равно \lstinline`object != object : bool` и \lstinline`set != set : bool`;
		\item
			включение \lstinline`set << object : bool` и \lstinline|set << set : bool|;
		\item
			включение шаблона \lstinline`set <* object : bool` и \lstinline`object <* object : bool`.
		\end{icItems}
	\item
		4-ого ранга:
		\begin{icItems}
		\item
			объединение \lstinline`set + set : set`;
		\item
			симметрическая разность \lstinline`set -   set : set`.
		\end{icItems}
	\item
		5-ого ранга:
		\begin{icItems}
		\item
			разность \lstinline`set \ set : set`;
		\item
			пересечение \lstinline`set * set : set`.
		\end{icItems}
	\item
		6$^+$-ого ранга: пересекаются \lstinline|set ** set : bool|.
\end{icItems}

Примеры использование операторов присутствуют на листинге \ref{setobjopex}.

\subsubsection{\lstinline`<object>obj1 == <object>obj2 : bool`}

Возвращает \true{} если \code{obj1} и \code{obj2} имеют одни и те же поля, значения полях из первого объекта совпадает с значениям одноимённых полях второго объекта, иначе \false{}.

\begin{lstlisting}[caption=Exemple de folosire al operatorilor asupra tipului object и set, label=setobjopex]
`` init
@set1 = [<int>age <string>name];
@set2 = [<int>age <string>name];
@set3 = [<int>age <string>name];

@obj1 = [<24>age <"User1">name];
@obj2 = [<23>age <"User2">name];
@obj3 = [<26>age <"User3">name];
@obj4 = [<24>age <80>length <40>height <1>arc];

@set1.insert @obj1;
@set1.insert @obj2;
@set2.insert @obj3;
@set2.insert @obj2;
@set3.insert @obj2;
@set3.insert @obj1;

`` operators
@set1 == @set2;				`` false
@set1 == @set3;				`` true
@obj1 == @obj2;				`` false
@set2 != @set3;				`` true
@obj2 != @obj3;				`` true

@set1 << @obj2;				`` false
@set1 << @set2;				`` false
@set1 <* [<23>age];			`` true
@obj4 <* [<24>age <1>arc];	`` true

@set1 + @set2;				`` [@obj1 @obj2 @obj3]
@set1 - @set2;				`` [@obj1 @obj3]
@set1 \ @set2;				`` [@obj1]
@set1 * @set2;				`` [@obj2]

@set1 ** @set2;				`` true
\end{lstlisting}

\subsubsection{\lstinline`<set>set1 == <set>set2 : bool`}

Возвращает \true{} если \code{set1} и \code{set2} имеют один и тоже заголовок, всё объекты из первой множестве приличествуют во вторым и наоборот, иначе \false{}.

\subsubsection{\lstinline`<object>obj1 != <object>obj2 : bool`}

Возвращает \true{} если один из объектов имеет поле, отсутствующее в другом или значения поле первого отличается от значении одноимённой поле второго объекта, иначе \false{}.

\subsubsection{\lstinline`<set>set1 != <set>set2 : bool`}

Возвращает \true{} если количество объектов во втором объекте отличается от количества объектов в первом или существует объект присутствующий только в одной множестве, иначе \false{}.

\subsubsection{\lstinline`<set>s << <object>obj : bool`}

Возвращает \true{}, если множество \code{s} содержит объект \code{obj}, иначе \false{}.

\subsubsection{\lstinline|<set>set1 << <set>set2 : bool|}

Возвращает \true, если множество \code{set1} содержит подмножество \code{set2}, иначе \false.

\subsubsection{\lstinline`<set>s <* <object>subobj : bool`}

Возвращает \true{}, если множество \code{s} содержит под объект \code{subobj}, иначе \false{}.

\subsubsection{\lstinline`<object>obj <* <object>subobj : bool`}

Возвращает \true{} если каждое поле объекта \code{subobj} содержится в объекте \code{obj} и значение одноимённых полях совпадает, иначе \false{}.

\subsubsection{\lstinline`<set>set1 + <set>set2 : set`}

Возвращает новое множество содержащая все объекты множеств \code{set1} и \code{set2}.

\subsubsection{\lstinline`<set>set1 - <set>set2 : set`}

Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}, и все объекты множестве \code{set2}, отсутствующих в \code{set1}.

\subsubsection{\lstinline`<set>set1 \\ <set>set2 : set`}

Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}.

\subsubsection{\lstinline`<set>set1 * <set>set2 : set`}

Возвращает новое множество содержащая все объекты , которые приличествуют в \code{set1} и \code{set2}.

\subsubsection{\lstinline`<set>set1 ** <set>set2 : bool`}

Возвращает \true, если множества \code{set1} и \code{set2} пересекаются, иначе \false.

\subsection{\color{lightblue}void}

Все \void{} операторы имеют 2-ой ранг. Данные операторы делят данных на 2 типа \void{} и не \void{}. Второй тип в дальнейшем будет отмечен как \code{any}, он может быть один из следующих типов: \integer{}, \double{}, \str{}, \listtype{}, \object{}, \set{}, \element{}.

Список \void{} операторов:

\begin{icItems}
\item
	альтернативный выбор \lstinline`void | void : void`, \lstinline`void | any : any`, \lstinline`any | void : any` и \lstinline`any | any : any`;
\item
	первичный выбор \lstinline|void & void : void|, \lstinline|any & void : void|, \lstinline|void & any : void| и \lstinline|any & any : any|;
\item
	вторичный выбор \lstinline|void ~ void : void|, \lstinline|void ~ any : void|, \lstinline|any ~ void : void| и \lstinline|any ~ any : any|;
\item
	исключающий выбор \lstinline|void ^ void : void|, \lstinline|void ^ any : any|, \lstinline|any ^ void : any| и \lstinline|any ^ any : void|;
\item
	коллекционный выбор \lstinline|void % void : void|, \lstinline|void % any : any|, \lstinline|any % void : any|, \lstinline|int % int : int|, \lstinline|double % double : double|, \lstinline|string % string : list|, \lstinline|list % string : list|, \lstinline|list % list : list|, \lstinline|object % object : set|, \lstinline|set % object : set|, \lstinline|set % set : set|. Ещё одна перегрузка оператора будет объявлена в главе \ref{webelments}.
\end{icItems}

\subsubsection{\lstinline`<void or any>arg1 | <void or any>arg2 : void or any`}

Возвращаемый результат оператором альтернативного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{orhacktable}.

\begin{table}[htb]
	\caption{Оператор альтернативный выбор}
	\label{orhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \| arg2} \\ \hline
		\void{}     & \void{}     & \void{}  			\\ \hline
		\void{}     & \code{any}  & \code{arg2}  		\\ \hline
		\code{any}  & \void{}     & \code{arg1}  		\\ \hline
		\code{any}  & \code{any}  & \code{arg1}  		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> \& <void or any> : void or any`}

Возвращаемый результат оператором первичного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{andhacktable}.

\begin{table}[htb]
	\caption{Оператор первичный выбор}
	\label{andhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \& arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg1}   		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`<void or any> ~ <void or any> : void or any`}

Возвращаемый результат оператором вторичного выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{eqhacktable}.

\begin{table}[htb]
	\caption{Оператор вторичный выбор}
	\label{eqhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \~ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg2}   		\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline`<void or any> ^ <void or any> : void or any`}

Возвращаемый результат оператором исключающего выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{xorhacktable}.

\begin{table}[htb]
	\caption{Оператор исключающий выбор}
	\label{xorhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \^ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \code{arg2}   		\\ \hline
		\code{any}  & \void{}     & \code{arg1}   		\\ \hline
		\code{any}  & \code{any}  & \void{}   			\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline`<void or any> \% <void or any> : void or any`}

	Возвращаемый результат оператором исключающего выбора, в зависимость от аргументов, указан в третьем столбце таблицы \ref{centhacktable}.
%\stablethree{1.5cm}{1.5cm}{5cm}
%{centhacktable}{Оператор коллекционный выбор}
%{\code{arg1}}{\code{arg2}}{\code{a \^ b}}
%{
\begin{table}[htb]
	\caption{Оператор коллекционный выбор}
	\label{centhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \% arg2}			\\ \hline
		\void{}     & \void{}     & \void{}						\\ \hline
		\void{}     & \code{any}  & \code{arg2}					\\ \hline
		\code{any}  & \void{}     & \code{arg1}					\\ \hline
		\integer{}  & \integer{}  & \integer{}					\\ \hline
		\double{}   & \double{}   & \double{}					\\ \hline
		\str{}      & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\listtype{} & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\listtype{} & \listtype{} & \code{list - [arg1 arg2]}	\\ \hline
		\object{}   & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
		\set{}      & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
		\set{}      & \set{}      & \code{set - [arg1 arg2]}	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}
%}

Для аргументов типов \integer{} и \double{}, вызывается функция \code{_numbers.process}, перед использованием установите какую операцию нужно выполнять с числами, использую функцию \code{_numbers.setProcess} с одни из следующих аргументов: \code{_numbers'sum} - сумма, \code{_numbers'product} - произведение, \code{_numbers'max} - максимум, \code{_numbers'min} - минимум. После использования оператора, вызываете \code{_numbers.restoreProcess} чтобы восстановить исходные настройки.

\subsection{Дополнительные операторы}

\subsubsection{\lstinline`[string...]`, \lstinline`[arg...]`, \lstinline`[param...]`, \lstinline`[<>]` и \lstinline`[]`}

{\bf Квадратные скобки} или {\bf оператор объединения данных} позволяет создавать объекты следующих типов данных \listtype{}, \set{} и \object{}.

\code{[] : list} создаёт пустой список.

\code{[string ...] : list} создаёт заполненный список, он может содержать как константные литеры, так и вызовы на функций возвращающие строки. Пример: \code{["a" "b" "c"]}.

\code{[list ...] : list} объединяет несколько списков в один.

\code{[string or list ...] : list} - строки и списки можно смешать.

\code{[<>] : object} создаёт пустой объект.

\code{[arg ...] : object} создаёт объект имеющие поля (каждое поле описывается в виде аргумента), аргумент описывается следующим образом \code{<value>name}, где \code{value} - значение, \code{name} - название аргумента. Пример \code{[<2>number <"str">str]}.

\code{[param ...] : set} создаёт множество с указанным заголовкам, каждый столбец описывается в виде параметра, параметр описывается следующим образом \code{<type>name}, где \code{type} - тип значения, \code{name} - название параметра. Создавать множество с пустым заголовком - запрещено. Пример \code{[<int>number <string>str]}.

\code{[object ...] : set} создаёт множество из несколько объектов.

\code{[set ...] : set} объединяет несколько множеств в одной.

\code{[object or set ...] : set} объекты и множества также можно смешать.

%\newpage
