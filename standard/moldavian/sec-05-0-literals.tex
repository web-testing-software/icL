% !TeX spellcheck = ro_RO
\section{Literale}

Valorile constante, care sunt prezente în cod ca o parte a lui, se numesc {\bf literale}.

Literalul poate fi o valoare din tipurile următoare:

\begin{icItems}
	\item
		valoare booleană - \bool{};
	\item
		număr întreg - \integer{};
	\item
		număr decimal - \double{};
	\item
		șir de caractere - \str{};
	\item
		listă - \listtype{};
	\item
		obiect - \object{};
	\item
		mulțime - \set{}.
\end{icItems}

\subsubsection{Valori booleene}

Pentru definirea {\bf valorilor booleene} se folosesc următoarele literale:
\begin{icItems}
	\item \true{} - adevărat;
	\item \false{} - fals.
\end{icItems}

\subsubsection{Numere întregi}

Pentru definirea {\bf numerelor întregi} se folosesc succesiuni de cifre, înaintea cărora poate fi prezent minus. Între minus și cifre nu ar trebui să fie spațiu, în caz contrar minusul va fi interpretat ca operator.

\noindent Exemple:
\begin{lstlisting}[numbers=none]
23; -23; - 23; +23 + 3; 12 + -34; 15 - 24; 89--56; 2-3; `` ok
23-; 23+; -2А; 3f5; 23f; 23l; 12u; 89i; 2w1; 1q1; rt2;  `` error
\end{lstlisting}

\subsubsection{Numere decimale}

{\bf Literalul decimal} constă din 2 părți: întreagă și fracțională. Ele se despart prin minus. Fiecare parte este un literal întreg. Partea fracțională nu poate fi negativă.

\noindent Exemple -
\begin{lstlisting}[numbers=none]
23.233452; 29229992.2391; 100.0; -23.29199; -0.23; -0.45 - 1000.5;  `` ok
23.-4; 3а.34; 23-.44; 34.+23; -25.f; -23.5f; -w.45; -2.4e10; -2.E2; `` error
\end{lstlisting}

\subsubsection{Șiruri de caractere}

{\bf Șirul de caractere} este o succesiune de caractere, limitată din ambele părți cu ghilimele \lstinline|"|. Pentru a adăuga ghilimele \lstinline|"| în șir se folosește succesiunea \lstinline|\"|. Alte simboluri de asemenea se scriu ca succesiuni din altele două: simbolul de tabulare - \lstinline|\t|, simbolul {\it linie nouă} - \lstinline|\n|, simbolul {\it pas în urmă} - \lstinline|\b|, \textbackslash \ - \lstinline|\\|.

\noindent Exemple -
\begin{lstlisting}[numbers=none]
"Hello \"to\" you!"; "Line1\nLine2"; "Tag1\n\bTag2\n\b"; "text"; "\\ \\ \n \\ \\";
\end{lstlisting}

\subsubsection{Liste}

{\bf Literalul listei} este o succesiune de șiruri de caractere (despărțite prin virgulă), limitată în paranteze pătrate.

\noindent Exemple -
\begin{lstlisting}[numbers=none]
@fruits = ["Apple" "Mango" "Banana" "Lime" "Lemon" "Olive"];
@vegetables = ["Cress" "Mustard" "Guar" "Soybean" "Leek" "Ahipa"];
\end{lstlisting}

\subsubsection{Obiecte}

{\bf Obiectul} este o uniune din cîteva variabile sub un nume, variabila definită în obiect se numește {\it cîmp}. Literalul {\it cîmpului} are sintaxa următoare \lstinline|name = value|, unde  {\it value} e o valoare și {\it name} e numele variabilei. În icL cîmpurile neinițializate, ca și variabilele neinițializate, nu se poate de definit.

De asemenea cîmpul poate fi descris în formă prescurtată \lstinline|@var|, unde \lstinline|@var| poate fi orice variabilă, în acest caz cîmpul primește numele și valoarea variabilei. Dacă cîmpuri sunt cîteva, și nici unul nu este descris clar, șirul semantic \lstinline|[@var1, @var2]| va fi interpretat ca operator de combinare. Ca să declarați clar că acesta este un obiect, adăugați un cîmp fără nume și valoare pe primul loc - \lstinline|[=, @var1, @var2]|.

\noindent Exemple -
\begin{lstlisting}[numbers=none]
@quotation = [author = "author", text = "text"];
@child = [age = 4, hasBrothers = true, hasParents = true];
@file = [isEmpty = false, size = 25220, readOnly = true];

@text = "la la la"; @file = "song.mp3";
@object = [=, @text, @file]; `` [text = @text, file = @file];

@empty = [=];
\end{lstlisting}

\subsubsection{Mulțimi}

Numai {\bf mulțimile vide} pot fi definite cu literal, literalul este foarte asemănător cu literalul obiectelor, numai că în loc de cîmpuri se indică coloane, care au următoarea sintaxă - \lstinline|name : type|, unde  {\it name} e numele coloanei și {\it type} e un tip de date.

Coloana de asemenea poate fi descrisă în formă scurtă, folosind sintaxa \lstinline|type|, unde \lstinline|type| este un tip de date, în acest caz coloana primește numele tipului de date. În comparație cu obiectele aici lipsesc conflictele semantice.

\noindent Exemple -
\begin{lstlisting}[numbers=none]
@quotations = [author : string, text : string];
@children = [age : int, hasBrothers : bool, hasParents : bool];
@files = [isEmpty : bool, size : int, readOnly : bool];

@empty = [:];
\end{lstlisting}

%\newpage
