% !TeX spellcheck = ro_RO
\section{Mulțimi}

{\bf Mulțimile} (tipul \set) cîteva obiecte (de tip \object) fără repetări, pentru mulțimi sunt disponibile operații ca intersecția și reuniunea.

\subsection{{\color{lightblue} object}}

Obiectul conține variabile, fiecare variabilă în obiect are tip și nume. Accesul la variabile se realizează prin proprietăți, unde numele proprietății este numele variabilei.

Cîmpurile obiectelor din mulțime se descriu în header-ul mulțimii.

\subsection{Proprietăți}

Mulțimile dețin următoarele proprietăți:
\begin{icItems}
\item \lstinline|[r/o] set'capacity : int|;
\item \lstinline|[r/o] set'empty : bool|;
\end{icItems}

\subsubsection{\lstinline|[r/o] set'capacity : int|}

Numărul de obiecte care poate fi salvat în mulțime fără a realoca memorie.

\subsubsection{\lstinline|[r/o] set'empty : bool|}

Mulțimea se socoate vidă, dacă nu conține nici un obiect.

\subsection{Metode}

Mulțimile dețin următoarele metode:
\begin{icItems}
\item \lstinline|set.applicate <list ...>data : set|;
\item \lstinline|set.clear : set|;
\item \lstinline|set.getField <string>name : list|;
\item \lstinline|set.hasField <string>name : bool|;
\item \lstinline|set.insert <any ...>data : set|;
\item \lstinline|set.insert <object>obj : set|;
\item \lstinline|set.insertBoolField <string>name <list>values : set|;
\item \lstinline|set.insertDoubleField <string>name <list>values : set|;
\item \lstinline|set.insertIntField <string>name <list>values : set|;
\item \lstinline|set.insertListField <string>name <list>value : set|;
\item \lstinline|set.insertStringField <string>name <list>values : set|;
\item \lstinline|set.remove <any ...>data : set|;
\item \lstinline|set.remove <object>obj : set|;
\item \lstinline|set.removeField <string>name : set|.
\end{icItems}

Exemple de folosire al metodelor descrise mai sus, sunt prezentate pe foaia \ref{setmethods};

\begin{lstlisting}[caption=Metodele clasei set, label=setmethods]
@set = [<int>age <string>name <string>sex]

@set.applicate 
	["23"    "45"     "67"]
	["Basil" "Nataly" "Siri"]
	["m"     "f"      "f"];
``` set = [
	[<23>age <"Basil">name  <"m">sex]
	[<45>age <"Nataly">name <"f">sex]
	[<67>age <"Siri">name   <"f">sex]
	] ```

@set.getField "name"; `` ["Basil" "Nataly" "Siri"]

@set.insert 34 "Critiano" "m";
``` set = [
	[<23>age <"Basil">name    <"m">sex]
	[<45>age <"Nataly">name   <"f">sex]
	[<67>age <"Siri">name     <"f">sex]
	[<34>age <"Cristiano"name <"m">sex]
	] ```

@set.insert [<"f">sex <"Sofia">name <19>age];
``` set = [
	[<23>age <"Basil">name    <"m">sex]
	[<45>age <"Nataly">name   <"f">sex]
	[<67>age <"Siri">name     <"f">sex]
	[<34>age <"Cristiano"name <"m">sex]
	[<19>age <"Sofia">name    <"f">sex]
	] ```

@set.insertStringField "parity" ["odd" "even"];
``` set = [
	[<23>age <"Basil">name    <"m">sex <"odd">parity]
	[<45>age <"Nataly">name   <"f">sex <"even">parity]
	[<67>age <"Siri">name     <"f">sex <"odd">parity]
	[<34>age <"Cristiano"name <"m">sex <"even">parity]
	[<19>age <"Sofia">name    <"f">sex <"odd">parity]
	] ```

@set.remove 45 "Nataly" "f" "even";
``` set = [
	[<23>age <"Basil">name    <"m">sex <"odd">parity]
	[<67>age <"Siri">name     <"f">sex <"odd">parity]
	[<34>age <"Cristiano"name <"m">sex <"even">parity]
	[<19>age <"Sofia">name    <"f">sex <"odd">parity]
	] ```

@set.remove [<34>age <"Cristiano"name <"m">sex <"even">parity];
``` set = [
	[<23>age <"Basil">name <"m">sex <"odd">parity]
	[<67>age <"Siri">name  <"f">sex <"odd">parity]
	[<19>age <"Sofia">name <"f">sex <"odd">parity]
	] ```

@set.removeField "parity";
``` set = [
	[<23>age <"Basil">name <"m">sex]
	[<67>age <"Siri">name  <"f">sex]
	[<19>age <"Sofia">name <"f">sex]
	] ```

@set.clear; `` set = []
\end{lstlisting}

\subsubsection{\lstinline|set.applicate <list ...>data : set|}

Numărul de argumente, trebuie să fie egal cu numărul de cîmpuri în header. Numărul de obiecte adăugate este egal cu lungimea celei mai lungi liste din \code{data}. Din listele mai scurte elementele vor fi adăugate repetat.

Excepții posibile: \ferror{IncompatibleData}.

\subsubsection{\lstinline|set.clear : set|}

Curăță mulțimea.

\subsubsection{\lstinline|set.getField <string>name : list|}

Întoarce lista de valori al cîmpului \code{name}, acumulînd informație din toate obiectele mulțimii.

Excepții posibile: \ferror{FieldNotFound}.

\subsubsection{\lstinline|set.hasField <string>name : bool|}

Returnează \true, dacă header-ul mulțimii conține cîmpul \code{name}, în caz contrar \false.

\subsubsection{\lstinline|set.insert <any ...>data : set|}

Inserează un obiect nou, vectorul \code{data} trebuie numaidecît să fie compatibil complet cu header-ul mulțimii;

Excepții posibile: \ferror{IncompatibleData}.

\subsubsection{\lstinline|set.insert <object>obj : set|}

Inserează un obiect nou, obiectul \code{obj} trebuie numaidecît să fie compatibil cu header-ul mulțimii.

Excepții posibile: \ferror{IncompatibleObject}.

\subsubsection{\lstinline|set.insertBoolField <string>name <list>values : set|}

Creează un cîmp nou de tip \bool. \code{values} poate să fie o listă deșartă numai dacă mulțimea e vidă. Valorile din listă sunt repartizate ca și de metoda \code{set.applicate}.

Excepții posibile: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertDoubleField <string>name <list>values : set|}

Creează un cîmp nou de tip \double. \code{values} poate să fie o listă deșartă numai dacă mulțimea e vidă. Valorile din listă sunt repartizate ca și de metoda \code{set.applicate}.

Excepții posibile: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertIntField <string>name <list>values : set|}

Creează un cîmp nou de tip \integer. \code{values} poate să fie o listă deșartă numai dacă mulțimea e vidă. Valorile din listă sunt repartizate ca și de metoda \code{set.applicate}.

Excepții posibile: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertListField <string>name <list>value : set|}

Creează un cîmp nou de tip \bool. Cîmpul \code{name} în toate obiectele va primi valoarea \code{value}.

Excepții posibile: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertStringField <string>name <list>values : set|}

Creează un cîmp nou de tip \str. \code{values} poate să fie o listă deșartă numai dacă mulțimea e vidă. Valorile din listă sunt repartizate ca și de metoda \code{set.applicate}.

Excepții posibile: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.remove <any ...>data : set|}

Șterge obiectul, care este compatibil cu descrierea \code{data}.

\subsubsection{\lstinline|set.remove <object>obj : set|}

Șterge obiectul \code{obj} din mulțime.

\subsubsection{\lstinline|set.removeField <string>name : set|}

Șterge cîmpul \code{name} din header-ul mulțimii.

Excepții posibile: \ferror{FieldNotFound}.

%\newpage
