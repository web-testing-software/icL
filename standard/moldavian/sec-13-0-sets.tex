% !TeX spellcheck = ro_RO
\section{Mulțimi}

{\bf Mulțimile} (tipul \set) cîteva obiecte (de tip \object) fără repetări, pentru mulțimi sunt disponibile operații ca intersecția și reuniunea.

\subsection{{\color{lightblue} object}}

Obiectul conține variabile, fiecare variabilă în obiect are tip și nume. Accesul la variabile se realizează prin proprietăți, unde numele proprietății este numele variabilei.

Cîmpurile obiectelor din mulțime se descriu în header-ul mulțimii.

Valoarea de tipul \object{} este un link, ca să primești o copie a obiectului, el trebuie copiat folosind metoda \lstinline|object.clone () : object|.

\subsection{Proprietăți}

Mulțimile dețin următoarele proprietăți:
\begin{icItems}
\item \lstinline|[r/o] set'capacity : int|;
\item \lstinline|[r/o] set'empty : bool|;
\end{icItems}

\subsubsection{\lstinline|[r/o] set'capacity : int|}

Numărul de obiecte care poate fi salvat în mulțime fără a realoca memorie.

\subsubsection{\lstinline|[r/o] set'empty : bool|}

Mulțimea se socoate vidă, dacă nu conține nici un obiect.

\subsection{Metode}

Mulțimile dețin următoarele metode:
\begin{icItems}
\item \lstinline|set.applicate (data : list ...) : set|;
\item \lstinline|set.clear () : set|;
\item \lstinline|set.clone () : set|;
\item \lstinline|set.getField (name : string) : list|;
\item \lstinline|set.hasField (name : string) : bool|;
\item \lstinline|set.insert (data : any ...) : set|;
\item \lstinline|set.insert (obj : object) : set|;
\item \lstinline|set.insertField (name : string, value : list, type = list)|;
\item \lstinline|set.insertField (name : string, value : any, type = void)|;
\item \lstinline|set.remove (data : any ...) : set|;
\item \lstinline|set.remove (obj : object) : set|;
\item \lstinline|set.removeField (name : string) : set|.
\end{icItems}

Exemple de folosire al metodelor descrise mai sus, sunt prezentate pe foaia \ref{setmethods};

\begin{lstlisting}[caption=Metodele clasei set, label=setmethods]
@set = [age : int, name : string, sex : string]

@set.applicate (
	["23",    "45",     "67"],
	["Basil", "Nataly", "Siri"],
	["m",     "f",      "f"]);
``` set = [
	[age = 23, name = "Basil",  sex = "m"]
	[age = 45, name = "Nataly", sex = "f"]
	[age = 67, name = "Siri",   sex = "f"]
] ```

@set.getField "name"; `` ["Basil", "Nataly", "Siri"]

@set.insert (34, "Critiano", "m");
``` set = [
	[age = 23, name = "Basil",     sex = "m"]
	[age = 45, name = "Nataly",    sex = "f"]
	[age = 67, name = "Siri",      sex = "f"]
	[age = 34, name = "Cristiano", sex = "m"]
] ```

@set.insert [sex = "f", name = "Sofia", age = 19];
``` set = [
	[age = 23, name = "Basil",    sex = "m"]
	[age = 45, name = "Nataly",   sex = "f"]
	[age = 67, name = "Siri",     sex = "f"]
	[age = 34, name = "Cristiano" sex = "m"]
	[age = 19, name = "Sofia",    sex = "f"]
] ```

@set.insertField ("parity", ["odd", "even"], string);
``` set = [
	[age = 23, name = "Basil",    sex = "m", parity = "odd"]
	[age = 45, name = "Nataly",   sex = "f", parity = "even"]
	[age = 67, name = "Siri",     sex = "f", parity = "odd"]
	[age = 34, name = "Cristiano" sex = "m", parity = "even"]
	[age = 19, name = "Sofia",    sex = "f", parity = "odd"]
] ```

@set.remove (45, "Nataly", "f", "even");
``` set = [
	[age = 23, name = "Basil",    sex = "m", parity = "odd"]
	[age = 67, name = "Siri",     sex = "f", parity = "odd"]
	[age = 34, name = "Cristiano" sex = "m", parity = "even"]
	[age = 19, name = "Sofia",    sex = "f", parity = "odd"]
] ```

@set.remove [age = 34, name = "Cristiano", sex = "m", parity = "even"];
``` set = [
	[age = 23, name = "Basil", sex = "m", parity = "odd"]
	[age = 67, name = "Siri",  sex = "f", parity = "odd"]
	[age = 19, name = "Sofia", sex = "f", parity = "odd"]
] ```

@set.removeField "parity";
``` set = [
	[age = 23, name = "Basil", sex = "m"]
	[age = 67, name = "Siri",  sex = "f"]
	[age = 19, name = "Sofia", sex = "f"]
] ```

@set.clear; `` set = []
\end{lstlisting}

\subsubsection{\lstinline|set.applicate (data : list ...) : set|}

Numărul de argumente, trebuie să fie egal cu numărul de cîmpuri în header. Numărul de obiecte adăugate este egal cu lungimea celei mai lungi liste din \code{data}. Din listele mai scurte elementele vor fi adăugate repetat.

Excepții posibile: \ferror{IncompatibleData} (pr. tab. \ref{errors}).

\subsubsection{\lstinline|set.clear () : set|}

Curăță mulțimea.

\subsubsection{\lstinline|set.clone () : set|}

Creează o copie, prin copierea datelor în alt container.

\subsubsection{\lstinline|set.getField (name : string) : list|}

Întoarce lista de valori al cîmpului \code{name}, acumulînd informație din toate obiectele mulțimii.

Excepții posibile: \ferror{FieldNotFound} (pr. tab. \ref{errors}).

\subsubsection{\lstinline|set.hasField (name : string) : bool|}

Returnează \true, dacă header-ul mulțimii conține cîmpul \code{name}, în caz contrar \false.

\subsubsection{\lstinline|set.insert (data : any ...) : set|}

Inserează un obiect nou, vectorul \code{data} trebuie numaidecît să fie compatibil complet cu header-ul mulțimii;

Excepții posibile: \ferror{IncompatibleData} (pr. tab. \ref{errors}).

\subsubsection{\lstinline|set.insert (obj : object) : set|}

Inserează un obiect nou, obiectul \code{obj} trebuie numaidecît să fie compatibil cu header-ul mulțimii.

Excepții posibile: \ferror{IncompatibleObject} (pr. tab. \ref{errors}).

\subsubsection{\lstinline|set.inserField (name : string, value : list, type = list)|}

Creează un cîmp nou de tip \code{type}. \code{values} poate să fie o listă deșartă numai dacă mulțimea e vidă. Valorile din listă sunt repartizate ca și de metoda \code{set.applicate}.

Excepții posibile: \ferror{FieldAlreadyExists} (pr. tab. \ref{errors}).

\subsubsection{\lstinline|set.insertField (name : string, value : any, type = void)|}

Creează un cîmp nou de tip \code{type}. Dacă \code{type == void} tipul va fi depistat automat, dar e mai bine de în indicat manual, poate exclude unele probleme în viitor.

Excepții posibile: \ferror{FieldAlreadyExists} (pr. tab. \ref{errors}).

\subsubsection{\lstinline|set.remove (data : any ...) : set|}

Șterge obiectul, care este compatibil cu descrierea \code{data}.

\subsubsection{\lstinline|set.remove (obj : object) : set|}

Șterge obiectul \code{obj} din mulțime.

\subsubsection{\lstinline|set.removeField (name : string) : set|}

Șterge cîmpul \code{name} din header-ul mulțimii.

Excepții posibile: \ferror{FieldNotFound} (pr. tab. \ref{errors}).

%\newpage
