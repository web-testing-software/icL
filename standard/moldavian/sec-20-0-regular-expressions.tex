% !TeX spellcheck = ro_RO
\section{Expresii regulare}
\label{regex}

Pentru definirea {\bf expresiilor regulare} se folosește literalul \mintinline{icl}{//șablon//mods}, unde \mintinline{icl}{șablon} este paternul expresii, \mintinline{icl}{mods} sunt modificatorii. În patern grupele pot avea nume, gupa anonimă are următoarea sintaxă \mintinline{icl}{(conținut)}, grupa cu nume - \mintinline{icl}{(?<nume>conținut)}.

Simbolul intern poate fi nu numai \mintinline{icl}{/}, dar și oricare alt simbol, în afară de apostrof (\mintinline{icl}{'}) el intră în conflict cu operatorul {\it rădăcină pătrată} (\mintinline{icl}{/'}), \mintinline{icl}{@}, \mintinline{icl}{#}, \mintinline{icl}{-}, \mintinline{icl}{+} și \mintinline{icl}{!}. De exemplu  \mintinline{icl}{/"șablon"/mods}, \mintinline{icl}{/:șablon:/mods}, \mintinline{icl}{/$șablon$/mods}.

Ca să capturezi începutul șirului de caractere se poate de folosit \mintinline{icl}{^} și \mintinline{icl}{\A}, dar pentru sfîrșit - \mintinline{icl}{$} și \mintinline{icl}{\z}. Primul variant necătînd la popularitatea lui poate funcționa incorect, pentru ca ele capturează începutul și sfîrșitul liniilor în context de text în mai multe linii.

\subsection{Modificatori}

În limbajul icL sunt prezenți următorii modificatori: \mintinline{icl}{/i}, \mintinline{icl}{/s}, \mintinline{icl}{/m}, \mintinline{icl}{/x}, \mintinline{icl}{/u} și \mintinline{icl}{/f}. Modificatorii pot fi combinați, de exemplu \mintinline{icl}{/xi}.

\subsubsection{Modificator \mintinline{icl}{/i}}

Diferența între majuscule și minuscule va fi ignorată. 

\subsubsection{Modificator \mintinline{icl}{/s}}

Punctul va însemna orice simbol, inclusiv și simbolul {\it rînd nou}.

\subsubsection{Modificator \mintinline{icl}{/m}}

Meta-simbolurile \mintinline{icl}{^} și \mintinline{icl}{$} vor captura nu numai începutul și sfîrșitul șirului, dar și al liniilor de text.

\subsubsection{Modificator \mintinline{icl}{/x}}

Toate spațiile vor fi ignorate, simbolul \mintinline{icl}{#} va însemna începutul comentariului, care se termină cu simbolul {\it rînd nou}.

\subsubsection{Modificator \mintinline{icl}{/u}}

Clasele de simboluri \mintinline{icl}{\w}, \mintinline{icl}{\d} ș.a.m.d. și inversiile lor \mintinline{icl}{\W}, \mintinline{icl}{\D} ș.a.m.d. vor captura nu numai literele latine, dar și literele alfabetelor naționale.

\subsubsection{Modificator \mintinline{icl}{/f}}

Se inventează zgîrcirea cuantificatorilor \mintinline{icl}{*}, \mintinline{icl}{+}, \mintinline{icl}{?} ș.a.m.d. și ei devin leneși. Dar versiunile lor leneșe \mintinline{icl}{*?}, \mintinline{icl}{+?}, \mintinline{icl}{??} ș.a.m.d. devin zgîrite.

{\bf Cuantificatorul zgîrgit} capturează cantitatea maximă de simboluri, dar {\bf cuantificatorul leneș} - minimală.

\subsection{Operatori}

Pentru expresiile regulare sunt disponibili următorii operatori:
\begin{icItems}
\item
	de rangul 3:
	\begin{icItems}
	\item
		\mintinline{icl}{string << regex : bool};
	\item
		\mintinline{icl}{string <* regex : list}.
	\end{icItems}

\item 
	de rangul 6$^+$: \mintinline{icl}{string ** regex : object}.
\end{icItems}

Exemple de folosire a operatorilor sunt prezenți pe foaia \ref{regexpopsex}.

\begin{sourcecode}
    \captionof{listing}{Operații cu expresii regulare}
    \label{regexpopsex}
    \inputminted[linenos]{icl}{../sources/regexpopsex.icL}
\end{sourcecode}

\subsubsection{\mintinline{icl}{string << regex : bool}}

Returnează \true{}, dacă șirul conține subșir care convine după expresia regulară, în caz contrar \false{}.

\subsubsection{\mintinline{icl}{string <* regex : list}}

Returnează lista de șiruri capturate, dacă șirul conține subșir care convine după expresia regulară, în caz contrar o listă deșartă.

\subsubsection{\mintinline{icl}{string ** regex : object}}

Returnează un obiect, care conține toate valorilor grupelor cu nume, dacă șirul conține subșir care convine după expresia regulară, în caz contrar o obiect deșert.

% \subsubsection{}

\subsection{Metode}

Metodele clasei \str{} și \listtype, care primesc parametri de tipul \regex{}:
\begin{icItems}
\item
\mintinline{icl}{string.count (re : regex) : int};
\item
\mintinline{icl}{string.indexOf (re : regex, startPos = -1) : int};
\item
\mintinline{icl}{string.lastIndexOf (re : regex, startPos = -1) : int};
\item
\mintinline{icl}{string.remove (re : regex) : string};
\item 
\mintinline{icl}{string.replace (re : regex, after : string) : string};
\item
\mintinline{icl}{string.split (re : regex, keepEmptyParts = true) : list}.
\item
\mintinline{icl}{list.filter (re : regex) : list};
\item
\mintinline{icl}{list.indexOf (re : regex, start : int) : int};
\item
\mintinline{icl}{list.lastIndexOf (re : regex, start : int) : int};
\end{icItems}

Exemple de folosire a metodelor enumerate mai sus sunt prezente pe foaia \ref{regexplikearg}.

\begin{sourcecode}
    \captionof{listing}{Expresii regulare în calitate de argumente}
    \label{regexplikearg}
    \inputminted[linenos]{icl}{../sources/regexplikearg.icL}
\end{sourcecode}

\subsubsection{\mintinline{icl}{string.count (re : regex) : int}}

Numără cîte subșiruri convin expresii regulare \mintinline{icl}{re}.

\subsubsection{\mintinline{icl}{string.indexOf (re : regex, startPos = -1) : int}}

Returnează indexul primului subșir care convine expresii regulare \mintinline{icl}{re}, căutînd înainte de pe poziția code{startPos}. Dacă așa subșir nu a fost găsit, returnează -1.

\subsubsection{\mintinline{icl}{string.lastIndexOf (re : regex, startPos = -1) : int}}

Returnează primului subșir care convine expresii regulare \mintinline{icl}{re}, căutînd înapoi de pe poziția \mintinline{icl}{startPos}; dacă așa subșir nu a fost găsit, returnează -1.

\subsubsection{\mintinline{icl}{string.remove (re : regex) : string}}

Șterge din șir toate subșirurile care convin expresii regulare \mintinline{icl}{re}.

\subsubsection{\mintinline{icl}{string.replace (re : regex, after : string) : string}}

Înlocuiește subșirurile care convin expresii regulare \mintinline{icl}{re}, cu șirul \mintinline{icl}{after}.

\subsubsection{\mintinline{icl}{string.split (re : regex, keepEmptyParts = true) : list}}

Împarte șirul în subșiruri, la fiecare găsire a subșirului care convine expresii regulare \mintinline{icl}{re} și strînge subșirurile în listă. Dacă \mintinline{icl}{keepEmptyParts == false} șirurile deșarte se ignoră.

\subsubsection{\mintinline{icl}{list.filter (re : regex) : list}}

Returnează o listă nouă, care conține doar șirurile acestei liste, care convin expresii regulare \mintinline{icl}{re}.

\subsubsection{\mintinline{icl}{list.indexOf (re : regex, start = 0) : int}}

Returnează indexul primului șir, care convine expresii regulare \mintinline{icl}{re}, căutînd înainte de pe poziția \mintinline{icl}{start}, dacă așa șir nu a fost găsit returnează -1.

\subsubsection{\mintinline{icl}{list.lastIndexOf (re : regex, start = -1) : int}}

Returnează indexul primului șir, care convine expresii regulare \mintinline{icl}{re}, căutînd înapoi de pe poziția \mintinline{icl}{start}, dacă așa șir nu a fost găsit returnează -1.

% \subsubsection{}

%\newpage
