% !TeX spellcheck = ro_RO
\section{Expresii regulare}
\label{regex}

Pentru definirea {\bf expresiilor regulare} se folosește literalul \lstinline|//pattern//mods|, unde \code{pattern} este paternul expresii, \code{mods} sunt modificatorii. În patern grupele pot avea nume, gupa anonimă are următoarea sintaxă \lstinline|(content)|, grupa cu nume - \lstinline|(?<name>content)|.

Simbolul intern poate fi nu numai \code{/}, dar și oricare alt simbol, în afară de apostrof (\lstinline|'|) el intră în conflict cu operatorul {\it rădăcină} (\lstinline|/'|), \lstinline|@|, \lstinline|#|, \lstinline|-|, \lstinline|+| și \lstinline|!|. De exemplu  \lstinline|/"pattern"/mods|, \lstinline|/:pattern:/mods|, \lstinline|/$pattern$/mods|.

Ca să capturezi începutul șirului de caractere se poate de folosit \lstinline|^| și \lstinline|\A|, dar pentru sfîrșit - \lstinline|$| și \lstinline|\z|. Primul variant necătînd la popularitatea lui poate funcționa incorect, pentru ca ele capturează începutul și sfîrșitul liniilor în context de text în mai multe linii.

\subsection{Modificatori}

În limbajul icL sunt prezenți următorii modificatori: \code{/i}, \code{/s}, \code{/m}, \code{/x}, \code{/u} и \code{/f}. Modificatorii pot fi combinați, de exemplu \code{/xi}.

\subsubsection{Modificator \code{/i}}

Diferența între majuscule și minuscule va fi ignorată. 

\subsubsection{Modificator \code{/s}}

Punctul va însemna orice simbol, inclusiv și simbolul {\it rînd nou}.

\subsubsection{Modificator \code{/m}}

Meta-simbolurile \lstinline|^| și \lstinline|$| vor captura nu numai începutul și sfîrșitul șirului, dar și al liniilor de text.

\subsubsection{Modificator \code{/x}}

Toate spațiile vor fi ignorate, simbolul \lstinline|#| va însemna începutul comentariului, care se termină cu simbolul {\it rînd nou}.

\subsubsection{Modificator \code{/u}}

Clasele de simboluri \lstinline|\w|, \lstinline|\d| ș.a.m.d. și inversiile lor \lstinline|\W|, \lstinline|\D| ș.a.m.d. vor captura nu numai literele latine, dar și literele alfabetelor naționale.

\subsubsection{Modificator \code{/f}}

Se inventează zgîrcirea cuantificatorilor \lstinline|*|, \lstinline|+|, \lstinline|?| ș.a.m.d. și ei devin leneși. Dar versiunile lor leneșe \lstinline|*?|, \lstinline|+?|, \lstinline|??| ș.a.m.d. devin zgîrite.

{\bf Cuantificatorul zgîrgit} capturează cantitatea maximă de simboluri, dar {\bf cuantificatorul leneș} - minimală.

\subsection{Операторы}

Для регулярных выражений доступны следующие операторы:
\begin{icItems}
\item
	3-ого ранга:
	\begin{icItems}
	\item
		\lstinline|string << regex : bool|;
	\item
		\lstinline|string <* regex : list|.
	\end{icItems}

\item 
	6$^+$-ого ранга: \lstinline|string ** regex : object|.
\end{icItems}

Примеры использования операторов приведены на листинге \ref{regexpopsex}.

\begin{lstlisting}[caption=Операторы регулярных выражений, label=regexpopsex]
"string" << //s.r//;            `` true
"string" <* //s(.)r//;          `` ["str" "t"]
"string" ** //s(?<letter>.)r//; `` [<"t">letter]
\end{lstlisting}

\subsubsection{\lstinline|string << regex : bool|}

Возвращает \true{}, если строка содержит подстроку подходящая по шаблону регулярней выражений, иначе \false{}.

\subsubsection{\lstinline|string <* regex : list|}

Возвращает список захваченных подстрок если строка содержит подстроку подходящая по шаблону регулярней выражений, иначе пустой список.

\subsubsection{\lstinline|string ** regex : object|}

Возвращает объект, содержащий значения всех именованных групп, если строка содержит подстроку подходящая по шаблону регулярней выражений и объявлены именованные группы, иначе пустой объект.

% \subsubsection{}

\subsection{Методы}

Методы классы \str{} и \listtype, имеющие параметры типа \regex{}:
\begin{icItems}
\item
	\lstinline|string.count <regex>re : int|;
\item
	\lstinline|string.indexOf <regex>re <int>startPos = -1 : int|;
\item
	\lstinline|string.lastIndexOf <regex>re <int>startPos = -1 : int|;
\item
	\lstinline|string.remove <regex>re : string|;
\item 
	\lstinline|string.replace <regex>re <string>after : string|;
\item
	\lstinline|string.split <regex>re <bool>keepEmptyParts = true : list|.
\item
	\lstinline|list.filter <regex>re : list|;
\item
	\lstinline|list.indexOf <regex>re <int>start : int|;
\item
	\lstinline|list.lastIndexOf <regex>re <int>start : int|;
\end{icItems}

Примеры использования выше перечисленных методов, представлены на листинге \ref{regexplikearg}.

\subsubsection{\lstinline|string.count <regex>re : int|}

Считает количество подстрок подходящие по шаблону \code{re}.

\subsubsection{\lstinline|string.indexOf <regex>re <int>startPos = -1 : int|}

Возвращает индекс первой подстроки подходящей по шаблону \code{re}, ища вперёд с позицией \code{startPos}; если такая подстрока не нашлось, возвращает -1.

\begin{lstlisting}[caption=Регулярные выражения в качестве аргумента, label=regexplikearg]
@str = "Hello world, collaborators!";

@str.count //\wo//;       `` 5
@str.indexOf //\w{6}//;   `` 13
@str.lastIndexOf //l+o//; `` 2
@str.remove //\w{2}o//;   `` "He world, collrrs!"
@str.split //,?\s//;      `` ["He" "world" "collrrs!"]

@fonts = ["Arial" "Helvetica" "Times" "Courier"];

@fonts.filter //^[ac]//i;    `` ["Arial" "Courier"]
@fonts.indexOf //e.//;       `` 1
@fonts.indexOf //e.// 2;     `` 2
@fonts.lastIndexOf //e.//;   `` 3
@fonts.lastIndexOf //e.// 2; `` 2
\end{lstlisting}

\subsubsection{\lstinline|string.lastIndexOf <regex>re <int>startPos = -1 : int|}

Возвращает индекс первой подстроки подходящей по шаблону \code{re}, ища назад с позицией \code{startPos}; если такая подстрока не нашлось, возвращает -1.

\subsubsection{\lstinline|string.remove <regex>re : string|}

Удаляет из строки все фрагменты подходящие по шаблону \code{re}.

\subsubsection{\lstinline|string.replace <regex>re <string>after : string|}

Заменяет каждый фрагмент, подходящий по шаблону \code{re}, строкой \code{after}.

\subsubsection{\lstinline|string.split <regex>re <bool>keepEmptyParts = true : list|}

Разрывает строку на подстроки при каждой встречи подстроки, подходящей по шаблону \code{re} и собирает список этих строк; если \code{keepEmptyParts == false} то пустые строки пропускаются.

\subsubsection{\lstinline|list.filter <regex>re : list|}

Возвращает новый список строк, содержащий только строки этого списка, подходящих по регулярней выражении \code{re}.

\subsubsection{\lstinline|list.indexOf <regex>re <int>start = 0 : int|}

Возвращает индекс первой строки, подходящей по регулярней выражении \code{re}, ища вперёд с позицией \code{start}, если такой строке не найдено возвращает -1.

\subsubsection{\lstinline|list.lastIndexOf <regex>re <int>start = -1 : int|}

Возвращает индекс первой строки, подходящей по регулярней выражении \code{re}, ища назад с позицией \code{start}, если такой строке не найдено возвращает -1.

% \subsubsection{}

%\newpage
