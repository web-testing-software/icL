\section{Множества}

{\bf Множества} (тип \set) позволяют хранить несколько объектов (тип \object) без повторений, для множеств доступны операции как пересечение, объединение.

\subsection{{\color{lightblue} object}}

Объект позволяет хранить несколько переменных, каждая хранимая переменная имеет тип и название. Доступ к переменным осуществляется через свойства объекта, где название свойств и есть название переменных.

Поле объектов множества описаны в заголовке множества.

\subsection{Свойства}

Множества имеют следующие свойства:
\begin{icItems}
\item \lstinline|[r/o] set'capacity : int|;
\item \lstinline|[r/o] set'empty : bool|;
\end{icItems}

\subsubsection{\lstinline|[r/o] set'capacity : int|}

Возвращает количество объектов которых можно хранить в память без дополнительных выделений.

\subsubsection{\lstinline|[r/o] set'empty : bool|}

Множество считается пустой если оно не содержит ни один объект.

\subsection{Методы}

Множество имеет следующие методы:
\begin{icItems}
\item \lstinline|set.applicate (<list ...>data) : set|;
\item \lstinline|set.clear () : set|;
\item \lstinline|set.getField (name : string) : list|;
\item \lstinline|set.hasField (name : string) : bool|;
\item \lstinline|set.insert (<any ...>data) : set|;
\item \lstinline|set.insert (obj : object) : set|;
\item \lstinline|set.insertBoolField (name : string, values : list) : set|;
\item \lstinline|set.insertDoubleField (name : string, values : list) : set|;
\item \lstinline|set.insertIntField (name : string, values : list) : set|;
\item \lstinline|set.insertListField (name : string, value : list) : set|;
\item \lstinline|set.insertStringField (name : string, values : list) : set|;
\item \lstinline|set.remove (<any ...>data) : set|;
\item \lstinline|set.remove (obj : object) : set|;
\item \lstinline|set.removeField (name : string) : set|.
\end{icItems}

Код использующий выше перечисленных методов представлен на листинге \ref{setmethods};

\begin{lstlisting}[caption=Методы класса set, label=setmethods]
@set = [age : int, name : string, sex : string,]

@set.applicate 
	["23"    "45"     "67"]
	["Basil" "Nataly" "Siri"]
	["m"     "f"      "f"];
``` set = [
    [age = 23, name = "Basil",  sex = "m"]
	[age = 45, name = "Nataly", sex = "f"]
	[age = 67, name = "Siri",   sex = "f"]
	] ```

@set.getField "name"; `` ["Basil" "Nataly" "Siri"]

@set.insert 34 "Critiano" "m";
``` set = [
    [age = 23, name = "Basil",     sex = "m"]
	[age = 45, name = "Nataly",    sex = "f"]
	[age = 67, name = "Siri",      sex = "f"]
	[age = 34, name = "Cristiano", sex = "m"]
	] ```

@set.insert [sex = "f", name = "Sofia", age = 19];
``` set = [
    [age = 23, name = "Basil",    sex = "m"]
	[age = 45, name = "Nataly",   sex = "f"]
	[age = 67, name = "Siri",     sex = "f"]
	[age = 34, name = "Cristiano" sex = "m"]
	[age = 19, name = "Sofia",    sex = "f"]
	] ```

@set.insertStringField "parity" ["odd" "even"];
``` set = [
    [age = 23, name = "Basil",    sex = "m", parity = "odd"]
	[age = 45, name = "Nataly",   sex = "f", parity = "even"]
	[age = 67, name = "Siri",     sex = "f", parity = "odd"]
	[age = 34, name = "Cristiano" sex = "m", parity = "even"]
	[age = 19, name = "Sofia",    sex = "f", parity = "odd"]
	] ```

@set.remove 45 "Nataly" "f" "even";
``` set = [
    [age = 23, name = "Basil",    sex = "m", parity = "odd"]
	[age = 67, name = "Siri",     sex = "f", parity = "odd"]
	[age = 34, name = "Cristiano" sex = "m", parity = "even"]
	[age = 19, name = "Sofia",    sex = "f", parity = "odd"]
	] ```

@set.remove [age = 34, sex = "Cristiano"name <"m", parity = "even"];
``` set = [
    [age = 23, name = "Basil", sex = "m", parity = "odd"]
	[age = 67, name = "Siri",  sex = "f", parity = "odd"]
	[age = 19, name = "Sofia", sex = "f", parity = "odd"]
	] ```

@set.removeField "parity";
``` set = [
    [age = 23, name = "Basil", sex = "m"]
	[age = 67, name = "Siri",  sex = "f"]
	[age = 19, name = "Sofia", sex = "f"]
	] ```

@set.clear; `` set = []
\end{lstlisting}

\subsubsection{\lstinline|set.applicate (<list ...>data) : set|}

Количество полученных списков должна быть равна количеству полей объектов множества. Количество добавленных объектов будет ровна длине самого длинного списка из \code{data}. Из списков в которых не хватает строк, элементы будут добавлены повторно.

Возможные исключения: \ferror{IncompatibleData}.

\subsubsection{\lstinline|set.clear () : set|}

Очищает множество.

\subsubsection{\lstinline|set.getField (name : string) : list|}

Возвращает список значений поле \code{name} всех объектов.

Возможные исключения: \ferror{FieldNotFound}.

\subsubsection{\lstinline|set.hasField (name : string) : bool|}

Возвращает \true, если заголовок содержит поле \code{name}, иначе \false.

\subsubsection{\lstinline|set.insert (<any ...>data) : set|}

Вставит новый объект, значения полей (массив \code{data}) должна полностью соблюдать порядок и тип данных, определён заголовком множество.

Возможные исключения: \ferror{IncompatibleData}.

\subsubsection{\lstinline|set.insert (obj : object) : set|}

Вставит новый объект, поля объекта \code{obj} должна быть совместимы полностью с заголовком множество.

Возможные исключения: \ferror{IncompatibleObject}.

\subsubsection{\lstinline|set.insertBoolField (name : string, values : list) : set|}

Создаёт новое поле типа \bool. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertDoubleField (name : string, values : list) : set|}

Создаёт новое поле типа \double. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertIntField (name : string, values : list) : set|}

Создаёт новое поле типа \integer. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertListField (name : string, value : list) : set|}

Создаёт новое поле типа \bool. Все объекты множеству получат новое поле со значением \code{value}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.insertStringField (name : string, values : list) : set|}

Создаёт новое поле типа \str. \code{values} может быть пустым списком только если множество пустая. Значений массива распределяется так же как и при использовании \code{set.applicate}.

Возможные исключения: \ferror{FieldAlreadyExists}.

\subsubsection{\lstinline|set.remove (<any ...>data) : set|}

Удаляет объект, который подходит по описанию \code{data}.

\subsubsection{\lstinline|set.remove (obj : object) : set|}

Удаляет объект \code{obj} из множества.

\subsubsection{\lstinline|set.removeField (name : string) : set|}

Удаляет поле \code{name} с заголовка.

Возможные исключения: \ferror{FieldNotFound}.

%\newpage
