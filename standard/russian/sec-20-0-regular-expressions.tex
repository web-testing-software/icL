% !TeX spellcheck = ru_RU
\section{Регулярные выражения}
\label{regex}

Для объявления {\bf регулярных выражения} используется литерал \mintinline{icl}{//pattern//ms}, где \mintinline{icl}{pattern} — шаблон регулярней выражений, \mintinline{icl}{ms} — модификаторы. В шаблоне группы можно наименовать, анонимная группа имеет следующий синтаксис \mintinline{icl}{(content)}, именованная группа — \mintinline{icl}{(?<name>content)}.

Внутренний символ может быть не только \mintinline{icl}{/}, но и любой другой на свой вкус, кроме апострофа (\mintinline{icl}{'}) он конфликтует с оператором {\it корень} (\mintinline{icl}{/'}), \mintinline{icl}{@}, \mintinline{icl}{#}, \mintinline{icl}{-}, \mintinline{icl}{+} и \mintinline{icl}{!}. Например  \mintinline{icl}{/"pattern"/mods}, \mintinline{icl}{/:pattern:/mods}, \mintinline{icl}{/$pattern$/mods}.

Для того чтобы захватить начало строки можно использовать \mintinline{icl}{^} и \mintinline{icl}{\A}, а для конца строки - \mintinline{icl}{$} и \mintinline{icl}{\z}. Первый вариант несмотря на его популярность может срабатывать неправильно, так как им захватывается начало и конец строки в контексте многострочного текста.

\subsection{Модификаторы}

В языке icL присутствуют следующее модификаторы: \mintinline{icl}{/i}, \mintinline{icl}{/s}, \mintinline{icl}{/m}, \mintinline{icl}{/x}, \mintinline{icl}{/u} и \mintinline{icl}{/f}. Модификаторы можно скомбинировать, например \mintinline{icl}{/xi}.

\subsubsection{Модификатор \mintinline{icl}{/i}}

Регистр букв будет проигнорирован. 

\subsubsection{Модификатор \mintinline{icl}{/s}}

Точка будет означать любой символ, включая символа {\it новая строка}.

\subsubsection{Модификатор \mintinline{icl}{/m}}

Метасимволы \mintinline{icl}{^} и \mintinline{icl}{$} будут означать начало и конец строки не только в общем смысле, но и в контексте многострочного текста.

\subsubsection{Модификатор \mintinline{icl}{/x}}

Все пробельные символы будут проигнорированы, и символ \mintinline{icl}{#} будет означать начало комментария, который заканчивается символом {\it новая строка}.

\subsubsection{Модификатор \mintinline{icl}{/u}}

Классы символов \mintinline{icl}{\w}, \mintinline{icl}{\d} и т.д. и их отрицаний \mintinline{icl}{\W}, \mintinline{icl}{\D} и т.д. будут соответствовать не только английских символов, но и национальных.

\subsubsection{Модификатор \mintinline{icl}{/f}}

Инвертирует жадность квантификаторов \mintinline{icl}{*}, \mintinline{icl}{+}, \mintinline{icl}{?} и т.д. и они становятся ленивыми. А их ленивые версии \mintinline{icl}{*?}, \mintinline{icl}{+?}, \mintinline{icl}{??} и т.д. становятся жадными.

{\bf Жадный квантификатор} захватывает максимальное количество символов. {\bf Ленивый квантификатор} - минимальное.

\subsection{Операторы}

Для регулярных выражений доступны следующие операторы:
\begin{icItems}
\item
	3-ого ранга:
	\begin{icItems}
	\item
		\mintinline{icl}{string << regex : bool};
	\item
		\mintinline{icl}{string <* regex : list}.
	\end{icItems}

\item 
	6$^+$-ого ранга: \mintinline{icl}{string ** regex : object}.
\end{icItems}

Примеры использования операторов приведены на листинге \ref{regexpopsex}.

\begin{sourcecode}
	\captionof{listing}{Операторы регулярных выражений}
	\label{regexpopsex}
    \inputminted[linenos]{icl}{../sources/regexpopsex.icL}
\end{sourcecode}

\subsubsection{\mintinline{icl}{string << regex : bool}}

Возвращает \true{}, если строка содержит подстроку подходящая по шаблону регулярней выражений, иначе \false{}.

\subsubsection{\mintinline{icl}{string <* regex : list}}

Возвращает список захваченных подстрок если строка содержит подстроку подходящая по шаблону регулярней выражений, иначе пустой список.

\subsubsection{\mintinline{icl}{string ** regex : object}}

Возвращает объект, содержащий значения всех именованных групп, если строка содержит подстроку подходящая по шаблону регулярней выражений и объявлены именованные группы, иначе пустой объект.

% \subsubsection{}

\subsection{Методы}

Методы классы \str{} и \listtype, имеющие параметры типа \regex{}:
\begin{icItems}
\item
	\mintinline{icl}{string.count (re : regex) : int};
\item
	\mintinline{icl}{string.indexOf (re : regex, startPos = -1) : int};
\item
	\mintinline{icl}{string.lastIndexOf (re : regex, startPos = -1) : int};
\item
	\mintinline{icl}{string.remove (re : regex) : string};
\item 
	\mintinline{icl}{string.replace (re : regex, after : string) : string};
\item
	\mintinline{icl}{string.split (re : regex, keepEmptyParts = true) : list}.
\item
	\mintinline{icl}{list.filter (re : regex) : list};
\item
	\mintinline{icl}{list.indexOf (re : regex, start : int) : int};
\item
	\mintinline{icl}{list.lastIndexOf (re : regex, start : int) : int};
\end{icItems}

Примеры использования выше перечисленных методов, представлены на листинге \ref{regexplikearg}.

\subsubsection{\mintinline{icl}{string.count (re : regex) : int}}

Считает количество подстрок подходящие по шаблону \mintinline{icl}{re}.

\subsubsection{\mintinline{icl}{string.indexOf (re : regex, startPos = -1) : int}}

Возвращает индекс первой подстроки подходящей по шаблону \mintinline{icl}{re}, ища вперёд с позицией \mintinline{icl}{startPos}; если такая подстрока не нашлось, возвращает -1.

\begin{sourcecode}
	\captionof{listing}{Регулярные выражения в качестве аргумента}
	\label{regexplikearg}
    \inputminted[linenos]{icl}{../sources/regexplikearg.icL}
\end{sourcecode}

\subsubsection{\mintinline{icl}{string.lastIndexOf (re : regex, startPos = -1) : int}}

Возвращает индекс первой подстроки подходящей по шаблону \mintinline{icl}{re}, ища назад с позицией \mintinline{icl}{startPos}; если такая подстрока не нашлось, возвращает -1.

\subsubsection{\mintinline{icl}{string.remove (re : regex) : string}}

Удаляет из строки все фрагменты подходящие по шаблону \mintinline{icl}{re}.

\subsubsection{\mintinline{icl}{string.replace (re : regex, after : string) : string}}

Заменяет каждый фрагмент, подходящий по шаблону \mintinline{icl}{re}, строкой \mintinline{icl}{after}.

\subsubsection{\mintinline{icl}{string.split (re : regex, keepEmptyParts = true) : list}}

Разрывает строку на подстроки при каждой встречи подстроки, подходящей по шаблону \mintinline{icl}{re} и собирает список этих строк; если \mintinline{icl}{keepEmptyParts == false} то пустые строки пропускаются.

\subsubsection{\mintinline{icl}{list.filter (re : regex) : list}}

Возвращает новый список строк, содержащий только строки этого списка, подходящих по регулярней выражении \mintinline{icl}{re}.

\subsubsection{\mintinline{icl}{list.indexOf (re : regex, start = 0) : int}}

Возвращает индекс первой строки, подходящей по регулярней выражении \mintinline{icl}{re}, ища вперёд с позицией \mintinline{icl}{start}, если такой строке не найдено возвращает -1.

\subsubsection{\mintinline{icl}{list.lastIndexOf (re : regex, start = -1) : int}}

Возвращает индекс первой строки, подходящей по регулярней выражении \mintinline{icl}{re}, ища назад с позицией \mintinline{icl}{start}, если такой строке не найдено возвращает -1.

% \subsubsection{}

%\newpage
