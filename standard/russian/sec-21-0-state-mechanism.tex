% !TeX spellcheck = ru_RU
\section{Механизм состояний}

Все переменные icL хранятся в контейнерах 2 типов: стек и состояние.

Стек представляет собой стек контейнеров, каждый контейнер строго привязан к фрагменту кода icL, при вводе курсора в область контейнер создаётся, при выходе разрушается.

Состояние представляет собой двусвязный список контейнеров, они не привязываются к коду и доступны глобально. По умолчанию создаётся лишь один контейнер, но новые могут быть созданы пользователем.

\subsection{Управление стеками}

Для управления стеками, используется следующий набор функций и свойств:
\begin{icItems}
	\item \lstinline|[r/o] Stacks'(name : string) : Stack|;
	\item \lstinline|Stacks.root() : Stack|;
	\item \lstinline|Stack.clear () : void|;
	\item \lstinline|Stack.continue () : void|;
	\item \lstinline|Stack.break () : void|;
	\item \lstinline|Stack.return (value : any) : void|.
\end{icItems}

\subsubsection{\lstinline|[r/o] Stacks'(name : string) : Stack|}

Возвращает контейнер имеющий имя \code{name}. Наименование контейнера имеет следующий синтаксис -
\begin{lstlisting}[numbers=none]
{:name
	`` content
}
\end{lstlisting}
Могут быть именованными только блоки команд (код ограничен круглыми скобками). Код ограничен круглыми скобками не может иметь название. Вызов функций создаёт контейнер имеющий название функций.

\subsubsection{\lstinline|Stacks.root() : Stack|}

Возвращает коренной контейнер. В функциях это контейнер функций.

\subsubsection{\lstinline|Stack'(name : string) : any|}

Возвращает переменную, находящаяся именно в этом контейнере. Например: уже существует переменная \code{i} в родительском контейнере, нужно определить переменная с таким же именем в текущем контексте. Проблема решается следующим образом: \lstinline|Stack'i = 0| вместо \lstinline|@i = 0|.

\subsubsection{\lstinline|Stack.clear () : void|}

Удаляет все переменные, которые хранится в контейнере.

\subsubsection{\lstinline|Stack.continue () : void|}

Переход на следующую итерацию, доступно только для циклов.

Возможные исключения: \ferror{InvalidArgument}.

\subsubsection{\lstinline|Stack.break () : void|}

Прекращает немедленно работу цикла. Доступно только для циклов.

Возможные исключения: \ferror{InvalidArgument}.

\subsubsection{\lstinline|Stack.return (value : any) : void|}

Возвращает результат выполнения функции во внешней среды.

Возможные исключения: \ferror{InvalidArgument}.

\subsection{Управление состояниями}

Для управления состояниями, используется следующий набор функций и свойств:
\begin{icItems}
	\item \lstinline|States'first : object|;
	\item \lstinline|States'prev : object|;
	\item \lstinline|States'next : object|;
	\item \lstinline|States'last : object|;
	\item \lstinline|States.new () : void|;
	\item \lstinline|States.newAtEnd () : void|;
	\item \lstinline|States.toNext () : void|;
	\item \lstinline|States.toPrev () : void|;
	\item \lstinline|States.clear () : void|;
	\item \lstinline|States.delete () : void|;
	\item \lstinline|States.toFirst () : void|;
	\item \lstinline|States.toLast () : void|.
\end{icItems}

Объект \lstinline|States| является коллекцией, а значит её можно посматривать через \lstinline|for (States) {}|. Поддержка других циклов не предусматриваться.

\subsubsection{\lstinline|States'first : object|}

Возвращает первое состояние в виде объекта.

\subsubsection{\lstinline|States'prev : object|}

Возвращает предыдущее состояние в виде объекта.

\subsubsection{\lstinline|States'next : object|}

Возвращает следующее состояние в виде объекта.

\subsubsection{\lstinline|States'last : object|}

Возвращает последнее состояние в виде объекта.

\subsubsection{\lstinline|States.new (data = [=]) : void|}

Создаёт новое состояние после текущей и переключает фокус на ней. Все данные объекта \code{data} добавляются в новом контейнере.

\subsubsection{\lstinline|States.newAtEnd (data = [=]) : void|}

Создаёт новое состояние в конце, не переключает фокус на ней. Все данные объекта \code{data} добавляются в новом контейнере.

\subsubsection{\lstinline|States.toNext () : bool|}

Возвращает \true, если существует следующее состояние и фокус был перемещён на неё, иначе \false.

\subsubsection{\lstinline|States.toPrev () : bool|}

Возвращает \true, если существует предыдущее состояние и фокус был перемещён на неё, иначе \false.

\subsubsection{\lstinline|States.clear () : void|}

Удаляет все переменные, которые хранится в контейнере.

\subsubsection{\lstinline|States.delete () : void|}

Удаляет состояние, если существует следующее то фокус переходит на ней, иначе если существует предыдущее то фокус переходит на ней, в противном случае текущее состояние - последняя и она не удаляется, а только очищается.

\subsubsection{\lstinline|States.toFirst () : void|}

Переходит на первое состояние.

\subsubsection{\lstinline|States.toLast () : void|}

Переходит на последнее состояние.

\subsubsection{\lstinline|for (States) \{\}|}

Выполняет тело цикла для каждой состояний.

%\newpage
