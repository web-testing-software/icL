% !TeX spellcheck = ru_RU
\section{Операторы}

{\bf Оператор} - это токен, который предписывает выполнение определённой манипуляции данных. Встроенных операторов в icL очень много, по этому будет их разбирать по типу данных.

{\bf Порядок выполнения операторов} определяет ранг, операторы имеющие наивысший ранг выполняются первыми, а имеющие наименьший ранг - последними. Операторы имеющие правая ассоциативность выполняются раньше чем операторы имеющие левое ассоциативность, они отмечены плюсом справа от ранга, например 7$^+$.

{\bf Оператор пристраивания} имеет ранг 0 и правая ассоциативность.

{\bf Квадратные скобки} в языке icL, также являются операторами, имеющие ранг 1 и левая ассоциативность.

При описании операторов используется понятие {\bf операции} и понятие {\bf оператора}. Под операций подразумевается общий случай (например {\it сложение}). Под оператором подразумевается частный случай (например {\it сложение целых чисел}). Оператор становится операцией при первой возможность его реализаций, например в выражения \lstinline|1 + 2 * 3|, оператор \lstinline|+| становится операцией только после выполнения операций умножения.

\subsection{Логические операций}

Если у вас отсутствуют знания по алгебре логике, пожалуйста прочтите любую книгу по основам данной науке. Логические операции перечислены в таблице \ref{logicops}.

\stablethree{1.0cm}{5.0cm}{5.0cm}
{logicops}{Логические операций}
{Ранг}{Операция}{Оператор}
{
    2     & конъюнкция      & \lstinline|bool \& bool : bool| \\ \hline
	2     & дизъюнкция      & \lstinline`bool | bool : bool`  \\ \hline
	2     & эквивалентность & \lstinline|bool ~ bool : bool|  \\ \hline
	2     & исключающий или & \lstinline|bool ^ bool : bool|  \\ \hline
	7$^+$ & инверсия        & \lstinline|! bool : bool|       \\ \hline
	3     & равно           & \lstinline|bool == bool : bool| \\ \hline
	3     & не равно        & \lstinline|bool != bool : bool| \\
}

Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{boolopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа bool, label=boolopex]
Log.out "true & false = " (true & false);		`` true \& false = false
Log.out "false | true =  " (false | true);		`` false | true = true
Log.out "true ~ false = " (true ~ false);		`` true \textasciitilde\ false = false
Log.out "false ^ true = " (false ^ true);		`` false \textasciicircum\ true = true`

Log.out "!true = " !true;						`` !true = false
Log.out "!false = " !false;					`` !false = true

Log.out "true == false = " (true == false);	`` true == false = false
Log.out "false != true = " (false != true);	`` false != true = true
\end{lstlisting}

\subsubsection{\lstinline|(a : bool) & (b : bool) : bool|}

Оператор принимает логическую операцию "конъюнкция" над переменными a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{conjtable}.

\begin{table}[htb]
	\caption{Таблица истинности конъюнкции}
	\label{conjtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \& b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline`(a : bool) | (b : bool) : bool`}

Оператор принимает логическую операцию "дизъюнкция" над переменными a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{distable}.

\begin{table}[htb]
	\caption{Таблица истинности дизъюнкции}
	\label{distable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \| b} 	\\ \hline
		\false{} & \false{} & \false{} 		\\ \hline
		\false{} & \true{}  & \true{}  		\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \true{}  		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|(a : bool) ~ (b : bool) : bool|}

Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logeqtable}.

\begin{table}[htb]
	\caption{Таблица истинности эквивалентности}
	\label{logeqtable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \~ b} \\ \hline
		\false{} & \false{} & \true{}   	\\ \hline
		\false{} & \true{}  & \false{}  	\\ \hline
		\true{}  & \false{} & \false{}  	\\ \hline
		\true{}  & \true{}  & \true{}   	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline|(a : bool) ^ (b : bool) : bool|}

Оператор сравнивает логические переменные a и b. Зависимость результата от исходных данных иллюстрирована в таблице \ref{logdifftable}.

\begin{table}[htb]
	\caption{Таблица истинности исключающего или}
	\label{logdifftable}
	\begin{tabular}{|c|c|c|}
		\hline
		\code{a} & \code{b} & \code{a \^ b} \\ \hline
		\false{} & \false{} & \false{}  	\\ \hline
		\false{} & \true{}  & \true{}   	\\ \hline
		\true{}  & \false{} & \true{}  		\\ \hline
		\true{}  & \true{}  & \false{}  	\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|! (a : bool) : bool|}

Оператор принимает логическую операцию "инверсия" над переменной a. Зависимость результата от исходных данных иллюстрирована в таблице \ref{invtable}.

\begin{table}[htb]
	\caption{Таблица истинности инверсии}
	\label{invtable}
	\begin{tabular}{|c|c|}
		\hline
		\code{a} & \code{!a} \\ \hline
		\false{} & \true{} 	 \\ \hline
		\true{}  & \false{}  \\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|(a : bool) == (b : bool) : bool|}

Возвращает \true{} если a равно b, иначе \false{}.

\subsubsection{\lstinline|(a : bool) != (b : bool) : bool|}

Возвращает \true{} если a равно b, иначе \false{}.

\subsection{Операции над числами}

Доступные операции над числами перечислены в таблице \ref{numbersops}.

\stablethree{1.0cm}{7.0cm}{6.0cm}
{numbersops}{Операции над числами}
{Ранг}{Операция}{Оператор}
{
3     & равно                          & \lstinline|int == int : bool|          \\ \hline
3     & равно                          & \lstinline|double == double : bool|    \\ \hline
3     & не равно                       & \lstinline|int != int : bool|          \\ \hline
3     & не равно                       & \lstinline|double != double : bool|    \\ \hline
3     & больше                         & \lstinline|int > int : bool|           \\ \hline
3     & больше                         & \lstinline|double > double : bool|     \\ \hline
3     & больше или равно               & \lstinline|int >= int : bool|          \\ \hline
3     & больше или равно               & \lstinline|double >= double : bool|    \\ \hline
3     & меньше                         & \lstinline|int < int : bool|           \\ \hline
3     & меньше                         & \lstinline|double < double : bool|     \\ \hline
3     & меньше или равно               & \lstinline|int <= int : bool|          \\ \hline
3     & меньше или равно               & \lstinline|double <= double : bool|    \\ \hline
3     & меньше или больше              & \lstinline|int <> (int, int)|          \\ \hline
3     & меньше или больше              & \lstinline|double <> (double, double)| \\ \hline
3     & больше и меньше                & \lstinline|int >< (int, int)|          \\ \hline
3     & больше и меньше                & \lstinline|double >< (double, double)| \\ \hline
4     & сложение                       & \lstinline|int + int : int|            \\ \hline
4     & сложение                       & \lstinline|double + double : double|   \\ \hline
4     & вычитание                      & \lstinline|int - int : int|            \\ \hline
4     & вычитание                      & \lstinline|double - double : double|   \\ \hline
5     & умножение                      & \lstinline|int * int : int|            \\ \hline
5     & умножение                      & \lstinline|double * double : double|   \\ \hline
5     & деление                        & \lstinline|int / int : int|            \\ \hline
5     & деление                        & \lstinline|double / double : double|   \\ \hline
5     & остаток от деления целых чисел & \lstinline|int \ int : int|            \\ \hline
6$^+$ & возведения в квадрат           & \lstinline|int** : int|                \\ \hline
6$^+$ & возведения в квадрат           & \lstinline|double** : double|          \\ \hline
6$^+$ & возведения в степень           & \lstinline|int ** int : int|           \\ \hline
6$^+$ & возведения в степень           & \lstinline|double ** double : double|  \\ \hline
6$^+$ & извлечения квадратного корня   & \lstinline|/'int : int|                \\ \hline
6$^+$ & извлечения квадратного корня   & \lstinline|/'double : double|          \\ \hline
6$^+$ & извлечения корня               & \lstinline|int/'int : int|             \\ \hline
6$^+$ & извлечения корня               & \lstinline|int/'double : double|       \\ \hline
6$^+$ & извлечения корня               & \lstinline|double/'double : double|    \\ \hline
7$^+$ & инверсия знака                 & \lstinline|-int : int|                 \\ \hline
7$^+$ & инверсия знака                 & \lstinline|-double : double|           \\ \hline
7$^+$ & абсолютное значение            & \lstinline|+int : int|                 \\ \hline
7$^+$ & абсолютное значение            & \lstinline|+double : double|           \\
}

Примеры использования выше перечисленных операторов, продемонстрированы на листинге \ref{numberopex}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа int и double, label=numberopex]
`` 3rd rank
Log.out "2 == 3 = "			2 == 3;		`` 2 = 3 = false
Log.out "2.5 == 2.5 = "		2.5 == 2.5;	`` 2.5 = 2.5 = true
Log.out "1 != 2 = "			1 != 2;		`` 1 $\neq$ 2 = true
Log.out "2.1 != 2.1 = "		2.1 != 2.1;	`` 2.1 $\neq$ 2.1 = false
Log.out "3 > 2 = "			3 > 2;		`` 3 > 2 = true
Log.out "1.1 > 2.1 = "		1.1 > 2.1;	`` 1.1 > 2.1 = false
Log.out "5 >= 2 = "			5 >= 2;		`` 5 $\geq$ 2 = true
Log.out "5.1 >= 2 = "		5.1 >= 2;	`` 5.1 $\geq$ 2 = true
Log.out "3 < 9 = "			3 < 9;		`` 3 < 9 = true
Log.out "6.1 < 6.2 = "		6.1 < 6.2;	`` 6.1 < 6.2 = true
Log.out "4 <= 5 = "			4 <= 5;		`` 4 $\leq$ 5 = true
Log.out "5.6 <= 6.5 = "		5.6 <= 6.5;	`` 5.6 $\leq$ 6.5 = true
Log.out "1 <> (2, 3) = "	1 <> (2,3); `` 1 < 2 | 1 > 3 = true
Log.out "1 >< (2, 3) = "	1 >< (2,3); `` 2 < 1 < 3 = false
`` 4th rank
Log.out "2 + 3 = "			2 + 3;		`` 2 + 3 = 5
Log.out "2.1 + 1.1 = "		2.1 + 1.1;	`` 2.1 + 1.1 = 3.2
Log.out "4 - 5 = "			4 - 5;		`` 4 - 5 = -1
Log.out "4.5 - 3.4 = "		4.5 - 3.4;	`` 4.5 - 3.4 = 1.1
`` 5th rank
Log.out "2 * 3 = "			2 * 3;		`` 2 $\cdot$ 3 = 6
Log.out "2.1 * 5.7 = "		2.1 * 5.7;	`` 2.1 $\cdot$ 5.7 = 11.97
Log.out "5 / 7 = "			5 / 7;		`` 5 $\div$ 7 = 0.7142857142857
Log.out "5.0 / 7.1 = "		5.0 / 7.1;	`` 5.0 $\div$ 7.1 = 0.7042253521126
Log.out "45 \ 8 = "			45 \ 8;		`` 45 \textbackslash 8 = 5
`` 6+th rank
Log.out "25** = "			25**;		`` $25^2$ = 625
Log.out "25.1** = "			25.1**;		`` $25.1^2$ = 630,01
Log.out "34 ** 3 = "		34 ** 3;	`` $34^3$ = 39304
Log.out "2.0 ** 1.5 = "		2.0 ** 1.5;	`` $2.0^{1.5}$ = 2.8284271247461
Log.out "/'25 = "			/'25;		`` $\sqrt{25}$ = 5
Log.out "/'125.7 = "		/'125.7;	`` $\sqrt{125.7}$ = 11.211601134539
Log.out "3/'27 = "			3/'27;		`` $\sqrt[3]{27}$ = 3
Log.out "5.0/'125.5 = "		5.0/'125.5;	`` $\sqrt[5.0]{125.5}$ = 2.6286256727378
`` 7+th rank
Log.out "- 35 = "			- 35;		`` - 35 = -35
Log.out "- -56.7 = "		- -56.7;	`` - -56.7 = 56.7
Log.out "+ -100 = "			+ -100;		`` + -100 = 100
Log.out "+ 89.7 = "			+ 89.7;		`` + 89.7 = 89.7
\end{lstlisting}

\subsubsection{\lstinline|(a : int) == (b : int) : bool|}

Возвращает \true{} если \code{a} и \code{b} имеют одинаковое значение, иначе \false{}.

\subsubsection{\lstinline|(a : double) == (b : double) : bool|}

Возвращает \true{} если \code{a} и \code{b} отличаются довольно мало (например на 10$^{-15}$), иначе \false{}.

\subsubsection{\lstinline|(a : int) != (b : int) : bool|}

Возвращает \true{} если \code{a} и \code{b} не имеют одинаковое значение, иначе \false{}.

\subsubsection{\lstinline|(a : double) != (b : double) : bool|}

Возвращает \true{} если \code{a} и \code{b} отличаются больше чем на уровень погрешности машины, иначе \false{}.

\subsubsection{\lstinline|(a : int) > (b : int) : bool|}

Возвращает \true{} если целое число \code{a} больше \code{b}, иначе \false{}.

\subsubsection{\lstinline|(a : double) > (b : double) : bool|}

Возвращает \true{} если дробное число \code{a} больше \code{b}, иначе \false{}.

\subsubsection{\lstinline|(a : int) >= (b : int) : bool|}

Возвращает \true{} если целое число \code{a} больше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline|(a : double) >= (b : double) : bool|}

Возвращает \true{} если дробное число \code{a} больше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline|(a : int) < (b : int) : bool|}

Возвращает \true{} если целое число \code{a} меньше \code{b}, иначе \false{}.

\subsubsection{\lstinline|(a : double) < (b : double) : bool|}

Возвращает \true{} если дробное число \code{a} меньше \code{b}, иначе \false{}.

\subsubsection{\lstinline|(a : int) <= (b : int) : bool|}

Возвращает \true{} если целое число \code{a} меньше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline|(a : double) <= (b : double) : bool|}

Возвращает \true{} если дробное число \code{a} меньше или равно \code{b}, иначе \false{}.

\subsubsection{\lstinline|(a : int) <> (b : double, c : double) : bool|}

Возвращает \true{} если целое число \code{a} меньше \code{b} или больше \code{c}, иначе \false{}.

\subsubsection{\lstinline|(a : double) <> (b : double, c : doubleuble) : bool|}

Возвращает \true{} если дробное число \code{a} меньше \code{b} или больше \code{c}, иначе \false{}.

\subsubsection{\lstinline|(a : int) >< (b : double, c : double) : bool|}

Возвращает \true{} если целое число \code{a} больше \code{b} и меньше \code{c}, иначе \false{}.

\subsubsection{\lstinline|(a : double) <> (b : double, c : doubleuble) : bool|}

Возвращает \true{} если дробное число \code{a} больше \code{b} и меньше \code{c}, иначе \false{}.


\subsubsection{\lstinline|(a : int) + (b : int) : int|}

Возвращает сумму целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline|(a : double) + (b : double) : double|}

Возвращает сумму дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline|(a : int) - (b : int) : int|}

Возвращает разницу между целыми числами \code{a} и \code{b}.

\subsubsection{\lstinline|(a : double) - (b : double) : double|}

Возвращает разницу между дробными числами \code{a} и \code{b}.

\subsubsection{\lstinline|(a : int) * (b : int) : int|}

Возвращает результат умножения целых чисел \code{a} и \code{b}.

\subsubsection{\lstinline|(a : double) * (b : double) : double|}

Возвращает результат умножения дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline|(a : int) / (b : int) : int|}

Возвращает результат деления целых чисел \code{a} и \code{b}, остаток отбрасывается.

\subsubsection{\lstinline|(a : double) / (b : double) : double|}

Возвращает результат деления дробных чисел \code{a} и \code{b}.

\subsubsection{\lstinline|(a : int) \ (b : int) : int|}

Возвращает результат от деления целых чисел \code{a} и \code{b}.


\subsubsection{\lstinline|(a : int) ** : int|}

Возвращает квадрат целого числа \code{a} (a$^2$);

\subsubsection{\lstinline|(a : double) ** : double|}

Возвращает квадрат дробного числа \code{a} (a$^2$);

\subsubsection{\lstinline|(a : int) ** (b : int) : int|}

Возвращает результат возведения целого числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline|(a : double) ** (b : double) : double|}

Возвращает результат возведения дробного числа \code{a} в степени \code{b} (a$^b$).

\subsubsection{\lstinline|/' (a : int) : int|}

Возвращает корень целого числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline|/' (a : double) : double|}

Возвращает корень дробного числа \code{a} ($\sqrt{a}$).

\subsubsection{\lstinline|(n : int) /' (a : int) : int|}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline|(n : int) /' (a : double) : double|}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).

\subsubsection{\lstinline|(n : double) /' (a : double) : double|}

Возвращает корень \code{n}-ой степени из \code{a} ($\sqrt[n]{a}$).


\subsubsection{\lstinline|- (a : int) : int|}

Возвращает \lstinline|0 - a|;

\subsubsection{\lstinline|- (b : double) : double|}

Возвращает \lstinline|0.0 - a|;

\subsubsection{\lstinline|+ (a : int) : int|}

Возвращает абсолютное значение целого числа \code{a}.

\subsubsection{\lstinline|+ (a : double) : double|}

Возвращает абсолютное значение дробного числа \code{a}.

\subsection{Операций над строками и список строк}

Доступные операции над строками и список строк перечислены в таблице \ref{stringops}.

\stablethree{1.0cm}{6.0cm}{7.0cm}
{stringops}{Операций над строками и списков строк}
{Ранг}{Операция}{Оператор}
{
3     & равно                                    & \lstinline|string == string : bool|   \\ \hline
3     & равно                                    & \lstinline|list == list : bool|       \\ \hline
3     & не равно                                 & \lstinline|string != string : bool|   \\ \hline
3     & не равно                                 & \lstinline|list != list : bool|       \\ \hline
3     & содержит                                 & \lstinline|list << string : bool|     \\ \hline
3     & содержит                                 & \lstinline|string << string : bool|   \\ \hline
3     & не содержит                              & \lstinline|list !< string : bool|     \\ \hline
3     & не содержит                              & \lstinline|string !< string : bool|   \\ \hline
3     & содержит строку подходящая по шаблону    & \lstinline|list <* string : bool|     \\ \hline
3     & не содержит строку подходящая по шаблону & \lstinline|list !* string : bool|     \\ \hline
4     & конкатенация                             & \lstinline|string + string : string|  \\ \hline
4     & вставка                                  & \lstinline|string + list : list|      \\ \hline
4     & вставка                                  & \lstinline|list + string : list|      \\ \hline
4     & вставка                                  & \lstinline|list + list : list|        \\ \hline
5     & шаблонное сравнение                      & \lstinline|string * string : bool|    \\ \hline
5     & шаблонное сравнение                      & \lstinline|list * string : bool|      \\ \hline
5     & шаблонное сравнение                      & \lstinline|list * list : bool|        \\ \hline
6$^+$ & эквивалентность                          & \lstinline|string ** string : double| \\
}

Примеры использование операторов присутствуют на листинге \ref{stringlistopex}.

Чтобы из несколько строк получить список, оператор вставки рекомендуется не использовать, вместо него использовать литерал:
\begin{lstlisting}[numbers=none]
[@str1, @str2, "Const string", func, 37.1 : string, @bool : string, @list.Join]
\end{lstlisting}

\subsubsection{\lstinline|(s1 : string) == (s2 : string) : bool|}

Возвращает \true{} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \false{}.

\subsubsection{\lstinline|(l1 : list) == (l2 : list) : bool|}

Возвращает \true{} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \false{}.

\subsubsection{\lstinline|(s1 : string) != (s2 : string) : bool|}

Возвращает \false{} если \code{s1} и \code{s2} имеют одинаковое количество символов и содержат они и те же символы в один и тот же порядок, иначе \true{}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа string и list, label=stringlistopex]
"String1" == "String2";					 `` false
["a", "b"] == ["a", "b"];				 `` true
["a", "b"] == ["b", "a"];				 `` true
["a", "b"] << "c";						 `` false
"abc" << "c";							 `` true
"ab" + "c";								 `` "abc"
"ab" + ["c"];							 `` ["ac", "c"]
["a", "b"] + "c";						 `` ["a", "b", "c"]
["a", "b"] + ["c", "d"];				 `` ["a", "b", "c", "d"]
"abc" * "*c";							 `` true
["ac", "bc"] * "*c";					 `` true
["ac", "bc"] * "a*";					 `` false
["ad", "ac", "bd", "cc"] * ["*d", "*c"]; `` true
["ad", "ac", "bc", "cd"] * ["*d", "*c"]; `` false
"Tom is a cat" ** "Tom is not a cat";	 `` 0.875
\end{lstlisting}

\subsubsection{\lstinline|(l1 : list) != (l2 : list) : bool|}

Возвращает \false{} если \code{l1} и \code{l2} имеют одинаковое количество строк и содержат они и те же строки (порядок игнорируется), иначе \true{}.

\subsubsection{\lstinline|(l : list) << (str : string) : bool|}

Возвращает \true{}, если список \code{l} содержит строку \code{str}, иначе \false{}.

\subsubsection{\lstinline|(str : string) << (substr : string) : bool|}

Возвращает \true{}, если строка \code{str} содержит подстроку \code{substr}, иначе \false{}.

\subsubsection{\lstinline|(l : list) !< (str : string) : bool|}

Возвращает \true{}, если список \code{l} не содержит строку \code{str}, иначе \false{}.

\subsubsection{\lstinline|(str : string) !< (substr : string) : bool|}

Возвращает \true{}, если строка \code{str} не содержит подстроку \code{substr}, иначе \false{}.

\subsubsection{\lstinline|(l : list) <* (template : string) : bool|}

Возвращает \true{}, если список \code{l} содержит хотя бы одна строка, подходящая по шаблону \code{template}, иначе \false{}.

{\bf Шаблон} - это строка содержащая данные и специальный символ \lstinline|*|, где \lstinline|*| означает любая последовательность символов. Рассмотрим шаблонную строку \lstinline|"Have a * day!"|, примеры строк подходящие по шаблону: \lstinline|"Have a nice day!"|, \lstinline|"Have a amazing day!"|. Пример неподходящей строки \lstinline|"Have a good day"| (отсутствует восклицательный знак).

\subsubsection{\lstinline|(l : list) !* (template : string) : bool|}

Возвращает \true{}, если список \code{l} не содержит хотя бы одна строка, подходящая по шаблону \code{template}, иначе \false{}.

\subsubsection{\lstinline|(s1 : string) + (s2 : string) : string|}

Возвращает строку содержащую все символы строк \code{s1} и \code{s2}. Полученная строка имеет длину равна суммы длин составляющих.

\subsubsection{\lstinline|(str : string) + (l : list) : list|}

Возвращает новый список, получен при вставке строке \code{str} в начале списка \code{l}.

\subsubsection{\lstinline|(l : list) + (str : string) : list|}

Возвращает новый список, получен при вставке строке \code{str} в конце списка \code{l}.

\subsubsection{\lstinline|(l1 : list) + (l2 : list) : list|}

Возвращает новый список, содержащий все элементы списков \code{l1} и \code{l2}.

\subsubsection{\lstinline|(str : string) * (template : string) : bool|}

Возвращает \true{}, если строка \code{str} подходит по шаблону \code{template}, иначе \false{}.

\subsubsection{\lstinline|(l : list) * (template : string) : bool|}

Возвращает \true{} если все строки списка \code{l} подходят по шаблону \code{template}, иначе \false{}.

\subsubsection{\lstinline|(l : list) * (templates : list) : bool|}

Возвращает \true{} если все строки списка \code{l} подходят по соответственному шаблону из списка \code{templates}, иначе \false{}.

\subsubsection{\lstinline|(s1 : string) ** (s2 : string) : double|}

Возвращает коэффициент эквивалентности получен при сравнении \code{s1} с \code{s2}.

{\bf Эквивалентность} - уровень схожести строк. \lstinline|"Hi! Robert, how do you do?"| относительно \lstinline|"Robert! Hi! How do you do?"| имеет эквивалентность равна единицы. Так как они состоят из одни и те же слова. Но если сравнивать с  \lstinline|"Rich! Hi! How are you?"| оценка снижается до 0,64.

\subsubsection{\lstinline|(l1 : list) ** (l2 : list) : double|}

Возвращает коэффициент эквивалентности получен при сравнении строк из списка \code{l1} со строками из списка \code{l2}.
Для корректности вычисления, каждая строка должна содержать одно слово.

\subsection{Операции над объектами и множеств}

Доступные операции над объектами и множеств перечислены в таблице \ref{objectops}.

\stablethree{1.0cm}{7.0cm}{6.0cm}
{objectops}{Операции над объектами и множеств}
{Ранг}{Операция}{Оператор}
{
3     & равно                   & \lstinline|object == object : bool| \\ \hline
3     & равно                   & \lstinline|set == set : bool|       \\ \hline
3     & не равно                & \lstinline|object != object : bool| \\ \hline
3     & не равно                & \lstinline|set != set : bool|       \\ \hline
3     & включение               & \lstinline|set << object : bool|    \\ \hline
3     & включение               & \lstinline|set << set : bool|       \\ \hline
3     & исключение              & \lstinline|set !< object : bool|    \\ \hline
3     & исключение              & \lstinline|set !< set : bool|       \\ \hline
3     & включение шаблона       & \lstinline|set <* object : bool|    \\ \hline
3     & включение шаблона       & \lstinline|object <* object : bool| \\ \hline
3     & исключение шаблона      & \lstinline|set !* object : bool|    \\ \hline
3     & исключение шаблона      & \lstinline|object !* object : bool| \\ \hline
4     & объединение             & \lstinline|set + set : set|         \\ \hline
4     & симметрическая разность & \lstinline|set -   set : set|       \\ \hline
5     & разность                & \lstinline|set \\ set : set|         \\ \hline
5     & пересечение             & \lstinline|set * set : set|         \\ \hline
6$^+$ & присутствия пересечений & \lstinline|set ** set : bool|       \\
}

Примеры использование операторов присутствуют на листинге \ref{setobjopex}.

\subsubsection{\lstinline|(obj1 : object) == (obj2 : object) : bool|}

Возвращает \true{} если \code{obj1} и \code{obj2} имеют одни и те же поля, значения полях из первого объекта совпадает с значениям одноимённых полях второго объекта, иначе \false{}.

\begin{lstlisting}[caption=Примеры использования операторов над данными типа object и set, label=setobjopex]
`` init
@set1 = [age : int, name : string];
@set2 = [age : int, name : string];
@set3 = [age : int, name : string];

@obj1 = [age = 24, name = "User1"];
@obj2 = [age = 23, name = "User2"];
@obj3 = [age = 26, name = "User3"];
@obj4 = [age = 24, length = 80, height = 40, arc = 1];

@set1.insert @obj1;
@set1.insert @obj2;
@set2.insert @obj3;
@set2.insert @obj2;
@set3.insert @obj2;
@set3.insert @obj1;

`` operators
@set1 == @set2;					`` false
@set1 == @set3;					`` true
@obj1 == @obj2;					`` false
@set2 != @set3;					`` true
@obj2 != @obj3;					`` true

@set1 << @obj2;					`` false
@set1 << @set2;					`` false
@set1 <* [age = 23];			`` true
@obj4 <* [age = 24, arc = 1];	`` true

@set1 + @set2;					`` [@obj1 @obj2 @obj3]
@set1 - @set2;					`` [@obj1 @obj3]
@set1 \ @set2;					`` [@obj1]
@set1 * @set2;					`` [@obj2]

@set1 ** @set2;					`` true
\end{lstlisting}

\subsubsection{\lstinline|(set1 : set) == (set2 : set) : bool|}

Возвращает \true{} если \code{set1} и \code{set2} имеют один и тоже заголовок, всё объекты из первой множестве приличествуют во вторым и наоборот, иначе \false{}.

\subsubsection{\lstinline|(obj1 : object) != (obj2 : object) : bool|}

Возвращает \true{} если один из объектов имеет поле, отсутствующее в другом или значения поле первого отличается от значении одноимённой поле второго объекта, иначе \false{}.

\subsubsection{\lstinline|(set1 : set) != (set2 : set) : bool|}

Возвращает \true{} если количество объектов во втором объекте отличается от количества объектов в первом или существует объект присутствующий только в одной множестве, иначе \false{}.

\subsubsection{\lstinline|(s : set) << (obj : object) : bool|}

Возвращает \true{}, если множество \code{s} содержит объект \code{obj}, иначе \false{}.

\subsubsection{\lstinline|(set1 : set) << (set2 : set) : bool|}

Возвращает \true, если множество \code{set1} содержит подмножество \code{set2}, иначе \false.

\subsubsection{\lstinline|(s : set) !< (obj : object) : bool|}

Возвращает \true{}, если множество \code{s} не содержит объект \code{obj}, иначе \false{}.

\subsubsection{\lstinline|(set1 : set) !< (set2 : set) : bool|}

Возвращает \true, если множество \code{set1} не содержит подмножество \code{set2}, иначе \false.

\subsubsection{\lstinline|(s : set) <* (subobj : object) : bool|}

Возвращает \true{}, если множество \code{s} содержит под объект \code{subobj}, иначе \false{}.

\subsubsection{\lstinline|(obj : object) <* (subobj : object) : bool|}

Возвращает \true{} если каждое поле объекта \code{subobj} содержится в объекте \code{obj} и значение одноимённых полях совпадает, иначе \false{}.

\subsubsection{\lstinline|(s : set) !* (subobj : object) : bool|}

Возвращает \true{}, если множество \code{s} не содержит под объект \code{subobj}, иначе \false{}.

\subsubsection{\lstinline|(obj : object) !* (subobj : object) : bool|}

Возвращает \false{} если каждое поле объекта \code{subobj} содержится в объекте \code{obj} и значение одноимённых полях совпадает, иначе \true{}.

\subsubsection{\lstinline|(set1 : set) + (set2 : set) : set|}

Возвращает новое множество содержащая все объекты множеств \code{set1} и \code{set2}.

\subsubsection{\lstinline|(set1 : set) - (set2 : set) : set|}

Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}, и все объекты множестве \code{set2}, отсутствующих в \code{set1}.

\subsubsection{\lstinline|(set1 : set) \\ (set2 : set) : set|}

Возвращает новое множество содержащая все объекты множества \code{set1}, отсутствующих в множестве \code{set2}.

\subsubsection{\lstinline|(set1 : set) * (set2 : set) : set|}

Возвращает новое множество содержащая все объекты , которые приличествуют в \code{set1} и \code{set2}.

\subsubsection{\lstinline|(set1 : set) ** (set2 : set) : bool|}

Возвращает \true, если множества \code{set1} и \code{set2} пересекаются, иначе \false.

\subsection{{\color{lightblue}void} операторы}

Все \void{} операторы делят данных на 2 типа \void{} и не \void{}. Второй тип в дальнейшем будет отмечен как \code{any}, он может быть один из следующих типов: \integer{}, \double{}, \str{}, \listtype{}, \object{}, \set{}, \element{}. \void{} операторы перечислены в таблице \ref{voidops}.

\stablethree{1.0cm}{7.0cm}{6.0cm}
{voidops}{Операции над объектами и множеств}
{Ранг}{Операция}{Оператор}
{
2 & альтернативный выбор & \lstinline`void | void : void`       \\ \hline
2 & альтернативный выбор & \lstinline`void | any : any`         \\ \hline
2 & альтернативный выбор & \lstinline`any | void : any`         \\ \hline
2 & альтернативный выбор & \lstinline`any | any : any`          \\ \hline
2 & первичный выбор      & \lstinline|void \& void : void|      \\ \hline
2 & первичный выбор      & \lstinline|any \& void : void|       \\ \hline
2 & первичный выбор      & \lstinline|void \& any : void|       \\ \hline
2 & первичный выбор      & \lstinline|any \& any : any|         \\ \hline
2 & вторичный выбор      & \lstinline|void ~ void : void|       \\ \hline
2 & вторичный выбор      & \lstinline|void ~ any : void|        \\ \hline
2 & вторичный выбор      & \lstinline|any ~ void : void|        \\ \hline
2 & вторичный выбор      & \lstinline|any ~ any : any|          \\ \hline
2 & исключающий выбор    & \lstinline|void \^ void : void|      \\ \hline
2 & исключающий выбор    & \lstinline|void \^ any : any|        \\ \hline
2 & исключающий выбор    & \lstinline|any \^ void : any|        \\ \hline
2 & исключающий выбор    & \lstinline|any \^ any : void|        \\ \hline
2 & коллекционный выбор  & \lstinline|void \% void : void|      \\ \hline
2 & коллекционный выбор  & \lstinline|void \% any : any|        \\ \hline
2 & коллекционный выбор  & \lstinline|any \% void : any|        \\ \hline
2 & коллекционный выбор  & \lstinline|int \% int : int|         \\ \hline
2 & коллекционный выбор  & \lstinline|double \% double : double|\\ \hline
2 & коллекционный выбор  & \lstinline|string \% string : list|  \\ \hline
2 & коллекционный выбор  & \lstinline|list \% string : list|    \\ \hline
2 & коллекционный выбор  & \lstinline|list \% list : list|      \\ \hline
2 & коллекционный выбор  & \lstinline|object \% object : set|   \\ \hline
2 & коллекционный выбор  & \lstinline|set \% object : set|      \\ \hline
2 & коллекционный выбор  & \lstinline|set \% set : set|         \\ \hline
}

\subsubsection{\lstinline`(arg1 : void or any) | (arg2 : void or any) : (void or any)`}

Возвращаемый результат оператором альтернативного выбора, в зависимости от аргументов, указан в третьем столбце таблицы \ref{orhacktable}.

\begin{table}[htb]
	\caption{Оператор альтернативный выбор}
	\label{orhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \| arg2} \\ \hline
		\void{}     & \void{}     & \void{}  			\\ \hline
		\void{}     & \code{any}  & \code{arg2}  		\\ \hline
		\code{any}  & \void{}     & \code{arg1}  		\\ \hline
		\code{any}  & \code{any}  & \code{arg1}  		\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline|(void or any) \& (void or any) : (void or any)|}

Возвращаемый результат оператором первичного выбора, в зависимости от аргументов, указан в третьем столбце таблицы \ref{andhacktable}.

\begin{table}[htb]
	\caption{Оператор первичный выбор}
	\label{andhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \& arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg1}   		\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline|(void or any) ~ (void or any) : void or any|}

Возвращаемый результат оператором вторичного выбора, в зависимости от аргументов, указан в третьем столбце таблицы \ref{eqhacktable}.

\begin{table}[htb]
	\caption{Оператор вторичный выбор}
	\label{eqhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \~ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \void{}   			\\ \hline
		\code{any}  & \void{}     & \void{}   			\\ \hline
		\code{any}  & \code{any}  & \code{arg2}   		\\ \hline
	\end{tabular}
	\vspace{-2em}
\end{table}

\subsubsection{\lstinline|(void or any) ^ (void or any) : (void or any)|}

Возвращаемый результат оператором исключающего выбора, в зависимости от аргументов, указан в третьем столбце таблицы \ref{xorhacktable}.

\begin{table}[htb]
	\caption{Оператор исключающий выбор}
	\label{xorhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \^ arg2} \\ \hline
		\void{}     & \void{}     & \void{}   			\\ \hline
		\void{}     & \code{any}  & \code{arg2}   		\\ \hline
		\code{any}  & \void{}     & \code{arg1}   		\\ \hline
		\code{any}  & \code{any}  & \void{}   			\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

\subsubsection{\lstinline|(void or any) \% (void or any) : (void or any)|}

	Возвращаемый результат оператором исключающего выбора, в зависимости от аргументов, указан в третьем столбце таблицы \ref{centhacktable}.

\begin{table}[htb]
	\caption{Оператор коллекционный выбор}
	\label{centhacktable}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{arg1} & \code{arg2} & \code{arg1 \% arg2}			\\ \hline
		\void{}     & \void{}     & \void{}						\\ \hline
		\void{}     & \code{any}  & \code{arg2}					\\ \hline
		\code{any}  & \void{}     & \code{arg1}					\\ \hline
		\integer{}  & \integer{}  & \integer{}					\\ \hline
		\double{}   & \double{}   & \double{}					\\ \hline
		\str{}      & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\listtype{} & \str{}      & \code{list - [arg1 arg2]}	\\ \hline
		\listtype{} & \listtype{} & \code{list - [arg1 arg2]}	\\ \hline
		\object{}   & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
		\set{}      & \object{}   & \code{set - [arg1 arg2]}	\\ \hline
		\set{}      & \set{}      & \code{set - [arg1 arg2]}	\\ \hline
	\end{tabular}
	\vspace{0em}
\end{table}

Для аргументов типов \integer{} и \double{}, вызывается функция \code{Numbers.process}, перед использованием установите какую операцию нужно выполнять с числами, использую функцию \code{Numbers.setProcess} с одни из следующих аргументов: \code{Numbers'sum} - сумма, \code{Numbers'product} - произведение, \code{Numbers'max} - максимум, \code{Numbers'min} - минимум. После использования оператора, вызываете \code{Numbers.restoreProcess} чтобы восстановить исходные настройки.

\subsection{Оператор объединения данных}

{\bf Квадратные скобки} или {\bf оператор объединения данных} позволяет создавать объекты следующих типов данных \listtype{}, \set{} и \object{}.

\code{[] : list} создаёт пустой список.

\code{[string ...] : list} создаёт заполненный список, он может содержать как константные литеры, так и вызовы на функций возвращающие строки. Пример: \code{["a", "b", "c"]}.

\code{[list ...] : list} объединяет несколько списков в один.

\code{[string or list ...] : list} - строки и списки можно смешать.

\code{[arg ...] : object} создаёт объект имеющие поля (каждое поле описывается в виде аргумента), аргумент описывается следующим образом \code{name = value}, где \code{value} - значение, \code{name} - название аргумента. Пример \code{[number = 2, str = "str"]}.

\code{[param ...] : set} создаёт множество с указанным заголовкам, каждый столбец описывается в виде параметра, параметр описывается следующим образом \code{name : type}, где \code{type} - тип значения, \code{name} - название параметра. Пример \code{[number : int, str : string]}.

\code{[object ...] : set} создаёт множество из несколько объектов.

\code{[set ...] : set} объединяет несколько множеств в одной.

\code{[object or set ...] : set} объекты и множества также можно смешать.

%\newpage
