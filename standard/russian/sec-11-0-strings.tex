\section{Строки}

{\bf Строки} (тип \str{}) позволяет хранить и манипулировать фрагменты текста. 

\subsection{Свойства}

В дальнейшем свойства будут отмечены следующим маркером: \code{[r/w]} - доступно для чтения и записи, \code{[r/o]} - доступно только для чтения, \code{[w/o]} - доступно только для записи,  \code{[r/*]} - доступно для записи только в режиме автоматизации, \code{[*/*]} - доступ будет конкретизирован потом.

Строки имеют следующее дополнительные свойства:
\begin{icItems}
\item
	\code{[r/o] string'empty : bool};
\item
	\code{[r/o] string'length : int};
\item
	\code{[r/o] string'last : string};
\item
	\lstinline|[r/o] string'(<int>n) : string|.
\end{icItems}

\

На листинге \ref{stringprop} представлен код, использующий выше перечисленных свойства.

\subsubsection{\code{[r/o] string'empty : bool}}

Строка считается пустой если количество содержащих символов равна нулю;

\begin{lstlisting}[caption=Свойства класса string, label=stringprop]
@empty = "";
@fonts = "Arial, Helvetica, Times, Courier";

@empty'empty; `` true
@fonts'empty; `` false

@empty'length; `` 0
@fonts'length; `` 32

@empty'last; `` error
@fonts'last; `` "r"

@empty'0; `` error
@fonts'0; `` "A"
\end{lstlisting}

\subsubsection{\code{[r/o] string'length : int}}

Длина строки равна количеству символов в строке;

\subsubsection{\code{[r/o] string'last : char}}

Последний символ строки, то же самое что и \lstinline|string.at (string'length - 1)|.

Возможные исключения: \ferror{EmptyString}.

\subsubsection{\lstinline|[r/o] string'(<int> n) : string|}

n-й символ строки. n должен быть целым литералов, примеры \lstinline|@str'0; @string'2|.

Возможные исключения: \ferror{OutOfBounds}.

\subsection{Методы}

Строки имеют следующий набор дополнительных методов:
\begin{icItems}
\item
	\lstinline|string.append <string>str : string|;
\item
	\lstinline|string.at <int>i : string|;
\item
	\lstinline|string.beginsWith <string>str : bool|;
\item
	\lstinline|string.compare <string>str <bool>caseSensitive = true : bool|;
\item
	\lstinline|string.count <string>str : int|;
\item
	\lstinline|string.endsWith <string>str : bool|;
\item
	\lstinline|string.indexOf <string>str <int>startPos = 0 : int|;
\item
	\lstinline|string.insert <string>str <int>pos : string|;
\item
	\lstinline|string.lastIndexOf <string>str <int>startPos = -1 : int|;
\item
	\lstinline|string.left <int>n : string|;
\item
	\lstinline|string.leftJustified <int>width <string>fillChar <bool>truncate = false :string|;
\item
	\lstinline|string.mid <int>pos <int>n = -1 : string|;
\item
	\lstinline|string.prepend <string>str : string|;
\item
	\lstinline|string.remove <int>pos <int>n : string|;
\item
	\lstinline|string.remove <string>str <bool>caseSensitive = true : string|;
\item
	\lstinline|string.replace <int>pos <int>n <string>after : string|;
\item
	\lstinline|string.replace <string>before <string>after : string|;
\item
	\lstinline|string.right <int>n : string|;
\item
	\lstinline|string.rightJustified <int>width <string>fillChar <bool>truncate = false:string|;
\item
	\lstinline|string.split <string>separator <bool>keepEmptyParts = true <bool>caseSensitive = true : list|;
\item
	\lstinline|string.substring <int>begin <int>end : string|;
\item
	\lstinline|string.trim <bool>justWhitespace = true : string|.
\end{icItems}

Некоторые методы пропущены, они будут представлены в главе \ref{regex}; Код, использующий выше перечисленных методов представлен на листинге \ref{stringmethods}.

\begin{lstlisting}[caption=Методы класса string, label=stringmethods]
@empty = "";
@fonts = "Arial, Helvetica, Times, Courier";
@index = 2;

@empty.append "data";   `` "data"
@empty.append @fonts'0; `` "dataA"
@empty = "";

@empty.at @index; `` error
@fonts.at @index; `` i
@fonts.at 1;	  `` r

@empty.beginsWith "";      `` true
@fonts.beginsWith "Arial"; `` true

@empty.compare "data"; `` false
@empty.compare "";     `` true

@fonts.count ",";      `` 3
@fonts.count @fonts'0; `` 1

@fonts.endsWith "Courier"; `` true
@fonts.endsWith "Arial";   `` false

@fonts.indexOf "Courier"; `` 25
@fonts.indexOf @fonts'11; `` 8

@data = "10"
@data.insert "data" 1;   `` "1data0"
@data.insert @fonts'0 2; `` "1dAata0"

@fonts.lastIndexOf "e";      `` 30
@fonts.lastIndexOf @fonts'8; `` 30

@fonts.left 5; `` "Arial"

@data = "10";
@data.leftJustified 4 "0"; `` "0010"
@data.mid 1 2;             `` "01"

@data.prepend "11";     `` "1100010"
@data.prepend @fonts'0; `` "A1100010"

@data.remove 2 2;  `` "11010"
@data.remove "01"; `` "110"

@data.replace 2 1 "0101"; `` "110101"
@data.replace "01" "01";  `` "111010"

@data.right 4; 				`` "1010"
@data.rightJustified 8 "0"; `` "11101000"

@fonts.split ", ";     `` ["Arial", "Helvica", "Times", "Curier"]
@fonts.split @fonts'5; `` ["Arial", " Helvica", " Times", " Curier"];

@data.substring 1 3; `` "11"

@str = " , 34px \n";
@str.trim;       `` ", 34px"
@str.trim false; `` "34px"
\end{lstlisting}

\subsubsection{\lstinline|string.append <string>str : string|}

Вставит строку \code{str} в конце строки.

\subsubsection{\lstinline|string.at <int>i : string|}

Возвращает ссылка на \code{i}-й символ.

Возможные исключения: \ferror{OutOfBounds}.

\subsubsection{\lstinline|string.beginsWith <string>str : bool|}

Возвращает \true{}, если начало строки совпадает с \code{str}, иначе \false{}.

\subsubsection{\lstinline|string.compare <string>str <bool>caseSensitive = true : bool|}

Сравнивает строки, возвращает \true{} если они равны, иначе \false{}. Аргумент \code{caseSensitive} может быть пропущен, если установить его в \false{}, то регистр букв будет проигнорирован.

\subsubsection{\lstinline|string.count <string>str : int|}

Считает сколько раз подстрока \code{str} встречается в строке.

\subsubsection{\lstinline|string.endsWith <string>str : bool|}

Возвращает \true{}, если конец строки совпадает с \code{str}, иначе \false{}.

\subsubsection{\lstinline|string.indexOf <string>str <int>startPos = 0 : int|}

Возвращает индекс первой нахождения подстроки \code{str} в строке, ища вперёд с позиции \code{startPos}, если подстрока не найдено возвращает -1.

\subsubsection{\lstinline|string.insert <string>str <int>pos : string|}

Вставит строку \code{str} в позиции \code{pos}.

\subsubsection{\lstinline|string.lastIndexOf <string>str <int>startPos = -1 : int|}

Возвращает индекс первой нахождения подстроки \code{str} в строке, ища назад с позиции \code{startPos}, если подстрока не найдена возвращает -1.

\subsubsection{\lstinline|string.left <int>n : string|}

Возвращает подстроку содержащая первый \code{n} символы.

\subsubsection{\lstinline|string.leftJustified <int>width <string>fillChar <bool>truncate = false :|\\* \lstinline|string|}

Возвращает строку длины \code{width}, содержащую эту строку, в конце ставится \code{width - .length} символов \code{fillChar}. Если \code{truncate == true} и \code{width < .length}, то последние \code{.length - width} символы будут удалены.

\subsubsection{\lstinline|string.mid <int>pos <int>n = -1 : string|}

Возвращает строку содержащую \code{n} символы строки, начиная с позиции \code{pos}. Будет возвращена пустая строка если установленный интервал выходит за рамки строки. Если \code{n == -1} то будут возвращены все доступные символы начиная с позицией \code{pos}.

\subsubsection{\lstinline|string.prepend <string>str : string|}

Вставит строку \code{str} в начале строки.

\subsubsection{\lstinline|string.remove <int>pos <int>n : string|}

Удаляет \code{n} символы строки начиная с позицией \code{pos}.

\subsubsection{\lstinline|string.remove <string>str <bool>caseSensitive = true : string|}

Удаляет каждое нахождения подстроки \code{str} в строке. Аргумент \code{caseSensitive} может быть пропущен, если установить его в \false{} то регистр букв будет проигнорирован.

\subsubsection{\lstinline|string.replace <int>pos <int>n <string>after : string|}

Заменяет интервал установленный позицией \code{pos} и количеством символов \code{n} строкой \code{after}.

\subsubsection{\lstinline|string.replace <string>before <string>after : string|}

Заменяет каждое нахождение подстроки \code{before} подстрокой \code{after}.

\subsubsection{\lstinline|string.right <int>n : string|}

Возвращает строку содержащую последние \code{n} символы строки.

\subsubsection{\lstinline|string.rightJustified <int>width <string>fillChar <bool>truncate = false :|\\* \lstinline|string|;}

Возвращает строку длины \code{width}, содержащую эту строку, в начале ставится \code{width - .length} символов \code{fillChar}. Если \code{truncate == true} и \code{width < .length}, то первые \code{.length - width} символы будут удалены.

\subsubsection{\lstinline|string.split <string>separator <bool>keepEmptyParts = true <bool>caseSensiti|\\* \lstinline|ve = true : list|}

Разрывает строку на подстроки при каждой нахождения подстроки \code{separator} и собирает список из этих строк. Если \code{separator} не встречается ни разу, будет возвращён список из одной строки - этой строки. Если \code{keepEmptyParts == false} то пустые строки пропускаются.

\subsubsection{\lstinline|string.substring <int>begin <int>end : string|}

Возвращает подстроку содержащую символы строки, от позиции \code{begin} до \code{end}.

\subsubsection{\lstinline|string.trim <bool>justWhitespace = true : string|}

Возвращает строку, копия текущей из которого удаляются пробельные символы с начало и конце строки. Если \lstinline|justWhitespace == false|, то будут удалены все знаки которые не является буквой или цифрой.

% \subsubsection{}

%\newpage
